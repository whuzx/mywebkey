/*
Copyright (C) 2012  Peter Mora, Zoltan Papp

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
# 1 "webkey-2.09/service/webkey.cpp"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "webkey-2.09/service/webkey.cpp"
# 18 "webkey-2.09/service/webkey.cpp"
# 1 "webkey-2.09/service/webkey.h" 1
# 19 "webkey-2.09/service/webkey.cpp" 2


# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/types.h" 1
# 33 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/types.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stddef.h" 1
# 18 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stddef.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_cprolog.h" 1
# 18 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_cprolog.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/config/features.h" 1
# 42 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/config/features.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_stlport_version.h" 1
# 43 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/config/features.h" 2
# 63 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/config/features.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/config/user_config.h" 1
# 64 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/config/features.h" 2
# 88 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/config/features.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/config/compat.h" 1
# 89 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/config/features.h" 2


# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/config/host.h" 1
# 92 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/config/features.h" 2


# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/config/_system.h" 1
# 64 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/config/_system.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/config/_android.h" 1
# 64 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/config/_android.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/config/_gcc.h" 1
# 65 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/config/_android.h" 2
# 65 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/config/_system.h" 2
# 95 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/config/features.h" 2
# 103 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/config/features.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/config/stl_confix.h" 1
# 104 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/config/features.h" 2
# 218 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/config/features.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/config/_native_headers.h" 1
# 219 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/config/features.h" 2
# 415 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/config/features.h"
namespace std { }
namespace __std_alias = std;
# 536 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/config/features.h"
namespace stlport = std;



namespace _STL = std;
# 19 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_cprolog.h" 2
# 19 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stddef.h" 2
# 34 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stddef.h"
# 1 "/home/petya/download/android-ndk-r8b/toolchains/arm-linux-androideabi-4.4.3/prebuilt/linux-x86/bin/../lib/gcc/arm-linux-androideabi/4.4.3/include/../include/stddef.h" 1 3 4
# 149 "/home/petya/download/android-ndk-r8b/toolchains/arm-linux-androideabi-4.4.3/prebuilt/linux-x86/bin/../lib/gcc/arm-linux-androideabi/4.4.3/include/../include/stddef.h" 3 4
typedef int ptrdiff_t;
# 211 "/home/petya/download/android-ndk-r8b/toolchains/arm-linux-androideabi-4.4.3/prebuilt/linux-x86/bin/../lib/gcc/arm-linux-androideabi/4.4.3/include/../include/stddef.h" 3 4
typedef unsigned int size_t;
# 35 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stddef.h" 2




# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_epilog.h" 1
# 19 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_epilog.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_config_compat_post.h" 1
# 20 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_epilog.h" 2
# 40 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stddef.h" 2
# 34 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/types.h" 2
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/stdint.h" 1
# 31 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/stdint.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stddef.h" 1
# 18 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stddef.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_cprolog.h" 1
# 19 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stddef.h" 2
# 34 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stddef.h"
# 1 "/home/petya/download/android-ndk-r8b/toolchains/arm-linux-androideabi-4.4.3/prebuilt/linux-x86/bin/../lib/gcc/arm-linux-androideabi/4.4.3/include/../include/stddef.h" 1 3 4
# 35 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stddef.h" 2




# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_epilog.h" 1
# 19 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_epilog.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_config_compat_post.h" 1
# 20 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_epilog.h" 2
# 40 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stddef.h" 2
# 32 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/stdint.h" 2
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/_types.h" 1
# 40 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/_types.h"
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/machine/_types.h" 1
# 52 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/machine/_types.h"
typedef __signed char __int8_t;
typedef unsigned char __uint8_t;
typedef short __int16_t;
typedef unsigned short __uint16_t;
typedef int __int32_t;
typedef unsigned int __uint32_t;

typedef long long __int64_t;

typedef unsigned long long __uint64_t;


typedef __int8_t __int_least8_t;
typedef __uint8_t __uint_least8_t;
typedef __int16_t __int_least16_t;
typedef __uint16_t __uint_least16_t;
typedef __int32_t __int_least32_t;
typedef __uint32_t __uint_least32_t;
typedef __int64_t __int_least64_t;
typedef __uint64_t __uint_least64_t;


typedef __int32_t __int_fast8_t;
typedef __uint32_t __uint_fast8_t;
typedef __int32_t __int_fast16_t;
typedef __uint32_t __uint_fast16_t;
typedef __int32_t __int_fast32_t;
typedef __uint32_t __uint_fast32_t;
typedef __int64_t __int_fast64_t;
typedef __uint64_t __uint_fast64_t;


typedef int __intptr_t;
typedef unsigned int __uintptr_t;


typedef __int64_t __intmax_t;
typedef __uint64_t __uintmax_t;


typedef __int32_t __register_t;


typedef unsigned long __vaddr_t;
typedef unsigned long __paddr_t;
typedef unsigned long __vsize_t;
typedef unsigned long __psize_t;


typedef int __clock_t;
typedef int __clockid_t;
typedef long __ptrdiff_t;
typedef int __time_t;
typedef int __timer_t;

typedef __builtin_va_list __va_list;
# 116 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/machine/_types.h"
typedef int __wint_t;
typedef int __rune_t;
typedef void * __wctrans_t;
typedef void * __wctype_t;
# 41 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/_types.h" 2

typedef unsigned long __cpuid_t;
typedef __int32_t __dev_t;
typedef __uint32_t __fixpt_t;
typedef __uint32_t __gid_t;
typedef __uint32_t __id_t;
typedef __uint32_t __in_addr_t;
typedef __uint16_t __in_port_t;
typedef __uint32_t __ino_t;
typedef long __key_t;
typedef __uint32_t __mode_t;
typedef __uint32_t __nlink_t;
typedef __int32_t __pid_t;
typedef __uint64_t __rlim_t;
typedef __uint16_t __sa_family_t;
typedef __int32_t __segsz_t;
typedef __uint32_t __socklen_t;
typedef __int32_t __swblk_t;
typedef __uint32_t __uid_t;
typedef __uint32_t __useconds_t;
typedef __int32_t __suseconds_t;





typedef union {
 char __mbstate8[128];
 __int64_t __mbstateL;
} __mbstate_t;
# 33 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/stdint.h" 2
# 48 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/stdint.h"
typedef __int8_t int8_t;
typedef __uint8_t uint8_t;
typedef __int16_t int16_t;
typedef __uint16_t uint16_t;
typedef __int32_t int32_t;
typedef __uint32_t uint32_t;

typedef __int64_t int64_t;
typedef __uint64_t uint64_t;






typedef int8_t int_least8_t;
typedef int8_t int_fast8_t;

typedef uint8_t uint_least8_t;
typedef uint8_t uint_fast8_t;
# 97 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/stdint.h"
typedef int16_t int_least16_t;
typedef int32_t int_fast16_t;

typedef uint16_t uint_least16_t;
typedef uint32_t uint_fast16_t;
# 130 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/stdint.h"
typedef int32_t int_least32_t;
typedef int32_t int_fast32_t;

typedef uint32_t uint_least32_t;
typedef uint32_t uint_fast32_t;
# 163 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/stdint.h"
typedef int64_t int_least64_t;
typedef int64_t int_fast64_t;

typedef uint64_t uint_least64_t;
typedef uint64_t uint_fast64_t;
# 207 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/stdint.h"
typedef int intptr_t;
typedef unsigned int uintptr_t;
# 232 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/stdint.h"
typedef uint64_t uintmax_t;
typedef int64_t intmax_t;
# 268 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/stdint.h"
typedef long int ssize_t;
# 35 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/types.h" 2
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/cdefs.h" 1
# 65 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/cdefs.h"
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/cdefs_elf.h" 1
# 66 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/cdefs.h" 2
# 506 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/cdefs.h"
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/android/api-level.h" 1
# 507 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/cdefs.h" 2
# 36 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/types.h" 2

# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/linux/posix_types.h" 1
# 15 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/linux/posix_types.h"
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/linux/stddef.h" 1
# 15 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/linux/stddef.h"
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/linux/compiler.h" 1
# 16 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/linux/stddef.h" 2
# 16 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/linux/posix_types.h" 2
# 32 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/linux/posix_types.h"
typedef struct {
 unsigned long fds_bits [(1024/(8 * sizeof(unsigned long)))];
} __kernel_fd_set;

typedef void (*__kernel_sighandler_t)(int);

typedef int __kernel_key_t;
typedef int __kernel_mqd_t;

# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/asm/posix_types.h" 1
# 15 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/asm/posix_types.h"
typedef unsigned long __kernel_ino_t;
typedef unsigned short __kernel_mode_t;
typedef unsigned short __kernel_nlink_t;
typedef long __kernel_off_t;
typedef int __kernel_pid_t;
typedef unsigned short __kernel_ipc_pid_t;
typedef unsigned short __kernel_uid_t;
typedef unsigned short __kernel_gid_t;
typedef unsigned int __kernel_size_t;
typedef int __kernel_ssize_t;
typedef int __kernel_ptrdiff_t;
typedef long __kernel_time_t;
typedef long __kernel_suseconds_t;
typedef long __kernel_clock_t;
typedef int __kernel_timer_t;
typedef int __kernel_clockid_t;
typedef int __kernel_daddr_t;
typedef char * __kernel_caddr_t;
typedef unsigned short __kernel_uid16_t;
typedef unsigned short __kernel_gid16_t;
typedef unsigned int __kernel_uid32_t;
typedef unsigned int __kernel_gid32_t;

typedef unsigned short __kernel_old_uid_t;
typedef unsigned short __kernel_old_gid_t;
typedef unsigned short __kernel_old_dev_t;


typedef long long __kernel_loff_t;


typedef struct {



 int __val[2];

} __kernel_fsid_t;
# 42 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/linux/posix_types.h" 2
# 38 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/types.h" 2
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/asm/types.h" 1
# 17 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/asm/types.h"
typedef unsigned short umode_t;

typedef __signed__ char __s8;
typedef unsigned char __u8;

typedef __signed__ short __s16;
typedef unsigned short __u16;

typedef __signed__ int __s32;
typedef unsigned int __u32;


typedef __signed__ long long __s64;
typedef unsigned long long __u64;
# 39 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/types.h" 2
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/linux/types.h" 1
# 21 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/linux/types.h"
typedef __u16 __le16;
typedef __u16 __be16;
typedef __u32 __le32;
typedef __u32 __be32;

typedef __u64 __le64;
typedef __u64 __be64;


struct ustat {
 __kernel_daddr_t f_tfree;
 __kernel_ino_t f_tinode;
 char f_fname[6];
 char f_fpack[6];
};
# 40 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/types.h" 2
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/machine/kernel.h" 1
# 34 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/machine/kernel.h"
typedef unsigned long __kernel_blkcnt_t;
typedef unsigned long __kernel_blksize_t;


typedef unsigned long __kernel_fsblkcnt_t;
typedef unsigned long __kernel_fsfilcnt_t;
typedef unsigned int __kernel_id_t;
# 41 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/types.h" 2

typedef __u32 __kernel_dev_t;
# 52 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/types.h"
typedef __kernel_blkcnt_t blkcnt_t;
typedef __kernel_blksize_t blksize_t;
typedef __kernel_clock_t clock_t;
typedef __kernel_clockid_t clockid_t;
typedef __kernel_dev_t dev_t;
typedef __kernel_fsblkcnt_t fsblkcnt_t;
typedef __kernel_fsfilcnt_t fsfilcnt_t;
typedef __kernel_gid32_t gid_t;
typedef __kernel_id_t id_t;
typedef __kernel_ino_t ino_t;
typedef __kernel_key_t key_t;
typedef __kernel_mode_t mode_t;
typedef __kernel_nlink_t nlink_t;


typedef __kernel_off_t off_t;

typedef __kernel_loff_t loff_t;
typedef loff_t off64_t;

typedef __kernel_pid_t pid_t;
# 99 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/types.h"
typedef __kernel_suseconds_t suseconds_t;
typedef __kernel_time_t time_t;
typedef __kernel_uid32_t uid_t;
typedef signed long useconds_t;

typedef __kernel_daddr_t daddr_t;
typedef __kernel_timer_t timer_t;
typedef __kernel_mqd_t mqd_t;

typedef __kernel_caddr_t caddr_t;
typedef unsigned int uint_t;
typedef unsigned int uint;


# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/sysmacros.h" 1
# 36 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/sysmacros.h"
static __inline__ int major(dev_t _dev)
{
  return (_dev >> 8) & 0xfff;
}

static __inline__ int minor(dev_t _dev)
{
  return (_dev & 0xff) | ((_dev >> 12) & 0xfff00);
}

static __inline__ dev_t makedev(int __ma, int __mi)
{
  return ((__ma & 0xfff) << 8) | (__mi & 0xff) | ((__mi & 0xfff00) << 12);
}
# 114 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/types.h" 2


typedef unsigned char u_char;
typedef unsigned short u_short;
typedef unsigned int u_int;
typedef unsigned long u_long;

typedef uint32_t u_int32_t;
typedef uint16_t u_int16_t;
typedef uint8_t u_int8_t;
typedef uint64_t u_int64_t;
# 22 "webkey-2.09/service/webkey.cpp" 2
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/stat.h" 1
# 33 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/stat.h"
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/time.h" 1
# 33 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/time.h"
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/linux/time.h" 1
# 19 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/linux/time.h"
struct timespec {
 time_t tv_sec;
 long tv_nsec;
};


struct timeval {
 time_t tv_sec;
 suseconds_t tv_usec;
};

struct timezone {
 int tz_minuteswest;
 int tz_dsttime;
};
# 47 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/linux/time.h"
struct itimerspec {
 struct timespec it_interval;
 struct timespec it_value;
};

struct itimerval {
 struct timeval it_interval;
 struct timeval it_value;
};
# 34 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/time.h" 2

extern "C" {

extern int gettimeofday(struct timeval *, struct timezone *);
extern int settimeofday(const struct timeval *, const struct timezone *);

extern int getitimer(int, struct itimerval *);
extern int setitimer(int, const struct itimerval *, struct itimerval *);

extern int utimes(const char *, const struct timeval *);
# 76 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/time.h"
}
# 34 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/stat.h" 2
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/linux/stat.h" 1
# 35 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/stat.h" 2

# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/endian.h" 1
# 31 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/endian.h"
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/endian.h" 1
# 162 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/endian.h"
extern "C" {
__uint64_t htobe64(__uint64_t);
__uint32_t htobe32(__uint32_t);
__uint16_t htobe16(__uint16_t);
__uint64_t betoh64(__uint64_t);
__uint32_t betoh32(__uint32_t);
__uint16_t betoh16(__uint16_t);

__uint64_t htole64(__uint64_t);
__uint32_t htole32(__uint32_t);
__uint16_t htole16(__uint16_t);
__uint64_t letoh64(__uint64_t);
__uint32_t letoh32(__uint32_t);
__uint16_t letoh16(__uint16_t);
}
# 32 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/endian.h" 2
# 37 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/stat.h" 2

extern "C" {





struct stat {
    unsigned long long st_dev;
    unsigned char __pad0[4];

    unsigned long __st_ino;
    unsigned int st_mode;
    unsigned int st_nlink;

    unsigned long st_uid;
    unsigned long st_gid;

    unsigned long long st_rdev;
    unsigned char __pad3[4];

    long long st_size;
    unsigned long st_blksize;
    unsigned long long st_blocks;

    unsigned long st_atime;
    unsigned long st_atime_nsec;

    unsigned long st_mtime;
    unsigned long st_mtime_nsec;

    unsigned long st_ctime;
    unsigned long st_ctime_nsec;

    unsigned long long st_ino;
};
# 81 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/stat.h"
extern int chmod(const char *, mode_t);
extern int fchmod(int, mode_t);
extern int mkdir(const char *, mode_t);

extern int stat(const char *, struct stat *);
extern int fstat(int, struct stat *);
extern int lstat(const char *, struct stat *);
extern int mknod(const char *, mode_t, dev_t);
extern mode_t umask(mode_t);





static __inline__ int mkfifo(const char *__p, mode_t __m)
{
  return mknod(__p, (__m & ~00170000) | 0010000, (dev_t)0);
}

extern int fstatat(int dirfd, const char *path, struct stat *buf, int flags);
extern int mkdirat(int dirfd, const char *pathname, mode_t mode);
extern int fchownat(int dirfd, const char *path, uid_t owner, gid_t group, int flags);
extern int fchmodat(int dirfd, const char *path, mode_t mode, int flags);
extern int renameat(int olddirfd, const char *oldpath, int newdirfd, const char *newpath);

}
# 23 "webkey-2.09/service/webkey.cpp" 2
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/errno.h" 1
# 32 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/errno.h"
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/linux/errno.h" 1
# 15 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/linux/errno.h"
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/asm/errno.h" 1
# 15 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/asm/errno.h"
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/asm-generic/errno.h" 1
# 15 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/asm-generic/errno.h"
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/asm-generic/errno-base.h" 1
# 16 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/asm-generic/errno.h" 2
# 16 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/asm/errno.h" 2
# 16 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/linux/errno.h" 2
# 33 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/errno.h" 2

extern "C" {
# 45 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/errno.h"
extern int __set_errno(int error);


extern volatile int* __errno(void);




}
# 24 "webkey-2.09/service/webkey.cpp" 2
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/signal.h" 1
# 32 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/signal.h"
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/limits.h" 1
# 86 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/limits.h"
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/limits.h" 1
# 30 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/limits.h"
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/linux/limits.h" 1
# 31 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/limits.h" 2
# 44 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/limits.h"
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/machine/internal_types.h" 1
# 45 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/limits.h" 2


# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/machine/limits.h" 1
# 48 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/limits.h" 2
# 87 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/limits.h" 2


# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/syslimits.h" 1
# 90 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/limits.h" 2
# 33 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/signal.h" 2
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/string.h" 1
# 32 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/string.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stddef.h" 1
# 18 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stddef.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_cprolog.h" 1
# 19 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stddef.h" 2
# 34 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stddef.h"
# 1 "/home/petya/download/android-ndk-r8b/toolchains/arm-linux-androideabi-4.4.3/prebuilt/linux-x86/bin/../lib/gcc/arm-linux-androideabi/4.4.3/include/../include/stddef.h" 1 3 4
# 35 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stddef.h" 2




# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_epilog.h" 1
# 19 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_epilog.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_config_compat_post.h" 1
# 20 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_epilog.h" 2
# 40 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stddef.h" 2
# 33 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/string.h" 2
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/malloc.h" 1
# 32 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/malloc.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stddef.h" 1
# 18 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stddef.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_cprolog.h" 1
# 19 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stddef.h" 2
# 34 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stddef.h"
# 1 "/home/petya/download/android-ndk-r8b/toolchains/arm-linux-androideabi-4.4.3/prebuilt/linux-x86/bin/../lib/gcc/arm-linux-androideabi/4.4.3/include/../include/stddef.h" 1 3 4
# 35 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stddef.h" 2




# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_epilog.h" 1
# 19 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_epilog.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_config_compat_post.h" 1
# 20 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_epilog.h" 2
# 40 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stddef.h" 2
# 33 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/malloc.h" 2

extern "C" {

extern __attribute__((malloc)) void* malloc(size_t);
extern __attribute__((malloc)) void* calloc(size_t, size_t);
extern __attribute__((malloc)) void* realloc(void *, size_t);
extern void free(void *);

extern void* memalign(size_t alignment, size_t bytesize);
extern void* valloc(size_t bytesize);
extern void* pvalloc(size_t bytesize);
extern int mallopt(int param_number, int param_value);
extern size_t malloc_footprint(void);
extern size_t malloc_max_footprint(void);

struct mallinfo {
    size_t arena;
    size_t ordblks;
    size_t smblks;
    size_t hblks;
    size_t hblkhd;
    size_t usmblks;
    size_t fsmblks;
    size_t uordblks;
    size_t fordblks;
    size_t keepcost;
};

extern struct mallinfo mallinfo(void);
# 78 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/malloc.h"
extern size_t malloc_usable_size(void* block);
# 99 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/malloc.h"
extern void malloc_stats(void);

}
# 34 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/string.h" 2

extern "C" {

extern void* memccpy(void *, const void *, int, size_t);
extern void* memchr(const void *, int, size_t);
extern void* memrchr(const void *, int, size_t);
extern int memcmp(const void *, const void *, size_t);
extern void* memcpy(void *, const void *, size_t);
extern void* memmove(void *, const void *, size_t);
extern void* memset(void *, int, size_t);
extern void* memmem(const void *, size_t, const void *, size_t);
extern void memswap(void *, void *, size_t);

extern char* index(const char *, int);
extern char* rindex(const char *, int);
extern char* strchr(const char *, int);
extern char* strrchr(const char *, int);

extern size_t strlen(const char *);
extern int strcmp(const char *, const char *);
extern char* strcpy(char *, const char *);
extern char* strcat(char *, const char *);

extern int strcasecmp(const char *, const char *);
extern int strncasecmp(const char *, const char *, size_t);
extern char* strdup(const char *);

extern char* strstr(const char *, const char *);
extern char* strcasestr(const char *haystack, const char *needle);
extern char* strtok(char *, const char *);
extern char* strtok_r(char *, const char *, char**);

extern char* strerror(int);
extern int strerror_r(int errnum, char *buf, size_t n);

extern size_t strnlen(const char *, size_t);
extern char* strncat(char *, const char *, size_t);
extern char* strndup(const char *, size_t);
extern int strncmp(const char *, const char *, size_t);
extern char* strncpy(char *, const char *, size_t);

extern size_t strlcat(char *, const char *, size_t);
extern size_t strlcpy(char *, const char *, size_t);

extern size_t strcspn(const char *, const char *);
extern char* strpbrk(const char *, const char *);
extern char* strsep(char **, const char *);
extern size_t strspn(const char *, const char *);

extern char* strsignal(int sig);

extern int strcoll(const char *, const char *);
extern size_t strxfrm(char *, const char *, size_t);

}
# 34 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/signal.h" 2

# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/asm/signal.h" 1
# 17 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/asm/signal.h"
struct siginfo;


typedef unsigned long sigset_t;
# 82 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/asm/signal.h"
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/asm-generic/signal.h" 1
# 28 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/asm-generic/signal.h"
typedef void __signalfn_t(int);
typedef __signalfn_t *__sighandler_t;

typedef void __restorefn_t(void);
typedef __restorefn_t *__sigrestore_t;
# 83 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/asm/signal.h" 2

struct sigaction {
 union {
 __sighandler_t _sa_handler;
 void (*_sa_sigaction)(int, struct siginfo *, void *);
 } _u;
 sigset_t sa_mask;
 unsigned long sa_flags;
 void (*sa_restorer)(void);
};




typedef struct sigaltstack {
 void *ss_sp;
 int ss_flags;
 size_t ss_size;
} stack_t;
# 36 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/signal.h" 2


# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/asm/siginfo.h" 1
# 15 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/asm/siginfo.h"
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/asm-generic/siginfo.h" 1
# 18 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/asm-generic/siginfo.h"
typedef union sigval {
 int sival_int;
 void *sival_ptr;
} sigval_t;
# 42 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/asm-generic/siginfo.h"
typedef struct siginfo {
 int si_signo;
 int si_errno;
 int si_code;

 union {
 int _pad[((128 - (3 * sizeof(int))) / sizeof(int))];

 struct {
 pid_t _pid;
 __kernel_uid32_t _uid;
 } _kill;

 struct {
 timer_t _tid;
 int _overrun;
 char _pad[sizeof( __kernel_uid32_t) - sizeof(int)];
 sigval_t _sigval;
 int _sys_private;
 } _timer;

 struct {
 pid_t _pid;
 __kernel_uid32_t _uid;
 sigval_t _sigval;
 } _rt;

 struct {
 pid_t _pid;
 __kernel_uid32_t _uid;
 int _status;
 clock_t _utime;
 clock_t _stime;
 } _sigchld;

 struct {
 void *_addr;



 } _sigfault;

 struct {
 long _band;
 int _fd;
 } _sigpoll;
 } _sifields;
} siginfo_t;
# 194 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/asm-generic/siginfo.h"
typedef struct sigevent {
 sigval_t sigev_value;
 int sigev_signo;
 int sigev_notify;
 union {
 int _pad[((64 - (sizeof(int) * 2 + sizeof(sigval_t))) / sizeof(int))];
 int _tid;

 struct {
 void (*_function)(sigval_t);
 void *_attribute;
 } _sigev_thread;
 } _sigev_un;
} sigevent_t;
# 16 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/asm/siginfo.h" 2
# 39 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/signal.h" 2


extern "C" {

typedef int sig_atomic_t;
# 56 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/signal.h"
extern const char * const sys_siglist[];

static __inline__ int sigismember(sigset_t *set, int signum)
{
    unsigned long *local_set = (unsigned long *)set;
    signum--;
    return (int)((local_set[signum/32] >> (signum%32)) & 1);
}


static __inline__ int sigaddset(sigset_t *set, int signum)
{
    unsigned long *local_set = (unsigned long *)set;
    signum--;
    local_set[signum/32] |= 1UL << (signum%32);
    return 0;
}


static __inline__ int sigdelset(sigset_t *set, int signum)
{
    unsigned long *local_set = (unsigned long *)set;
    signum--;
    local_set[signum/32] &= ~(1UL << (signum%32));
    return 0;
}


static __inline__ int sigemptyset(sigset_t *set)
{
    memset(set, 0, sizeof *set);
    return 0;
}

static __inline__ int sigfillset(sigset_t *set)
{
    memset(set, ~0, sizeof *set);
    return 0;
}



typedef void (*sig_t)(int);
typedef sig_t sighandler_t;


extern __sighandler_t sysv_signal(int, __sighandler_t);
extern __sighandler_t bsd_signal(int, __sighandler_t);


static __inline__ __sighandler_t signal(int s, __sighandler_t f)
{
    return bsd_signal(s,f);
}


extern __sighandler_t __signal(int, __sighandler_t, int);

extern int sigprocmask(int, const sigset_t *, sigset_t *);
extern int sigaction(int, const struct sigaction *, struct sigaction *);

extern int sigpending(sigset_t *);
extern int sigsuspend(const sigset_t *);
extern int sigwait(const sigset_t *set, int *sig);
extern int siginterrupt(int sig, int flag);

extern int raise(int);
extern int kill(pid_t, int);


}
# 25 "webkey-2.09/service/webkey.cpp" 2
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/fcntl.h" 1
# 33 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/fcntl.h"
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/linux/fcntl.h" 1
# 15 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/linux/fcntl.h"
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/asm/fcntl.h" 1
# 20 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/asm/fcntl.h"
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/asm-generic/fcntl.h" 1
# 117 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/asm-generic/fcntl.h"
struct flock {
 short l_type;
 short l_whence;
 off_t l_start;
 off_t l_len;
 pid_t l_pid;

};
# 138 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/asm-generic/fcntl.h"
struct flock64 {
 short l_type;
 short l_whence;
 loff_t l_start;
 loff_t l_len;
 pid_t l_pid;

};
# 21 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/asm/fcntl.h" 2
# 16 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/linux/fcntl.h" 2
# 34 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/fcntl.h" 2
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/unistd.h" 1
# 31 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/unistd.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stddef.h" 1
# 18 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stddef.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_cprolog.h" 1
# 19 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stddef.h" 2
# 34 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stddef.h"
# 1 "/home/petya/download/android-ndk-r8b/toolchains/arm-linux-androideabi-4.4.3/prebuilt/linux-x86/bin/../lib/gcc/arm-linux-androideabi/4.4.3/include/../include/stddef.h" 1 3 4
# 35 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stddef.h" 2




# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_epilog.h" 1
# 19 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_epilog.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_config_compat_post.h" 1
# 20 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_epilog.h" 2
# 40 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stddef.h" 2
# 32 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/unistd.h" 2


# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/select.h" 1
# 36 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/select.h"
extern "C" {

typedef __kernel_fd_set fd_set;

extern int select(int, fd_set *, fd_set *, fd_set *, struct timeval *);
extern int pselect(int n, fd_set *readfds, fd_set *writefds, fd_set *errfds,
                   const struct timespec *timeout, const sigset_t *sigmask);

}
# 35 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/unistd.h" 2
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/sysconf.h" 1
# 33 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/sysconf.h"
extern "C" {
# 131 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/sysconf.h"
extern int sysconf (int name);

}
# 36 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/unistd.h" 2
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/linux/capability.h" 1
# 20 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/linux/capability.h"
typedef struct __user_cap_header_struct {
 __u32 version;
 int pid;
} *cap_user_header_t;

typedef struct __user_cap_data_struct {
 __u32 effective;
 __u32 permitted;
 __u32 inheritable;
} *cap_user_data_t;
# 37 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/unistd.h" 2
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/pathconf.h" 1
# 33 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/pathconf.h"
extern "C" {
# 58 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/pathconf.h"
extern long fpathconf(int fildes, int name);
extern long pathconf(const char *path, int name);

}
# 38 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/unistd.h" 2

extern "C" {
# 51 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/unistd.h"
extern char **environ;
extern __attribute__((__noreturn__)) void _exit(int);

extern pid_t fork(void);
extern pid_t vfork(void);
extern pid_t getpid(void);
extern pid_t gettid(void);
extern pid_t getpgid(pid_t);
extern int setpgid(pid_t, pid_t);
extern pid_t getppid(void);
extern pid_t getpgrp(void);
extern int setpgrp(void);
extern pid_t setsid(void);

extern int execv(const char *, char * const *);
extern int execvp(const char *, char * const *);
extern int execve(const char *, char * const *, char * const *);
extern int execl(const char *, const char *, ...);
extern int execlp(const char *, const char *, ...);
extern int execle(const char *, const char *, ...);
extern int capget(cap_user_header_t hdrp, cap_user_data_t datap);
extern int capset(cap_user_header_t hdrp, const cap_user_data_t datap);


extern int prctl(int option, ...);

extern int nice(int);

extern int setuid(uid_t);
extern uid_t getuid(void);
extern int seteuid(uid_t);
extern uid_t geteuid(void);
extern int setgid(gid_t);
extern gid_t getgid(void);
extern int setegid(gid_t);
extern gid_t getegid(void);
extern int getgroups(int, gid_t *);
extern int setgroups(size_t, const gid_t *);
extern int setreuid(uid_t, uid_t);
extern int setregid(gid_t, gid_t);
extern int setresuid(uid_t, uid_t, uid_t);
extern int setresgid(gid_t, gid_t, gid_t);
extern int getresuid(uid_t *ruid, uid_t *euid, uid_t *suid);
extern int getresgid(gid_t *rgid, gid_t *egid, gid_t *sgid);
extern int issetugid(void);
extern char* getlogin(void);
# 105 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/unistd.h"
extern int access(const char *, int);
extern int link(const char *, const char *);
extern int unlink(const char *);
extern int chdir(const char *);
extern int fchdir(int);
extern int rmdir(const char *);
extern int pipe(int *);
extern int chroot(const char *);
extern int symlink(const char *, const char *);
extern int readlink(const char *, char *, size_t);
extern int chown(const char *, uid_t, gid_t);
extern int fchown(int, uid_t, gid_t);
extern int lchown(const char *, uid_t, gid_t);
extern int truncate(const char *, off_t);
extern char *getcwd(char *, size_t);

extern int sync(void);

extern int close(int);
extern off_t lseek(int, off_t, int);
extern off64_t lseek64(int, off64_t, int);

extern ssize_t read(int, void *, size_t);
extern ssize_t write(int, const void *, size_t);
extern ssize_t pread(int, void *, size_t, off_t);
extern ssize_t pwrite(int, const void *, size_t, off_t);

extern int dup(int);
extern int dup2(int, int);
extern int fcntl(int, int, ...);
extern int ioctl(int, int, ...);
extern int flock(int, int);
extern int fsync(int);
extern int ftruncate(int, off_t);

extern int pause(void);
extern unsigned int alarm(unsigned int);
extern unsigned int sleep(unsigned int);
extern void usleep(unsigned long);

extern int gethostname(char *, size_t);

extern int getdtablesize(void);

extern void *__brk(void *);
extern int brk(void *);
extern void *sbrk(ptrdiff_t);

extern int getopt(int, char * const *, const char *);
extern char *optarg;
extern int optind, opterr, optopt;

extern int isatty(int);
extern char* ttyname(int);

extern int acct(const char* filepath);

static __inline__ int getpagesize(void) {
  extern unsigned int __page_size;
  return __page_size;
}
static __inline__ int __getpageshift(void) {
  extern unsigned int __page_shift;
  return __page_shift;
}

extern int sysconf(int name);

extern int daemon(int, int);


extern int cacheflush(long start, long end, long flags);

extern pid_t tcgetpgrp(int fd);
extern int tcsetpgrp(int fd, pid_t _pid);
# 206 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/unistd.h"
}
# 35 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/fcntl.h" 2

extern "C" {
# 46 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/fcntl.h"
extern int open(const char* path, int mode, ...);
extern int openat(int fd, const char* path, int mode, ...);
extern int unlinkat(int dirfd, const char *pathname, int flags);
extern int fcntl(int fd, int command, ...);
extern int creat(const char* path, mode_t mode);

}
# 26 "webkey-2.09/service/webkey.cpp" 2


# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/time.h" 1
# 38 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/time.h"
extern "C" {

extern time_t time(time_t *);
extern int nanosleep(const struct timespec *, struct timespec *);

extern char *strtotimeval(const char *str, struct timeval *tv);

struct tm {
   int tm_sec;
   int tm_min;
   int tm_hour;
   int tm_mday;
   int tm_mon;
   int tm_year;
   int tm_wday;
   int tm_yday;
   int tm_isdst;

   long int tm_gmtoff;
   const char *tm_zone;

};






extern char* asctime(const struct tm* a);
extern char* asctime_r(const struct tm* a, char* buf);


extern double difftime (time_t __time1, time_t __time0);
extern time_t mktime (struct tm *a);

extern struct tm* localtime(const time_t *t);
extern struct tm* localtime_r(const time_t *timep, struct tm *result);

extern struct tm* gmtime(const time_t *timep);
extern struct tm* gmtime_r(const time_t *timep, struct tm *result);

extern char* strptime(const char *buf, const char *fmt, struct tm *tm);
extern size_t strftime(char *s, size_t max, const char *format, const struct tm *tm);

extern char *ctime(const time_t *timep);
extern char *ctime_r(const time_t *timep, char *buf);

extern void tzset(void);


extern char* tzname[];







extern clock_t clock(void);


extern int clock_getres(clockid_t, struct timespec *);
extern int clock_gettime(clockid_t, struct timespec *);
extern int clock_settime(clockid_t, const struct timespec *);
extern int clock_nanosleep(clockid_t, int, const struct timespec *, struct timespec *);
# 111 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/time.h"
extern int timer_create(int, struct sigevent*, timer_t*);
extern int timer_delete(timer_t);
extern int timer_settime(timer_t timerid, int flags, const struct itimerspec *value, struct itimerspec *ovalue);
extern int timer_gettime(timer_t timerid, struct itimerspec *value);
extern int timer_getoverrun(timer_t timerid);

}
# 29 "webkey-2.09/service/webkey.cpp" 2
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/stdlib.h" 1
# 37 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/stdlib.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stddef.h" 1
# 18 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stddef.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_cprolog.h" 1
# 19 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stddef.h" 2
# 34 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stddef.h"
# 1 "/home/petya/download/android-ndk-r8b/toolchains/arm-linux-androideabi-4.4.3/prebuilt/linux-x86/bin/../lib/gcc/arm-linux-androideabi/4.4.3/include/../include/stddef.h" 1 3 4
# 35 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stddef.h" 2




# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_epilog.h" 1
# 19 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_epilog.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_config_compat_post.h" 1
# 20 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_epilog.h" 2
# 40 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stddef.h" 2
# 38 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/stdlib.h" 2

# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stddef.h" 1
# 18 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stddef.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_cprolog.h" 1
# 19 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stddef.h" 2
# 34 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stddef.h"
# 1 "/home/petya/download/android-ndk-r8b/toolchains/arm-linux-androideabi-4.4.3/prebuilt/linux-x86/bin/../lib/gcc/arm-linux-androideabi/4.4.3/include/../include/stddef.h" 1 3 4
# 35 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stddef.h" 2




# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_epilog.h" 1
# 19 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_epilog.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_config_compat_post.h" 1
# 20 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_epilog.h" 2
# 40 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stddef.h" 2
# 40 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/stdlib.h" 2

# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/alloca.h" 1
# 42 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/stdlib.h" 2
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/strings.h" 1
# 45 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/strings.h"
extern "C" {
void bcopy(const void *, void *, size_t);
void bzero(void *, size_t);
int ffs(int);
char *index(const char *, int);
int strcasecmp(const char *, const char *);
int strncasecmp(const char *, const char *, size_t);




}
# 43 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/stdlib.h" 2
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/memory.h" 1
# 44 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/stdlib.h" 2

extern "C" {




extern __attribute__((__noreturn__)) void exit(int);
extern __attribute__((__noreturn__)) void abort(void);
extern int atexit(void (*)(void));

extern char *getenv(const char *);
extern int putenv(const char *);
extern int setenv(const char *, const char *, int);
extern int unsetenv(const char *);

extern char *mktemp (char *);
extern int mkstemp (char *);

extern long strtol(const char *, char **, int);
extern long long strtoll(const char *, char **, int);
extern unsigned long strtoul(const char *, char **, int);
extern unsigned long long strtoull(const char *, char **, int);
extern double strtod(const char *nptr, char **endptr);

static __inline__ float strtof(const char *nptr, char **endptr)
{
    return (float)strtod(nptr, endptr);
}

extern int atoi(const char *);
extern long atol(const char *);
extern long long atoll(const char *);

static __inline__ double atof(const char *nptr)
{
    return (strtod(nptr, __null));
}

static __inline__ int abs(int __n) {
    return (__n < 0) ? -__n : __n;
}

static __inline__ long labs(long __n) {
    return (__n < 0L) ? -__n : __n;
}

static __inline__ long long llabs(long long __n) {
    return (__n < 0LL) ? -__n : __n;
}

extern char * realpath(const char *path, char *resolved);
extern int system(const char * string);

extern void * bsearch(const void *key, const void *base0,
 size_t nmemb, size_t size,
 int (*compar)(const void *, const void *));

extern void qsort(void *, size_t, size_t, int (*)(const void *, const void *));

extern long jrand48(unsigned short *);
extern long mrand48(void);
extern long nrand48(unsigned short *);
extern long lrand48(void);
extern unsigned short *seed48(unsigned short*);
extern double erand48(unsigned short xsubi[3]);
extern double drand48(void);
extern void srand48(long);
extern unsigned int arc4random(void);
extern void arc4random_stir(void);
extern void arc4random_addrandom(unsigned char *, int);


static __inline__ int rand(void) {
    return (int)lrand48();
}
static __inline__ void srand(unsigned int __s) {
    srand48(__s);
}
static __inline__ long random(void)
{
    return lrand48();
}
static __inline__ void srandom(unsigned int __s)
{
    srand48(__s);
}



extern int unlockpt(int);
extern char* ptsname(int);
extern char* ptsname_r(int, char*, size_t);
extern int getpt(void);

static __inline__ int grantpt(int __fd)
{
  (void)__fd;
  return 0;
}

typedef struct {
    int quot;
    int rem;
} div_t;

extern div_t div(int, int);

typedef struct {
    long int quot;
    long int rem;
} ldiv_t;

extern ldiv_t ldiv(long, long);

typedef struct {
    long long int quot;
    long long int rem;
} lldiv_t;

extern lldiv_t lldiv(long long, long long);



extern int mblen(const char *, size_t);
extern size_t mbstowcs(wchar_t *, const char *, size_t);
extern int mbtowc(wchar_t *, const char *, size_t);


extern int wctomb(char *, wchar_t);
extern size_t wcstombs(char *, const wchar_t *, size_t);
# 183 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/stdlib.h"
}
# 30 "webkey-2.09/service/webkey.cpp" 2
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stdarg.h" 1
# 24 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stdarg.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_cprolog.h" 1
# 25 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stdarg.h" 2
# 36 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stdarg.h"
# 1 "/home/petya/download/android-ndk-r8b/toolchains/arm-linux-androideabi-4.4.3/prebuilt/linux-x86/bin/../lib/gcc/arm-linux-androideabi/4.4.3/include/../include/stdarg.h" 1 3 4
# 40 "/home/petya/download/android-ndk-r8b/toolchains/arm-linux-androideabi-4.4.3/prebuilt/linux-x86/bin/../lib/gcc/arm-linux-androideabi/4.4.3/include/../include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 102 "/home/petya/download/android-ndk-r8b/toolchains/arm-linux-androideabi-4.4.3/prebuilt/linux-x86/bin/../lib/gcc/arm-linux-androideabi/4.4.3/include/../include/stdarg.h" 3 4
typedef __gnuc_va_list va_list;
# 37 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stdarg.h" 2




# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_epilog.h" 1
# 19 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_epilog.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_config_compat_post.h" 1
# 20 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_epilog.h" 2
# 42 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stdarg.h" 2
# 31 "webkey-2.09/service/webkey.cpp" 2
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/assert.h" 1
# 62 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/assert.h"
extern "C" {
 void __assert(const char *, int, const char *);
 void __assert2(const char *, int, const char *, const char *);
}
# 32 "webkey-2.09/service/webkey.cpp" 2

# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/ctype.h" 1
# 54 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/ctype.h"
extern "C" {

extern const char *_ctype_;
extern const short *_tolower_tab_;
extern const short *_toupper_tab_;
# 72 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/ctype.h"
int isalnum(int);
int isalpha(int);
int iscntrl(int);
int isdigit(int);
int isgraph(int);
int islower(int);
int isprint(int);
int ispunct(int);
int isspace(int);
int isupper(int);
int isxdigit(int);
int tolower(int);
int toupper(int);



int isblank(int);



int isascii(int);
int toascii(int);
int _tolower(int);
int _toupper(int);
# 203 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/ctype.h"
}
# 34 "webkey-2.09/service/webkey.cpp" 2

# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stddef.h" 1
# 18 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stddef.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_cprolog.h" 1
# 19 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stddef.h" 2
# 34 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stddef.h"
# 1 "/home/petya/download/android-ndk-r8b/toolchains/arm-linux-androideabi-4.4.3/prebuilt/linux-x86/bin/../lib/gcc/arm-linux-androideabi/4.4.3/include/../include/stddef.h" 1 3 4
# 35 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stddef.h" 2




# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_epilog.h" 1
# 19 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_epilog.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_config_compat_post.h" 1
# 20 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_epilog.h" 2
# 40 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stddef.h" 2
# 36 "webkey-2.09/service/webkey.cpp" 2
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/stdio.h" 1
# 46 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/stdio.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stdarg.h" 1
# 24 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stdarg.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_cprolog.h" 1
# 25 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stdarg.h" 2
# 41 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stdarg.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_epilog.h" 1
# 19 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_epilog.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_config_compat_post.h" 1
# 20 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_epilog.h" 2
# 42 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stdarg.h" 2
# 47 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/stdio.h" 2



# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stddef.h" 1
# 18 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stddef.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_cprolog.h" 1
# 19 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stddef.h" 2
# 34 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stddef.h"
# 1 "/home/petya/download/android-ndk-r8b/toolchains/arm-linux-androideabi-4.4.3/prebuilt/linux-x86/bin/../lib/gcc/arm-linux-androideabi/4.4.3/include/../include/stddef.h" 1 3 4
# 35 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stddef.h" 2




# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_epilog.h" 1
# 19 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_epilog.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_config_compat_post.h" 1
# 20 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_epilog.h" 2
# 40 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stddef.h" 2
# 51 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/stdio.h" 2

# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stddef.h" 1
# 18 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stddef.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_cprolog.h" 1
# 19 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stddef.h" 2
# 34 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stddef.h"
# 1 "/home/petya/download/android-ndk-r8b/toolchains/arm-linux-androideabi-4.4.3/prebuilt/linux-x86/bin/../lib/gcc/arm-linux-androideabi/4.4.3/include/../include/stddef.h" 1 3 4
# 35 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stddef.h" 2




# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_epilog.h" 1
# 19 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_epilog.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_config_compat_post.h" 1
# 20 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_epilog.h" 2
# 40 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stddef.h" 2
# 53 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/stdio.h" 2
# 78 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/stdio.h"
typedef off_t fpos_t;
# 87 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/stdio.h"
struct __sbuf {
 unsigned char *_base;
 int _size;
};
# 119 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/stdio.h"
typedef struct __sFILE {
 unsigned char *_p;
 int _r;
 int _w;
 short _flags;
 short _file;
 struct __sbuf _bf;
 int _lbfsize;


 void *_cookie;
 int (*_close)(void *);
 int (*_read)(void *, char *, int);
 fpos_t (*_seek)(void *, fpos_t, int);
 int (*_write)(void *, const char *, int);


 struct __sbuf _ext;

 unsigned char *_up;
 int _ur;


 unsigned char _ubuf[3];
 unsigned char _nbuf[1];


 struct __sbuf _lb;


 int _blksize;
 fpos_t _offset;
} FILE;

extern "C" {
extern FILE __sF[];
}
# 223 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/stdio.h"
extern "C" {
void clearerr(FILE *);
int fclose(FILE *);
int feof(FILE *);
int ferror(FILE *);
int fflush(FILE *);
int fgetc(FILE *);
int fgetpos(FILE *, fpos_t *);
char *fgets(char *, int, FILE *);
FILE *fopen(const char *, const char *);
int fprintf(FILE *, const char *, ...);
int fputc(int, FILE *);
int fputs(const char *, FILE *);
size_t fread(void *, size_t, size_t, FILE *);
FILE *freopen(const char *, const char *, FILE *);
int fscanf(FILE *, const char *, ...);
int fseek(FILE *, long, int);
int fseeko(FILE *, off_t, int);
int fsetpos(FILE *, const fpos_t *);
long ftell(FILE *);
off_t ftello(FILE *);
size_t fwrite(const void *, size_t, size_t, FILE *);
int getc(FILE *);
int getchar(void);
char *gets(char *);



extern int sys_nerr;
extern char *sys_errlist[];

void perror(const char *);
int printf(const char *, ...);
int putc(int, FILE *);
int putchar(int);
int puts(const char *);
int remove(const char *);
int rename(const char *, const char *);
void rewind(FILE *);
int scanf(const char *, ...);
void setbuf(FILE *, char *);
int setvbuf(FILE *, char *, int, size_t);
int sprintf(char *, const char *, ...);
int sscanf(const char *, const char *, ...);
FILE *tmpfile(void);
char *tmpnam(char *);
int ungetc(int, FILE *);
int vfprintf(FILE *, const char *, __va_list);
int vprintf(const char *, __va_list);
int vsprintf(char *, const char *, __va_list);


int snprintf(char *, size_t, const char *, ...)
  __attribute__((__format__ (printf, 3, 4)))
  __attribute__((__nonnull__ (3)));
int vfscanf(FILE *, const char *, __va_list)
  __attribute__((__format__ (scanf, 2, 0)))
  __attribute__((__nonnull__ (2)));
int vscanf(const char *, __va_list)
  __attribute__((__format__ (scanf, 1, 0)))
  __attribute__((__nonnull__ (1)));
int vsnprintf(char *, size_t, const char *, __va_list)
  __attribute__((__format__ (printf, 3, 0)))
  __attribute__((__nonnull__ (3)));
int vsscanf(const char *, const char *, __va_list)
  __attribute__((__format__ (scanf, 2, 0)))
  __attribute__((__nonnull__ (2)));


}
# 302 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/stdio.h"
extern "C" {




FILE *fdopen(int, const char *);
int fileno(FILE *);


int pclose(FILE *);
FILE *popen(const char *, const char *);



void flockfile(FILE *);
int ftrylockfile(FILE *);
void funlockfile(FILE *);





int getc_unlocked(FILE *);
int getchar_unlocked(void);
int putc_unlocked(int, FILE *);
int putchar_unlocked(int);



char *tempnam(const char *, const char *);

}







extern "C" {
int asprintf(char **, const char *, ...)
  __attribute__((__format__ (printf, 2, 3)))
  __attribute__((__nonnull__ (2)));
char *fgetln(FILE *, size_t *);
int fpurge(FILE *);
int getw(FILE *);
int putw(int, FILE *);
void setbuffer(FILE *, char *, int);
int setlinebuf(FILE *);
int vasprintf(char **, const char *, __va_list)
  __attribute__((__format__ (printf, 2, 0)))
  __attribute__((__nonnull__ (2)));
}




extern "C" {
FILE *funopen(const void *,
  int (*)(void *, char *, int),
  int (*)(void *, const char *, int),
  fpos_t (*)(void *, fpos_t, int),
  int (*)(void *));
}







extern "C" {
int __srget(FILE *);
int __swbuf(int, FILE *);
}







static inline int __sputc(int _c, FILE *_p) {
 if (--_p->_w >= 0 || (_p->_w >= _p->_lbfsize && (char)_c != '\n'))
  return (*_p->_p++ = _c);
 else
  return (__swbuf(_c, _p));
}
# 37 "webkey-2.09/service/webkey.cpp" 2

# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/vector" 1
# 27 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/vector"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_prolog.h" 1






# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_cprolog.h" 1
# 8 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_prolog.h" 2
# 17 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_prolog.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/debug/_debug.h" 1
# 18 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_prolog.h" 2
# 28 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/vector" 2





# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_algobase.h" 1
# 34 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_algobase.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_cstddef.h" 1
# 34 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_cstddef.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stddef.h" 1
# 34 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stddef.h"
# 1 "/home/petya/download/android-ndk-r8b/toolchains/arm-linux-androideabi-4.4.3/prebuilt/linux-x86/bin/../lib/gcc/arm-linux-androideabi/4.4.3/include/../include/stddef.h" 1 3 4
# 35 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stddef.h" 2
# 35 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_cstddef.h" 2



namespace std {
using ::ptrdiff_t;
using ::size_t;
}
# 35 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_algobase.h" 2



# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_cstring.h" 1
# 30 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_cstring.h"
namespace std {
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/using/cstring" 1
using ::size_t;
# 12 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/using/cstring"
using ::memmove;
using ::memcpy;




using ::strcoll;
using ::strerror;
using ::strxfrm;





using ::memchr;
using ::strchr;
using ::strpbrk;
using ::strrchr;
using ::strstr;




using ::memcmp;
using ::memset;

using ::strcat;


using ::strcmp;





using ::strcpy;



using ::strcspn;
using ::strlen;
using ::strncat;
using ::strncmp;

using ::strncpy;
using ::strspn;

using ::strtok;
# 32 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_cstring.h" 2
}
# 39 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_algobase.h" 2



# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/climits" 1
# 43 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_algobase.h" 2



# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_cstdlib.h" 1
# 55 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_cstdlib.h"
namespace std {
using ::div_t;
using ::ldiv_t;
using ::size_t;




using ::abort;
using ::getenv;
using ::mblen;
using ::mbtowc;
using ::system;
using ::bsearch;

using ::atexit;
using ::exit;
using ::calloc;
using ::free;
using ::malloc;
using ::realloc;
using ::atof;
using ::atoi;
using ::atol;
using ::mbstowcs;
using ::strtod;
using ::strtol;
using ::strtoul;


using ::wcstombs;

using ::wctomb;


using ::qsort;
using ::labs;
using ::ldiv;


using ::llabs;
using ::lldiv_t;
using ::lldiv;






using ::rand;
using ::srand;

}
# 131 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_cstdlib.h"
inline long abs(long __x) { return ::labs(__x); }





inline ::ldiv_t div(long __x, long __y) { return ::ldiv(__x, __y); }
# 151 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_cstdlib.h"
inline long long abs(long long __x) { return ::llabs(__x); }
inline lldiv_t div(long long __x, long long __y) { return ::lldiv(__x, __y); }
# 169 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_cstdlib.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_cmath.h" 1
# 44 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_cmath.h"
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/math.h" 1
# 29 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/math.h"
extern const union __infinity_un {
 unsigned char __uc[8];
 double __ud;
} __infinity;

extern const union __nan_un {
 unsigned char __uc[sizeof(float)];
 float __uf;
} __nan;
# 165 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/math.h"
extern int signgam;
# 182 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/math.h"
extern "C" {



int __fpclassifyd(double) ;
int __fpclassifyf(float) ;
int __fpclassifyl(long double) ;
int __isfinitef(float) ;
int __isfinite(double) ;
int __isfinitel(long double) ;
int __isinff(float) ;
int __isinf(double) ;
int __isinfl(long double) ;
int __isnanl(long double) ;
int __isnormalf(float) ;
int __isnormal(double) ;
int __isnormall(long double) ;
int __signbit(double) ;
int __signbitf(float) ;
int __signbitl(long double) ;

double acos(double);
double asin(double);
double atan(double);
double atan2(double, double);
double cos(double);
double sin(double);
double tan(double);

double cosh(double);
double sinh(double);
double tanh(double);

double exp(double);
double frexp(double, int *);
double ldexp(double, int);
double log(double);
double log10(double);
double modf(double, double *);

double pow(double, double);
double sqrt(double);

double ceil(double);
double fabs(double) ;
double floor(double);
double fmod(double, double);





double acosh(double);
double asinh(double);
double atanh(double);
double cbrt(double);
double erf(double);
double erfc(double);
double exp2(double);
double expm1(double);
double fma(double, double, double);
double hypot(double, double);
int ilogb(double) ;

int (isnan)(double) ;
double lgamma(double);
long long llrint(double);
long long llround(double);
double log1p(double);
double logb(double);
long lrint(double);
long lround(double);
double nextafter(double, double);
double remainder(double, double);
double remquo(double, double, int *);
double rint(double);



double j0(double);
double j1(double);
double jn(int, double);
double scalb(double, double);
double y0(double);
double y1(double);
double yn(int, double);


double gamma(double);




double copysign(double, double) ;
double fdim(double, double);
double fmax(double, double) ;
double fmin(double, double) ;
double nearbyint(double);
double round(double);
double scalbln(double, long);
double scalbn(double, int);
double tgamma(double);
double trunc(double);






double drem(double, double);
int finite(double) ;
int isnanf(float) ;





double gamma_r(double, int *);
double lgamma_r(double, int *);




double significand(double);




float acosf(float);
float asinf(float);
float atanf(float);
float atan2f(float, float);
float cosf(float);
float sinf(float);
float tanf(float);

float coshf(float);
float sinhf(float);
float tanhf(float);

float exp2f(float);
float expf(float);
float expm1f(float);
float frexpf(float, int *);
int ilogbf(float) ;
float ldexpf(float, int);
float log10f(float);
float log1pf(float);
float logf(float);
float modff(float, float *);

float powf(float, float);
float sqrtf(float);

float ceilf(float);
float fabsf(float) ;
float floorf(float);
float fmodf(float, float);
float roundf(float);

float erff(float);
float erfcf(float);
float hypotf(float, float);
float lgammaf(float);

float acoshf(float);
float asinhf(float);
float atanhf(float);
float cbrtf(float);
float logbf(float);
float copysignf(float, float) ;
long long llrintf(float);
long long llroundf(float);
long lrintf(float);
long lroundf(float);
float nearbyintf(float);
float nextafterf(float, float);
float remainderf(float, float);
float remquof(float, float, int *);
float rintf(float);
float scalblnf(float, long);
float scalbnf(float, int);
float truncf(float);

float fdimf(float, float);
float fmaf(float, float, float);
float fmaxf(float, float) ;
float fminf(float, float) ;






float dremf(float, float);
int finitef(float) ;
float gammaf(float);
float j0f(float);
float j1f(float);
float jnf(int, float);
float scalbf(float, float);
float y0f(float);
float y1f(float);
float ynf(int, float);






float gammaf_r(float, int *);
float lgammaf_r(float, int *);




float significandf(float);
# 415 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/math.h"
long double ceill(long double);
long double copysignl(long double, long double) ;
# 426 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/math.h"
long double fabsl(long double) ;
long double fdiml(long double, long double);
long double floorl(long double);
long double fmal(long double, long double, long double);
long double fmaxl(long double, long double) ;
long double fminl(long double, long double) ;



long double frexpl(long double value, int *);



int ilogbl(long double) ;
long double ldexpl(long double, int);




long long llroundl(long double);
# 454 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/math.h"
long lroundl(long double);





long double nextafterl(long double, long double);
double nexttoward(double, long double);
float nexttowardf(float, long double);
long double nexttowardl(long double, long double);






long double roundl(long double);
long double scalblnl(long double, long);
long double scalbnl(long double, int);
# 481 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/math.h"
long double truncl(long double);


}
# 45 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_cmath.h" 2
# 424 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_cmath.h"
inline double abs(double __x)
{ return ::fabs(__x); }

inline float abs (float x) { return ::fabsf(x); } inline long double abs (long double x) { return static_cast<long double>(::fabs((double)x)); }




inline float acos (float x) { return ::acosf(x); } inline long double acos (long double x) { return static_cast<long double>(::acos((double)x)); }
inline float asin (float x) { return ::asinf(x); } inline long double asin (long double x) { return static_cast<long double>(::asin((double)x)); }
inline float atan (float x) { return ::atanf(x); } inline long double atan (long double x) { return static_cast<long double>(::atan((double)x)); }
inline float atan2 (float x, float y) { return ::atan2f(x, y); } inline long double atan2 (long double x, long double y) { return static_cast<long double>(::atan2((double)x, (double)y)); }
inline float ceil (float x) { return ::ceilf(x); } inline long double ceil (long double x) { return static_cast<long double>(::ceil((double)x)); }
inline float cos (float x) { return ::cosf(x); } inline long double cos (long double x) { return static_cast<long double>(::cos((double)x)); }
inline float cosh (float x) { return ::coshf(x); } inline long double cosh (long double x) { return static_cast<long double>(::cosh((double)x)); }
inline float exp (float x) { return ::expf(x); } inline long double exp (long double x) { return static_cast<long double>(::exp((double)x)); }
inline float fabs (float x) { return ::fabsf(x); } inline long double fabs (long double x) { return static_cast<long double>(::fabs((double)x)); }
inline float floor (float x) { return ::floorf(x); } inline long double floor (long double x) { return static_cast<long double>(::floor((double)x)); }
inline float fmod (float x, float y) { return ::fmodf(x, y); } inline long double fmod (long double x, long double y) { return static_cast<long double>(::fmod((double)x, (double)y)); }
inline float frexp (float x, int * y) { return ::frexpf(x, y); } inline long double frexp (long double x, int * y) { return static_cast<long double>(::frexp((double)x, y)); }
inline float ldexp (float x, int y) { return ::ldexpf(x, y); } inline long double ldexp (long double x, int y) { return static_cast<long double>(::ldexp((double)x, y)); }
inline float log (float x) { return ::logf(x); } inline long double log (long double x) { return static_cast<long double>(::log((double)x)); }
inline float log10 (float x) { return ::log10f(x); } inline long double log10 (long double x) { return static_cast<long double>(::log10((double)x)); }
inline float modf (float x, float * y) { return ::modff(x, y); } inline long double modf (long double x, long double *y) { double tmp1, tmp2; tmp1 = ::modf(static_cast<double>(x), &tmp2); *y = static_cast<long double>(tmp2); return static_cast<long double>(tmp1); }
inline float sin (float x) { return ::sinf(x); } inline long double sin (long double x) { return static_cast<long double>(::sin((double)x)); }
inline float sinh (float x) { return ::sinhf(x); } inline long double sinh (long double x) { return static_cast<long double>(::sinh((double)x)); }
inline float sqrt (float x) { return ::sqrtf(x); } inline long double sqrt (long double x) { return static_cast<long double>(::sqrt((double)x)); }
inline float tan (float x) { return ::tanf(x); } inline long double tan (long double x) { return static_cast<long double>(::tan((double)x)); }
inline float tanh (float x) { return ::tanhf(x); } inline long double tanh (long double x) { return static_cast<long double>(::tanh((double)x)); }
inline float pow (float x, float y) { return ::powf(x, y); } inline long double pow (long double x, long double y) { return static_cast<long double>(::pow((double)x, (double)y)); }




inline float pow(float __x, int __y) { return ::powf(__x, static_cast<float>(__y)); }






inline double pow(double __x, int __y) { return ::pow(__x, static_cast<double>(__y)); }
# 478 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_cmath.h"
inline long double pow(long double __x, int __y) { return static_cast<long double>(::pow(__x, static_cast<long double>(__y))); }
# 535 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_cmath.h"
namespace __captured {
template<typename _Tp> inline int __capture_isfinite(_Tp __f) { return ((sizeof (__f) == sizeof (float)) ? __isfinitef(__f) : (sizeof (__f) == sizeof (double)) ? __isfinite(__f) : __isfinitel(__f)); }
template<typename _Tp> inline int __capture_isinf(_Tp __f) { return ((sizeof (__f) == sizeof (float)) ? __isinff(__f) : (sizeof (__f) == sizeof (double)) ? __isinf(__f) : __isinfl(__f)); }
template<typename _Tp> inline int __capture_isnan(_Tp __f) { return ((sizeof (__f) == sizeof (float)) ? isnanf(__f) : (sizeof (__f) == sizeof (double)) ? isnan(__f) : __isnanl(__f)); }
template<typename _Tp> inline int __capture_signbit(_Tp __f) { return ((sizeof (__f) == sizeof (float)) ? __signbitf(__f) : (sizeof (__f) == sizeof (double)) ? __signbit(__f) : __signbitl(__f)); }
}




namespace __captured {
template<typename _Tp> inline int isfinite(_Tp __f) { return __capture_isfinite(__f); }
template<typename _Tp> inline int isinf(_Tp __f) { return __capture_isinf(__f); }
template<typename _Tp> inline int isnan(_Tp __f) { return __capture_isnan(__f); }
template<typename _Tp> inline int signbit(_Tp __f) { return __capture_signbit(__f); }
}

namespace std {
using ::abs;
using ::acos;
using ::asin;
using ::atan;
using ::atan2;
using ::ceil;
using ::cos;
using ::cosh;
using ::exp;
using ::fabs;
using ::floor;
using ::fmod;
using ::frexp;
# 574 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_cmath.h"
using ::hypot;


using __captured::isfinite;
using __captured::isinf;
using __captured::isnan;

using ::ldexp;
using ::log;
using ::log10;
using ::modf;
using ::pow;

using __captured::signbit;

using ::sin;
using ::sinh;
using ::sqrt;
using ::tan;
using ::tanh;
}
# 170 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_cstdlib.h" 2




namespace std {
using ::abs;
using ::div;
}
# 47 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_algobase.h" 2



# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_pair.h" 1
# 36 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_pair.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/type_traits.h" 1
# 63 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/type_traits.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/type_manips.h" 1
# 21 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/type_manips.h"
namespace std {

struct __true_type {};
struct __false_type {};


namespace priv {
using ::std::__true_type;
using ::std::__false_type;
}



template <int _Is>
struct __bool2type
{ typedef __true_type _Ret; };

template<>
struct __bool2type<1> { typedef __true_type _Ret; };

template<>
struct __bool2type<0> { typedef __false_type _Ret; };


template <class __bool_type>
struct __type2bool { enum {_Ret = 1}; };

template<>
struct __type2bool<__true_type> { enum {_Ret = 1}; };

template<>
struct __type2bool<__false_type> { enum {_Ret = 0}; };


template <class _BoolType>
struct _Not { typedef __false_type _Ret; };

template<>
struct _Not<__false_type> { typedef __true_type _Ret; };


template <class _P1, class _P2>
struct _Land2 { typedef __false_type _Ret; };

template<>
struct _Land2<__true_type, __true_type> { typedef __true_type _Ret; };


template <class _P1, class _P2, class _P3>
struct _Land3 { typedef __false_type _Ret; };

template<>
struct _Land3<__true_type, __true_type, __true_type> { typedef __true_type _Ret; };


template <class _P1, class _P2>
struct _Lor2 { typedef __true_type _Ret; };

template<>
struct _Lor2<__false_type, __false_type> { typedef __false_type _Ret; };


template <class _P1, class _P2, class _P3>
struct _Lor3 { typedef __true_type _Ret; };

template<>
struct _Lor3<__false_type, __false_type, __false_type> { typedef __false_type _Ret; };
# 112 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/type_manips.h"
template <bool _Cond, class _Tp1, class _Tp2>
struct __select { typedef _Tp1 _Ret; };

template <class _Tp1, class _Tp2>
struct __select<false, _Tp1, _Tp2> { typedef _Tp2 _Ret; };
# 164 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/type_manips.h"
struct _NoVolatilePointerShim { _NoVolatilePointerShim(const void*); };
template <class _Tp>
char _IsCopyableFun(bool, _NoVolatilePointerShim, _Tp const*, _Tp*);
char* _IsCopyableFun(bool, ...);

template <class _Src, class _Dst>
struct _Copyable {
  static _Src* __null_src();
  static _Dst* __null_dst();
  enum { _Ret = (sizeof(_IsCopyableFun(false, __null_src(), __null_src(), __null_dst())) == sizeof(char)) };
  typedef typename __bool2type<_Ret>::_Ret _RetT;
};
# 202 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/type_manips.h"
template <class _Src, class _Dst>
struct _AreCopyable {
  enum { _Same = _Copyable<_Src, _Dst>::_Ret };
  typedef typename _Copyable<_Src, _Dst>::_RetT _Ret;
};

template <class _Tp1, class _Tp2>
struct _AreSameTypes {
  enum { _Same = 0 };
  typedef __false_type _Ret;
};


template <class _Tp>
struct _AreSameTypes<_Tp, _Tp> {
  enum { _Same = 1 };
  typedef __true_type _Ret;
};



template <class _Src, class _Dst>
struct _ConversionHelper {
  static char _Test(bool, _Dst);
  static char* _Test(bool, ...);
  static _Src _MakeSource();
};

template <class _Src, class _Dst>
struct _IsConvertible {
  typedef _ConversionHelper<_Src*, const volatile _Dst*> _H;
  enum { value = (sizeof(char) == sizeof(_H::_Test(false, _H::_MakeSource()))) };
  typedef typename __bool2type<value>::_Ret _Ret;
};
# 292 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/type_manips.h"
template <class _Src, class _Dst>
struct _IsCVConvertible {

  typedef _ConversionHelper<_Src, _Dst> _H;
  enum { value = (sizeof(char) == sizeof(_H::_Test(false, _H::_MakeSource()))) };





  typedef typename __bool2type<value>::_Ret _Ret;
};
# 319 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/type_manips.h"
}
# 64 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/type_traits.h" 2
# 72 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/type_traits.h"
namespace std {






template <class _Tp> struct _IsIntegral
{ typedef __false_type _Ret; };


template<> struct _IsIntegral<bool>
{ typedef __true_type _Ret; };


template<> struct _IsIntegral<char>
{ typedef __true_type _Ret; };


template<> struct _IsIntegral<signed char>
{ typedef __true_type _Ret; };


template<> struct _IsIntegral<unsigned char>
{ typedef __true_type _Ret; };


template<> struct _IsIntegral<wchar_t>
{ typedef __true_type _Ret; };


template<> struct _IsIntegral<short>
{ typedef __true_type _Ret; };

template<> struct _IsIntegral<unsigned short>
{ typedef __true_type _Ret; };

template<> struct _IsIntegral<int>
{ typedef __true_type _Ret; };

template<> struct _IsIntegral<unsigned int>
{ typedef __true_type _Ret; };

template<> struct _IsIntegral<long>
{ typedef __true_type _Ret; };

template<> struct _IsIntegral<unsigned long>
{ typedef __true_type _Ret; };


template<> struct _IsIntegral<long long>
{ typedef __true_type _Ret; };

template<> struct _IsIntegral<unsigned long long>
{ typedef __true_type _Ret; };


template <class _Tp> struct _IsRational
{ typedef __false_type _Ret; };

template<> struct _IsRational<float>
{ typedef __true_type _Ret; };

template<> struct _IsRational<double>
{ typedef __true_type _Ret; };


template<> struct _IsRational<long double>
{ typedef __true_type _Ret; };



template <class _Tp> struct __type_traits;
template <class _IsPOD> struct __type_traits_aux {
   typedef __false_type has_trivial_default_constructor;
   typedef __false_type has_trivial_copy_constructor;
   typedef __false_type has_trivial_assignment_operator;
   typedef __false_type has_trivial_destructor;
   typedef __false_type is_POD_type;
};

template<>
struct __type_traits_aux<__false_type> {
   typedef __false_type has_trivial_default_constructor;
   typedef __false_type has_trivial_copy_constructor;
   typedef __false_type has_trivial_assignment_operator;
   typedef __false_type has_trivial_destructor;
   typedef __false_type is_POD_type;
};

template<>
struct __type_traits_aux<__true_type> {
  typedef __true_type has_trivial_default_constructor;
  typedef __true_type has_trivial_copy_constructor;
  typedef __true_type has_trivial_assignment_operator;
  typedef __true_type has_trivial_destructor;
  typedef __true_type is_POD_type;
};

template <class _Tp>
struct _IsRef {
  typedef __false_type _Ret;
};
# 219 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/type_traits.h"
template <class _Tp> struct _IsPtr {
  typedef __false_type _Ret;
};

template <class _Tp>
struct __type_traits {
   typedef __true_type this_dummy_member_must_be_first;
# 243 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/type_traits.h"
   typedef __false_type has_trivial_default_constructor;
   typedef __false_type has_trivial_copy_constructor;
   typedef __false_type has_trivial_assignment_operator;
   typedef __false_type has_trivial_destructor;
   typedef __false_type is_POD_type;







};


template <class _Tp> struct _IsPtr<_Tp*>
{ typedef __true_type _Ret; };
template <class _Tp> struct _IsRef<_Tp&>
{ typedef __true_type _Ret; };

template <class _Tp> struct __type_traits<_Tp*> : __type_traits_aux<__true_type>
{};
# 284 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/type_traits.h"
template<> struct __type_traits< bool > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< const bool > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< volatile bool > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< const volatile bool > : __type_traits_aux<__true_type> {};

template<> struct __type_traits< char > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< const char > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< volatile char > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< const volatile char > : __type_traits_aux<__true_type> {};

template<> struct __type_traits< signed char > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< const signed char > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< volatile signed char > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< const volatile signed char > : __type_traits_aux<__true_type> {};

template<> struct __type_traits< unsigned char > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< const unsigned char > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< volatile unsigned char > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< const volatile unsigned char > : __type_traits_aux<__true_type> {};

template<> struct __type_traits< wchar_t > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< const wchar_t > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< volatile wchar_t > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< const volatile wchar_t > : __type_traits_aux<__true_type> {};


template<> struct __type_traits< short > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< const short > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< volatile short > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< const volatile short > : __type_traits_aux<__true_type> {};
template<> struct __type_traits< unsigned short > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< const unsigned short > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< volatile unsigned short > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< const volatile unsigned short > : __type_traits_aux<__true_type> {};
template<> struct __type_traits< int > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< const int > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< volatile int > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< const volatile int > : __type_traits_aux<__true_type> {};
template<> struct __type_traits< unsigned int > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< const unsigned int > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< volatile unsigned int > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< const volatile unsigned int > : __type_traits_aux<__true_type> {};
template<> struct __type_traits< long > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< const long > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< volatile long > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< const volatile long > : __type_traits_aux<__true_type> {};
template<> struct __type_traits< unsigned long > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< const unsigned long > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< volatile unsigned long > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< const volatile unsigned long > : __type_traits_aux<__true_type> {};


template<> struct __type_traits< long long > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< const long long > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< volatile long long > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< const volatile long long > : __type_traits_aux<__true_type> {};
template<> struct __type_traits< unsigned long long > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< const unsigned long long > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< volatile unsigned long long > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< const volatile unsigned long long > : __type_traits_aux<__true_type> {};


template<> struct __type_traits< float > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< const float > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< volatile float > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< const volatile float > : __type_traits_aux<__true_type> {};
template<> struct __type_traits< double > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< const double > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< volatile double > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< const volatile double > : __type_traits_aux<__true_type> {};


template<> struct __type_traits< long double > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< const long double > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< volatile long double > : __type_traits_aux<__true_type> {}; template<> struct __type_traits< const volatile long double > : __type_traits_aux<__true_type> {};



template <class _ArePtrs, class _Src, class _Dst>
struct _IsCVConvertibleIf
{ typedef typename _IsCVConvertible<_Src, _Dst>::_Ret _Ret; };

template <class _Src, class _Dst>
struct _IsCVConvertibleIf<__false_type, _Src, _Dst>
{ typedef __false_type _Ret; };
# 352 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/type_traits.h"
template <class _Src, class _Dst>
struct _TrivialNativeTypeCopy {
  typedef typename _IsPtr<_Src>::_Ret _Ptr1;
  typedef typename _IsPtr<_Dst>::_Ret _Ptr2;
  typedef typename _Land2<_Ptr1, _Ptr2>::_Ret _BothPtrs;
  typedef typename _IsCVConvertibleIf<_BothPtrs, _Src, _Dst>::_Ret _Convertible;
  typedef typename _Land2<_BothPtrs, _Convertible>::_Ret _Trivial1;

  typedef typename __bool2type<(sizeof(_Src) == sizeof(_Dst))>::_Ret _SameSize;


  typedef typename _IsIntegral<_Src>::_Ret _Int1;




  typedef typename _IsIntegral<_Dst>::_Ret _Int2;
  typedef typename _Land2<_Int1, _Int2>::_Ret _BothInts;

  typedef typename _IsRational<_Src>::_Ret _Rat1;
  typedef typename _IsRational<_Dst>::_Ret _Rat2;
  typedef typename _Land2<_Rat1, _Rat2>::_Ret _BothRats;

  typedef typename _Lor2<_BothInts, _BothRats>::_Ret _BothNatives;

  typedef typename _Land2<_BothNatives, _SameSize>::_Ret _Trivial2;




  typedef typename _Lor2<_Trivial1, _Trivial2>::_Ret _Ret;
};

template <class _Src, class _Dst>
struct _TrivialCopy {
  typedef typename _TrivialNativeTypeCopy<_Src, _Dst>::_Ret _NativeRet;

  typedef typename __type_traits<_Src>::has_trivial_assignment_operator _Tr1;




  typedef typename _AreCopyable<_Src, _Dst>::_Ret _Tr2;
  typedef typename _Land2<_Tr1, _Tr2>::_Ret _UserRet;
  typedef typename _Lor2<_NativeRet, _UserRet>::_Ret _Ret;
  static _Ret _Answer() { return _Ret(); }
};

template <class _Src, class _Dst>
struct _TrivialUCopy {
  typedef typename _TrivialNativeTypeCopy<_Src, _Dst>::_Ret _NativeRet;

  typedef typename __type_traits<_Src>::has_trivial_copy_constructor _Tr1;




  typedef typename _AreCopyable<_Src, _Dst>::_Ret _Tr2;
  typedef typename _Land2<_Tr1, _Tr2>::_Ret _UserRet;
  typedef typename _Lor2<_NativeRet, _UserRet>::_Ret _Ret;
  static _Ret _Answer() { return _Ret(); }
};

template <class _Tp>
struct _DefaultZeroValue {
  typedef typename _IsIntegral<_Tp>::_Ret _Tr1;
  typedef typename _IsRational<_Tp>::_Ret _Tr2;
  typedef typename _IsPtr<_Tp>::_Ret _Tr3;
  typedef typename _Lor3<_Tr1, _Tr2, _Tr3>::_Ret _Ret;
};

template <class _Tp>
struct _TrivialInit {

  typedef typename __type_traits<_Tp>::has_trivial_default_constructor _Tr1;




  typedef typename _DefaultZeroValue<_Tp>::_Ret _Tr2;
  typedef typename _Not<_Tr2>::_Ret _Tr3;
  typedef typename _Land2<_Tr1, _Tr3>::_Ret _Ret;
  static _Ret _Answer() { return _Ret(); }
};



template <class _Tp>
struct _IsPtrType {
  typedef typename _IsPtr<_Tp>::_Ret _Type;
  static _Type _Ret() { return _Type(); }
};

template <class _Tp>
struct _IsRefType {
  typedef typename _IsRef<_Tp>::_Ret _Type;
  static _Type _Ret() { return _Type();}
};

template <class _Tp>
struct __call_traits {
# 461 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/type_traits.h"
  typedef const _Tp& const_param_type;
  typedef _Tp& param_type;

};


template <class _Tp>
struct __call_traits<_Tp&> {
  typedef _Tp& param_type;
  typedef const _Tp& const_param_type;
};
template <class _Tp>
struct __call_traits<const _Tp&> {
  typedef _Tp& param_type;
  typedef const _Tp& const_param_type;
};


template <class _Tp1, class _Tp2>
struct _BothPtrType {
  typedef typename _IsPtr<_Tp1>::_Ret _IsPtr1;
  typedef typename _IsPtr<_Tp2>::_Ret _IsPtr2;

  typedef typename _Land2<_IsPtr1, _IsPtr2>::_Ret _Ret;
  static _Ret _Answer() { return _Ret(); }
};

template <class _Tp1, class _Tp2, class _IsRef1, class _IsRef2>
struct _OKToSwap {
  typedef typename _AreSameTypes<_Tp1, _Tp2>::_Ret _Same;
  typedef typename _Land3<_Same, _IsRef1, _IsRef2>::_Ret _Type;
  static _Type _Answer() { return _Type(); }
};

template <class _Tp1, class _Tp2, class _IsRef1, class _IsRef2>
inline _OKToSwap<_Tp1, _Tp2, _IsRef1, _IsRef2>
_IsOKToSwap(_Tp1*, _Tp2*, const _IsRef1&, const _IsRef2&)
{ return _OKToSwap<_Tp1, _Tp2, _IsRef1, _IsRef2>(); }

template <class _Src, class _Dst>
inline _TrivialCopy<_Src, _Dst> _UseTrivialCopy(_Src*, _Dst*)
{ return _TrivialCopy<_Src, _Dst>(); }

template <class _Src, class _Dst>
inline _TrivialUCopy<_Src, _Dst> _UseTrivialUCopy(_Src*, _Dst*)
{ return _TrivialUCopy<_Src, _Dst>(); }



struct _NegativeAnswer {
  typedef __false_type _Ret;
  static _Ret _Answer() { return _Ret(); }
};

template <class _Src, class _Dst>
inline _NegativeAnswer _UseTrivialCopy(_Src*, const _Dst*)
{ return _NegativeAnswer(); }

template <class _Src, class _Dst>
inline _NegativeAnswer _UseTrivialCopy(_Src*, volatile _Dst*)
{ return _NegativeAnswer(); }

template <class _Src, class _Dst>
inline _NegativeAnswer _UseTrivialCopy(_Src*, const volatile _Dst*)
{ return _NegativeAnswer(); }

template <class _Src, class _Dst>
inline _NegativeAnswer _UseTrivialUCopy(_Src*, const _Dst*)
{ return _NegativeAnswer(); }

template <class _Src, class _Dst>
inline _NegativeAnswer _UseTrivialUCopy(_Src*, volatile _Dst*)
{ return _NegativeAnswer(); }

template <class _Src, class _Dst>
inline _NegativeAnswer _UseTrivialUCopy(_Src*, const volatile _Dst*)
{ return _NegativeAnswer(); }


template <class _Tp>
inline _TrivialInit<_Tp> _UseTrivialInit(_Tp*)
{ return _TrivialInit<_Tp>(); }

template <class _Tp>
struct _IsPOD {
  typedef typename __type_traits<_Tp>::is_POD_type _Type;
  static _Type _Answer() { return _Type(); }
};

template <class _Tp>
inline _IsPOD<_Tp> _Is_POD(_Tp*)
{ return _IsPOD<_Tp>(); }

template <class _Tp>
struct _DefaultZeroValueQuestion {
  typedef typename _DefaultZeroValue<_Tp>::_Ret _Ret;
  static _Ret _Answer() { return _Ret(); }
};

template <class _Tp>
inline _DefaultZeroValueQuestion<_Tp> _HasDefaultZeroValue(_Tp*)
{ return _DefaultZeroValueQuestion<_Tp>(); }







template <class _Tp>
struct __stlport_class
{ typedef _Tp _Type; };

template <class _Tp>
struct _IsSTLportClass {
  typedef typename _IsConvertible<_Tp, __stlport_class<_Tp> >::_Ret _Ret;



};
# 592 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/type_traits.h"
template <class _Tp>
class _TpWithState : private _Tp {
  _TpWithState();
  int _state;
};



template <class _Tp>
struct _IsStateless {
  enum { _Is = sizeof(_TpWithState<_Tp>) == sizeof(int) };
  typedef typename __bool2type<_Is>::_Ret _Ret;
};

}
# 37 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_pair.h" 2



# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_move_construct_fwk.h" 1
# 24 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_move_construct_fwk.h"
namespace std {
# 34 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_move_construct_fwk.h"
template <class _Tp>
class __move_source {
public:
  explicit __move_source (_Tp &_src) : _M_data(_src)
  {}

  _Tp& get() const
  { return _M_data; }
private:
  _Tp &_M_data;


  typedef __move_source<_Tp> _Self;
  _Self& operator = (_Self const&);
};


template <class _Tp>
struct __move_traits {
# 63 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_move_construct_fwk.h"
  typedef __false_type implemented;
# 73 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_move_construct_fwk.h"
  typedef typename __type_traits<_Tp>::has_trivial_destructor complete;

};

namespace priv {







template <class _Tp>
struct _MoveSourceTraits {
  typedef typename __move_traits<_Tp>::implemented _MvImpRet;



  enum {_MvImp = __type2bool<_MvImpRet>::_Ret};
  typedef typename __select<_MvImp,

                            __move_source<_Tp>,
                            _Tp const&>::_Ret _Type;
};


template <class _Tp>
inline typename _MoveSourceTraits<_Tp>::_Type
_AsMoveSource (_Tp &src) {
  typedef typename _MoveSourceTraits<_Tp>::_Type _SrcType;
  return _SrcType(src);
}


template <class _Tp>
struct __move_traits_aux {
  typedef typename __move_traits<_Tp>::implemented implemented;
  typedef typename __move_traits<_Tp>::complete complete;
};

template <class _Tp1, class _Tp2>
struct __move_traits_aux2 {
  typedef __move_traits<_Tp1> _MoveTraits1;
  typedef __move_traits<_Tp2> _MoveTraits2;

  typedef typename _Lor2<typename _MoveTraits1::implemented,
                         typename _MoveTraits2::implemented>::_Ret implemented;
  typedef typename _Land2<typename _MoveTraits1::complete,
                          typename _MoveTraits2::complete>::_Ret complete;
};





template <class _Tp>
struct __move_traits_help {
  typedef __true_type implemented;
  typedef typename __move_traits<_Tp>::complete complete;
};

template <class _Tp1, class _Tp2>
struct __move_traits_help1 {
  typedef __move_traits<_Tp1> _MoveTraits1;
  typedef __move_traits<_Tp2> _MoveTraits2;

  typedef typename _Lor2<typename _MoveTraits1::implemented,
                         typename _MoveTraits2::implemented>::_Ret implemented;
  typedef typename _Land2<typename _MoveTraits1::complete,
                          typename _MoveTraits2::complete>::_Ret complete;
};

template <class _Tp1, class _Tp2>
struct __move_traits_help2 {
  typedef __move_traits<_Tp1> _MoveTraits1;
  typedef __move_traits<_Tp2> _MoveTraits2;

  typedef __true_type implemented;
  typedef typename _Land2<typename _MoveTraits1::complete,
                          typename _MoveTraits2::complete>::_Ret complete;
};

}

}
# 41 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_pair.h" 2



namespace std {





template <class _T1, class _T2>
struct pair {
  typedef _T1 first_type;
  typedef _T2 second_type;

  _T1 first;
  _T2 second;



  pair() : first(_T1()), second(_T2()) {}

  pair(const _T1& __a, const _T2& __b) : first(__a), second(__b) {}


  template <class _U1, class _U2>
  pair(const pair<_U1, _U2>& __p) : first(__p.first), second(__p.second) {}

  pair(const pair<_T1,_T2>& __o) : first(__o.first), second(__o.second) {}



  pair(__move_source<pair<_T1, _T2> > src) : first(::std::priv:: _AsMoveSource(src.get().first)),
                                             second(::std::priv:: _AsMoveSource(src.get().second))
  {}


 
};

template <class _T1, class _T2>
inline bool operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
{ return __x.first == __y.first && __x.second == __y.second; }

template <class _T1, class _T2>
inline bool operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y) {
  return __x.first < __y.first ||
         (!(__y.first < __x.first) && __x.second < __y.second);
}


template <class _T1, class _T2>
inline bool operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
{ return !(__x == __y); }

template <class _T1, class _T2>
inline bool operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
{ return __y < __x; }

template <class _T1, class _T2>
inline bool operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
{ return !(__y < __x); }

template <class _T1, class _T2>
inline bool operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
{ return !(__x < __y); }



template <class _T1, class _T2, int _Sz>
inline pair<_T1, _T2 const*> make_pair(_T1 const& __x,
                                       _T2 const (&__y)[_Sz])
{ return pair<_T1, _T2 const*>(__x, static_cast<_T2 const*>(__y)); }

template <class _T1, class _T2, int _Sz>
inline pair<_T1 const*, _T2> make_pair(_T1 const (&__x)[_Sz],
                                       _T2 const& __y)
{ return pair<_T1 const*, _T2>(static_cast<_T1 const*>(__x), __y); }

template <class _T1, class _T2, int _Sz1, int _Sz2>
inline pair<_T1 const*, _T2 const*> make_pair(_T1 const (&__x)[_Sz1],
                                              _T2 const (&__y)[_Sz2]) {
  return pair<_T1 const*, _T2 const*>(static_cast<_T1 const*>(__x),
                                      static_cast<_T2 const*>(__y));
}


template <class _T1, class _T2>
inline pair<_T1, _T2> make_pair(_T1 __x, _T2 __y)
{ return pair<_T1, _T2>(__x, __y); }

}


namespace std { namespace rel_ops {

template <class _Tp>
inline bool operator!=(const _Tp& __x, const _Tp& __y)
{ return !(__x == __y); }

template <class _Tp>
inline bool operator>(const _Tp& __x, const _Tp& __y)
{ return __y < __x; }

template <class _Tp>
inline bool operator<=(const _Tp& __x, const _Tp& __y)
{ return !(__y < __x); }

template <class _Tp>
inline bool operator>=(const _Tp& __x, const _Tp& __y)
{ return !(__x < __y); }

} }



namespace std {

template <class _T1, class _T2>
struct __type_traits<pair<_T1, _T2> > {
  typedef __type_traits<_T1> _T1Traits;
  typedef __type_traits<_T2> _T2Traits;
  typedef typename _Land2<typename _T1Traits::has_trivial_default_constructor,
                          typename _T2Traits::has_trivial_default_constructor>::_Ret has_trivial_default_constructor;
  typedef typename _Land2<typename _T1Traits::has_trivial_copy_constructor,
                          typename _T2Traits::has_trivial_copy_constructor>::_Ret has_trivial_copy_constructor;
  typedef typename _Land2<typename _T1Traits::has_trivial_assignment_operator,
                          typename _T2Traits::has_trivial_assignment_operator>::_Ret has_trivial_assignment_operator;
  typedef typename _Land2<typename _T1Traits::has_trivial_destructor,
                          typename _T2Traits::has_trivial_destructor>::_Ret has_trivial_destructor;
  typedef __false_type is_POD_type;
};


template <class _T1, class _T2>
struct __move_traits<pair<_T1, _T2> >
  : ::std::priv:: __move_traits_help1<_T1, _T2> {};


}
# 51 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_algobase.h" 2



# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_iterator_base.h" 1
# 49 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_iterator_base.h"
namespace std {

struct input_iterator_tag {};
struct output_iterator_tag {};
struct forward_iterator_tag : public input_iterator_tag {};
struct bidirectional_iterator_tag : public forward_iterator_tag {};
struct random_access_iterator_tag : public bidirectional_iterator_tag {};

template <class _Category, class _Tp, class _Distance = ptrdiff_t,
          class _Pointer = _Tp*, class _Reference = _Tp& >
struct iterator {
  typedef _Category iterator_category;
  typedef _Tp value_type;
  typedef _Distance difference_type;
  typedef _Pointer pointer;
  typedef _Reference reference;
};
template<>
struct iterator<output_iterator_tag, void, void, void, void> {
  typedef output_iterator_tag iterator_category;

  typedef void value_type;
  typedef void difference_type;
  typedef void pointer;
  typedef void reference;

};
# 146 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_iterator_base.h"
template <class _Iterator>
struct iterator_traits {
  typedef typename _Iterator::iterator_category iterator_category;

  typedef typename _Iterator::value_type value_type;
  typedef typename _Iterator::difference_type difference_type;
  typedef typename _Iterator::pointer pointer;
  typedef typename _Iterator::reference reference;
};
# 165 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_iterator_base.h"
template <class _Tp>
struct iterator_traits<const _Tp*> {
  typedef random_access_iterator_tag iterator_category;
  typedef _Tp value_type;
  typedef ptrdiff_t difference_type;
  typedef const _Tp* pointer;
  typedef const _Tp& reference;
};

template <class _Tp>
struct iterator_traits<_Tp*> {
  typedef random_access_iterator_tag iterator_category;
  typedef _Tp value_type;
  typedef ptrdiff_t difference_type;
  typedef _Tp* pointer;
  typedef _Tp& reference;
};
# 196 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_iterator_base.h"
}
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_ptrs_specialize.h" 1
# 198 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_iterator_base.h" 2
namespace std {
# 267 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_iterator_base.h"
template <class _Tp, class _Distance> struct input_iterator :
  public iterator <input_iterator_tag, _Tp, _Distance, _Tp*, _Tp&> {};
struct output_iterator : public iterator <output_iterator_tag, void, void, void, void> {};
template <class _Tp, class _Distance> struct forward_iterator :
  public iterator<forward_iterator_tag, _Tp, _Distance, _Tp*, _Tp&> {};
template <class _Tp, class _Distance> struct bidirectional_iterator :
  public iterator<bidirectional_iterator_tag, _Tp, _Distance, _Tp*, _Tp&> {};
template <class _Tp, class _Distance> struct random_access_iterator :
  public iterator<random_access_iterator_tag, _Tp, _Distance, _Tp*, _Tp&> {};
# 311 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_iterator_base.h"
namespace priv {

template <class _InputIterator>
inline typename iterator_traits<_InputIterator>::difference_type
__distance(const _InputIterator& __first, const _InputIterator& __last,
           const input_iterator_tag &) {
  typename iterator_traits<_InputIterator>::difference_type __n = 0;
  _InputIterator __it(__first);
  while (__it != __last) {
    ++__it; ++__n;
  }
  return __n;
}
# 351 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_iterator_base.h"
template <class _RandomAccessIterator>
inline typename iterator_traits<_RandomAccessIterator>::difference_type
__distance(const _RandomAccessIterator& __first, const _RandomAccessIterator& __last,
           const random_access_iterator_tag &)
{ return __last - __first; }

}

template <class _InputIterator>
inline typename iterator_traits<_InputIterator>::difference_type
distance(_InputIterator __first, _InputIterator __last)
{ return ::std::priv:: __distance(__first, __last, typename ::std::iterator_traits< _InputIterator >::iterator_category()); }


template <class _InputIterator, class _Distance>
inline void distance(const _InputIterator& __first,
                                const _InputIterator& __last, _Distance& __n)
{ __n += ::std::distance(__first, __last); }
# 380 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_iterator_base.h"
template <class _Tp>
struct _Nonconst_traits;

template <class _Tp>
struct _Const_traits {
  typedef _Tp value_type;
  typedef const _Tp& reference;
  typedef const _Tp* pointer;
  typedef _Const_traits<_Tp> _ConstTraits;
  typedef _Nonconst_traits<_Tp> _NonConstTraits;
};

template <class _Tp>
struct _Nonconst_traits {
  typedef _Tp value_type;
  typedef _Tp& reference;
  typedef _Tp* pointer;
  typedef _Const_traits<_Tp> _ConstTraits;
  typedef _Nonconst_traits<_Tp> _NonConstTraits;
};





template <class _Tp>
struct _Nonconst_Const_traits;

template <class _Tp>
struct _Const_Const_traits {
  typedef _Tp value_type;
  typedef const _Tp& reference;
  typedef const _Tp* pointer;
  typedef _Const_Const_traits<_Tp> _ConstTraits;
  typedef _Nonconst_Const_traits<_Tp> _NonConstTraits;
};

template <class _Tp>
struct _Nonconst_Const_traits {
  typedef _Tp value_type;
  typedef const _Tp& reference;
  typedef const _Tp* pointer;
  typedef _Const_Const_traits<_Tp> _ConstTraits;
  typedef _Nonconst_Const_traits<_Tp> _NonConstTraits;
};
# 476 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_iterator_base.h"
namespace priv {

template <class _InputIter, class _Distance>
inline void
__advance(_InputIter& __i, _Distance __n, const input_iterator_tag &)
{ while (__n--) ++__i; }


template <class _InputIter, class _Distance>
inline void
__advance(_InputIter& __i, _Distance __n, const output_iterator_tag &)
{ while (__n--) ++__i; }
# 496 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_iterator_base.h"
template <class _BidirectionalIterator, class _Distance>
inline void
__advance(_BidirectionalIterator& __i, _Distance __n,
          const bidirectional_iterator_tag &) {
  if (__n > 0)
    while (__n--) ++__i;
  else
    while (__n++) --__i;
}

template <class _RandomAccessIterator, class _Distance>
inline void
__advance(_RandomAccessIterator& __i, _Distance __n,
          const random_access_iterator_tag &)
{ __i += __n; }

}

template <class _InputIterator, class _Distance>
inline void advance(_InputIterator& __i, _Distance __n)
{ ::std::priv:: __advance(__i, __n, typename ::std::iterator_traits< _InputIterator >::iterator_category()); }

}
# 55 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_algobase.h" 2






namespace std {
# 80 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_algobase.h"
template <class _Tp>
inline void swap(_Tp& __a, _Tp& __b) {
# 91 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_algobase.h"
  _Tp __tmp = __a;
  __a = __b;
  __b = __tmp;

}

namespace priv {

template <class _ForwardIter1, class _ForwardIter2, class _Value>
inline void __iter_swap_aux_aux(_ForwardIter1& __i1, _ForwardIter2& __i2, _Value *) {
  _Value tmp = *__i1;
  *__i1 = *__i2;
  *__i2 = tmp;
}

template <class _ForwardIter1, class _ForwardIter2>
inline void __iter_swap_aux(_ForwardIter1& __i1, _ForwardIter2& __i2, const __true_type& ) {

                  swap(*__i1, *__i2);
}

template <class _ForwardIter1, class _ForwardIter2>
inline void __iter_swap_aux(_ForwardIter1& __i1, _ForwardIter2& __i2, const __false_type& ) {
  ::std::priv:: __iter_swap_aux_aux( __i1, __i2, (typename ::std::iterator_traits< _ForwardIter1 >::value_type*)0 );
}

}

template <class _ForwardIter1, class _ForwardIter2>
inline void iter_swap(_ForwardIter1 __i1, _ForwardIter2 __i2) {
  ::std::priv:: __iter_swap_aux( __i1, __i2, _IsOKToSwap((typename ::std::iterator_traits< _ForwardIter1 >::value_type*)0, (typename ::std::iterator_traits< _ForwardIter2 >::value_type*)0,
                                                      ::std::_IsRefType< typename ::std::iterator_traits< _ForwardIter1 >::reference >::_Ret(),
                                                      ::std::_IsRefType< typename ::std::iterator_traits< _ForwardIter2 >::reference >::_Ret())._Answer());
}
# 138 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_algobase.h"
template <class _Tp>
inline const _Tp& (min)(const _Tp& __a, const _Tp& __b) { return __b < __a ? __b : __a; }
template <class _Tp>
inline const _Tp& (max)(const _Tp& __a, const _Tp& __b) { return __a < __b ? __b : __a; }
# 151 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_algobase.h"
template <class _Tp, class _Compare>
inline const _Tp& (min)(const _Tp& __a, const _Tp& __b, _Compare __comp) {
  return __comp(__b, __a) ? __b : __a;
}

template <class _Tp, class _Compare>
inline const _Tp& (max)(const _Tp& __a, const _Tp& __b, _Compare __comp) {
  return __comp(__a, __b) ? __b : __a;
}
# 181 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_algobase.h"
namespace priv {

template <class _InputIter, class _OutputIter, class _Distance>
inline _OutputIter __copy(_InputIter __first, _InputIter __last,
                          _OutputIter __result, const input_iterator_tag &, _Distance*) {
  for ( ; __first != __last; ++__result, ++__first)
    *__result = *__first;
  return __result;
}
# 209 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_algobase.h"
template <class _RandomAccessIter, class _OutputIter, class _Distance>
inline _OutputIter
__copy(_RandomAccessIter __first, _RandomAccessIter __last,
       _OutputIter __result, const random_access_iterator_tag &, _Distance*) {
  for (_Distance __n = __last - __first; __n > 0; --__n) {
    *__result = *__first;
    ++__first;
    ++__result;
  }
  return __result;
}

inline void*
__copy_trivial(const void* __first, const void* __last, void* __result) {
  size_t __n = (const char*)__last - (const char*)__first;
  return __n ? (void *)((char*)memmove(__result, __first, __n) + __n) : __result;
}




template <class _BidirectionalIter1, class _BidirectionalIter2,
          class _Distance>
inline _BidirectionalIter2 __copy_backward(_BidirectionalIter1 __first,
                                           _BidirectionalIter1 __last,
                                           _BidirectionalIter2 __result,
                                           const bidirectional_iterator_tag &,
                                           _Distance*) {
  while (__first != __last)
    *--__result = *--__last;
  return __result;
}

template <class _RandomAccessIter, class _BidirectionalIter, class _Distance>
inline _BidirectionalIter __copy_backward(_RandomAccessIter __first,
                                          _RandomAccessIter __last,
                                          _BidirectionalIter __result,
                                          const random_access_iterator_tag &,
                                          _Distance*) {
  for (_Distance __n = __last - __first; __n > 0; --__n)
    *--__result = *--__last;
  return __result;
}

inline void*
__copy_trivial_backward(const void* __first, const void* __last, void* __result) {
  const ptrdiff_t _Num = (const char*)__last - (const char*)__first;
  return (_Num > 0) ? memmove((char*)__result - _Num, __first, _Num) : __result ;
}

template <class _InputIter, class _OutputIter>
inline _OutputIter __copy_ptrs(_InputIter __first, _InputIter __last, _OutputIter __result,
                               const __false_type& ) {
  return ::std::priv:: __copy(__first, __last, __result, random_access_iterator_tag(), (ptrdiff_t*)0);
}
template <class _InputIter, class _OutputIter>
inline _OutputIter __copy_ptrs(_InputIter __first, _InputIter __last, _OutputIter __result,
                               const __true_type& ) {


  return (_OutputIter)::std::priv:: __copy_trivial(__first, __last, __result);
}

template <class _InputIter, class _OutputIter>
inline _OutputIter __copy_aux(_InputIter __first, _InputIter __last, _OutputIter __result,
                              const __true_type& ) {
  return ::std::priv:: __copy_ptrs(__first, __last, __result,
                                _UseTrivialCopy((typename ::std::iterator_traits< _InputIter >::value_type*)0,
                                                (typename ::std::iterator_traits< _OutputIter >::value_type*)0)._Answer());
}

template <class _InputIter, class _OutputIter>
inline _OutputIter __copy_aux(_InputIter __first, _InputIter __last, _OutputIter __result,
                              const __false_type& ) {
  return ::std::priv:: __copy(__first, __last, __result,
                           typename ::std::iterator_traits< _InputIter >::iterator_category(),
                           (typename ::std::iterator_traits< _InputIter >::difference_type*)0);
}

}

template <class _InputIter, class _OutputIter>
inline _OutputIter copy(_InputIter __first, _InputIter __last, _OutputIter __result) {
 
  return ::std::priv:: __copy_aux(__first, __last, __result, _BothPtrType< _InputIter, _OutputIter>::_Answer());
}

namespace priv {

template <class _InputIter, class _OutputIter>
inline _OutputIter __copy_backward_ptrs(_InputIter __first, _InputIter __last,
                                        _OutputIter __result, const __false_type& ) {
  return ::std::priv:: __copy_backward(__first, __last, __result,
                                    typename ::std::iterator_traits< _InputIter >::iterator_category(),
                                    (typename ::std::iterator_traits< _InputIter >::difference_type*)0);
}
template <class _InputIter, class _OutputIter>
inline _OutputIter __copy_backward_ptrs(_InputIter __first, _InputIter __last,
                                        _OutputIter __result, const __true_type& ) {
  return (_OutputIter)::std::priv:: __copy_trivial_backward(__first, __last, __result);
}

template <class _InputIter, class _OutputIter>
inline _OutputIter __copy_backward_aux(_InputIter __first, _InputIter __last, _OutputIter __result, const __false_type&) {
  return ::std::priv:: __copy_backward(__first, __last, __result,
                                    typename ::std::iterator_traits< _InputIter >::iterator_category(),
                                    (typename ::std::iterator_traits< _InputIter >::difference_type*)0);
}

template <class _InputIter, class _OutputIter>
inline _OutputIter __copy_backward_aux(_InputIter __first, _InputIter __last, _OutputIter __result, const __true_type&) {
  return ::std::priv:: __copy_backward_ptrs(__first, __last, __result,
                                         _UseTrivialCopy((typename ::std::iterator_traits< _InputIter >::value_type*)0,
                                                         (typename ::std::iterator_traits< _OutputIter >::value_type*)0)._Answer());
}

}

template <class _InputIter, class _OutputIter>
inline _OutputIter copy_backward(_InputIter __first, _InputIter __last, _OutputIter __result) {
 
  return ::std::priv:: __copy_backward_aux(__first, __last, __result, _BothPtrType< _InputIter, _OutputIter>::_Answer() );
}
# 373 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_algobase.h"
namespace priv {

template <class _InputIter, class _Size, class _OutputIter>
inline ::std::pair<_InputIter, _OutputIter>
__copy_n(_InputIter __first, _Size __count, _OutputIter __result,
         const input_iterator_tag &) {
  for ( ; __count > 0; --__count) {
    *__result = *__first;
    ++__first;
    ++__result;
  }
  return ::std::pair<_InputIter, _OutputIter>(__first, __result);
}

template <class _RAIter, class _Size, class _OutputIter>
inline ::std::pair<_RAIter, _OutputIter>
__copy_n(_RAIter __first, _Size __count, _OutputIter __result,
         const random_access_iterator_tag &) {
  _RAIter __last = __first + __count;
  return ::std::pair<_RAIter, _OutputIter>(__last, ::std::copy(__first, __last, __result));
}

}

template <class _InputIter, class _Size, class _OutputIter>
inline pair<_InputIter, _OutputIter>
copy_n(_InputIter __first, _Size __count, _OutputIter __result) {
 
  return ::std::priv:: __copy_n(__first, __count, __result, typename ::std::iterator_traits< _InputIter >::iterator_category());
}




namespace priv {

template <class _ForwardIter, class _Tp>
inline
void __fill_fwd(_ForwardIter __first, _ForwardIter __last, const _Tp& __val) {
  for ( ; __first != __last; ++__first)
    *__first = __val;
}

template <class _ForwardIter, class _Tp, class _Distance>
inline void __fill(_ForwardIter __first, _ForwardIter __last, const _Tp& __val,
                   const input_iterator_tag &, _Distance*) {
  ::std::priv:: __fill_fwd(__first, __last, __val);
}
# 438 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_algobase.h"
template <class _RandomAccessIter, class _Tp, class _Distance>
inline
void __fill(_RandomAccessIter __first, _RandomAccessIter __last, const _Tp& __val,
            const random_access_iterator_tag &, _Distance*) {
  for (_Distance __n = __last - __first ; __n > 0; ++__first, --__n)
    *__first = __val;
}

}

template <class _ForwardIter, class _Tp>
inline void fill(_ForwardIter __first, _ForwardIter __last, const _Tp& __val) {
 
  ::std::priv:: __fill(__first, __last, __val,
                    typename ::std::iterator_traits< _ForwardIter >::iterator_category(),
                    (typename ::std::iterator_traits< _ForwardIter >::difference_type*)0);
}


inline void fill(unsigned char* __first, unsigned char* __last,
                 const unsigned char& __val) {
  unsigned char __tmp = __val;
  memset(__first, __tmp, __last - __first);
}

inline void fill(signed char* __first, signed char* __last,
                 const signed char& __val) {
  signed char __tmp = __val;
  memset(__first, static_cast<unsigned char>(__tmp), __last - __first);
}

inline void fill(char* __first, char* __last, const char& __val) {
  char __tmp = __val;
  memset(__first, static_cast<unsigned char>(__tmp), __last - __first);
}

namespace priv {

template <class _OutputIter, class _Size, class _Tp>
inline
_OutputIter __fill_n(_OutputIter __first, _Size __n, const _Tp& __val) {
 
  for ( ; __n > 0; --__n, ++__first)
    *__first = __val;
  return __first;
}


template <class _Size>
inline unsigned char* __fill_n(unsigned char* __first, _Size __n,
                               const unsigned char& __val) {
  ::std::fill(__first, __first + __n, __val);
  return __first + __n;
}

template <class _Size>
inline signed char* __fill_n(signed char* __first, _Size __n,
                             const signed char& __val) {
  ::std::fill(__first, __first + __n, __val);
  return __first + __n;
}

template <class _Size>
inline char* __fill_n(char* __first, _Size __n,
                      const char& __val) {
  ::std::fill(__first, __first + __n, __val);
  return __first + __n;
}


}

template <class _OutputIter, class _Size, class _Tp>
inline void fill_n(_OutputIter __first, _Size __n, const _Tp& __val) {
 
  ::std::priv:: __fill_n(__first, __n, __val);
}





template <class _InputIter1, class _InputIter2>
inline
::std::pair<_InputIter1, _InputIter2> mismatch(_InputIter1 __first1,
                                                   _InputIter1 __last1,
                                                   _InputIter2 __first2) {
 
 
  while (__first1 != __last1 && *__first1 == *__first2) {
    ++__first1;
    ++__first2;
  }
  return ::std::pair<_InputIter1, _InputIter2>(__first1, __first2);
}

template <class _InputIter1, class _InputIter2, class _BinaryPredicate>
inline
::std::pair<_InputIter1, _InputIter2> mismatch(_InputIter1 __first1,
                                                   _InputIter1 __last1,
                                                   _InputIter2 __first2,
                                                   _BinaryPredicate __binary_pred) {
 
 
  while (__first1 != __last1 && __binary_pred(*__first1, *__first2)) {
    ++__first1;
    ++__first2;
  }
  return ::std::pair<_InputIter1, _InputIter2>(__first1, __first2);
}

template <class _InputIter1, class _InputIter2>
inline
bool equal(_InputIter1 __first1, _InputIter1 __last1,
           _InputIter2 __first2) {
 
 
  for ( ; __first1 != __last1; ++__first1, ++__first2)
    if (!(*__first1 == *__first2))
      return false;
  return true;
}

template <class _InputIter1, class _InputIter2, class _BinaryPredicate>
inline
bool equal(_InputIter1 __first1, _InputIter1 __last1,
           _InputIter2 __first2, _BinaryPredicate __binary_pred) {
 
 
  for ( ; __first1 != __last1; ++__first1, ++__first2)
    if (!__binary_pred(*__first1, *__first2))
      return false;
  return true;
}





template <class _InputIter1, class _InputIter2>
bool lexicographical_compare(_InputIter1 __first1, _InputIter1 __last1,
                             _InputIter2 __first2, _InputIter2 __last2);

template <class _InputIter1, class _InputIter2, class _Compare>
bool lexicographical_compare(_InputIter1 __first1, _InputIter1 __last1,
                             _InputIter2 __first2, _InputIter2 __last2,
                             _Compare __comp);

inline bool
lexicographical_compare(const unsigned char* __first1,
                        const unsigned char* __last1,
                        const unsigned char* __first2,
                        const unsigned char* __last2) {
  const size_t __len1 = __last1 - __first1;
  const size_t __len2 = __last2 - __first2;
 
 

  const int __result = memcmp(__first1, __first2, (min) (__len1, __len2));
  return __result != 0 ? (__result < 0) : (__len1 < __len2);
}



inline bool lexicographical_compare(const char* __first1, const char* __last1,
                                    const char* __first2, const char* __last2) {
 
 

  return lexicographical_compare((const unsigned char*) __first1,
                                 (const unsigned char*) __last1,
                                 (const unsigned char*) __first2,
                                 (const unsigned char*) __last2);
}


namespace priv {

template <class _InputIter1, class _InputIter2>
int __lexicographical_compare_3way(_InputIter1 __first1, _InputIter1 __last1,
                                   _InputIter2 __first2, _InputIter2 __last2);

inline int
__lexicographical_compare_3way(const unsigned char* __first1,
                               const unsigned char* __last1,
                               const unsigned char* __first2,
                               const unsigned char* __last2) {
  const ptrdiff_t __len1 = __last1 - __first1;
  const ptrdiff_t __len2 = __last2 - __first2;
  const int __result = memcmp(__first1, __first2, (min) (__len1, __len2));
  return __result != 0 ? __result
                       : (__len1 == __len2 ? 0 : (__len1 < __len2 ? -1 : 1));
}



inline int
__lexicographical_compare_3way(const char* __first1, const char* __last1,
                               const char* __first2, const char* __last2) {
  return __lexicographical_compare_3way((const unsigned char*) __first1,
                                        (const unsigned char*) __last1,
                                        (const unsigned char*) __first2,
                                        (const unsigned char*) __last2);
}


}


template <class _InputIter1, class _InputIter2>
int lexicographical_compare_3way(_InputIter1 __first1, _InputIter1 __last1,
                                 _InputIter2 __first2, _InputIter2 __last2);




template <class _InputIter, class _Tp>
inline typename iterator_traits<_InputIter>::difference_type
count(_InputIter __first, _InputIter __last, const _Tp& __val) {
 
  typename iterator_traits<_InputIter>::difference_type __n = 0;
  for ( ; __first != __last; ++__first)
    if (*__first == __val)
      ++__n;
  return __n;
}


template <class _InputIter, class _Tp>
_InputIter find(_InputIter __first, _InputIter __last, const _Tp& __val);

template <class _InputIter, class _Predicate>
_InputIter find_if(_InputIter __first, _InputIter __last, _Predicate __pred);


template <class _ForwardIter1, class _ForwardIter2, class _BinaryPred>
_ForwardIter1 search(_ForwardIter1 __first1, _ForwardIter1 __last1,
                     _ForwardIter2 __first2, _ForwardIter2 __last2, _BinaryPred __predicate);

namespace priv {


template <class _InputIter, class _ForwardIter>
_InputIter __find_first_of(_InputIter __first1, _InputIter __last1,
                           _ForwardIter __first2, _ForwardIter __last2);

template <class _InputIter, class _ForwardIter, class _BinaryPredicate>
_InputIter __find_first_of(_InputIter __first1, _InputIter __last1,
                           _ForwardIter __first2, _ForwardIter __last2,
                           _BinaryPredicate __comp);

}

template <class _ForwardIter1, class _ForwardIter2,
          class _BinaryPredicate>
_ForwardIter1
find_end(_ForwardIter1 __first1, _ForwardIter1 __last1,
         _ForwardIter2 __first2, _ForwardIter2 __last2,
         _BinaryPredicate __comp);


template <class _ForwardIter, class _Tp>
inline void
replace(_ForwardIter __first, _ForwardIter __last,
        const _Tp& __old_value, const _Tp& __new_value) {
 
  for ( ; __first != __last; ++__first)
    if (*__first == __old_value)
      *__first = __new_value;
}

namespace priv {

template <class _ForwardIter, class _Tp, class _Compare1, class _Compare2, class _Distance>
_ForwardIter __lower_bound(_ForwardIter __first, _ForwardIter __last,
                           const _Tp& __val, _Compare1 __comp1, _Compare2 __comp2, _Distance*);

}

}


# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_algobase.c" 1
# 33 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_algobase.c"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_function_base.h" 1
# 37 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_function_base.h"
namespace std {

template <class _Arg, class _Result>
struct unary_function {
  typedef _Arg argument_type;
  typedef _Result result_type;

protected:



  ~unary_function() {}

};

template <class _Arg1, class _Arg2, class _Result>
struct binary_function {
  typedef _Arg1 first_argument_type;
  typedef _Arg2 second_argument_type;
  typedef _Result result_type;

protected:

  ~binary_function() {}

};

template <class _Tp>
struct equal_to : public binary_function<_Tp, _Tp, bool> {
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x == __y; }
};

template <class _Tp>
struct less : public binary_function<_Tp,_Tp,bool>





              , public __stlport_class<less<_Tp> >

{
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x < __y; }




};


template <class _Tp>
struct __type_traits<less<_Tp> > {

  typedef typename _IsSTLportClass<less<_Tp> >::_Ret _STLportLess;




  typedef _STLportLess has_trivial_default_constructor;
  typedef _STLportLess has_trivial_copy_constructor;
  typedef _STLportLess has_trivial_assignment_operator;
  typedef _STLportLess has_trivial_destructor;
  typedef _STLportLess is_POD_type;
};


namespace priv {

template <class _Tp>
less<_Tp> __less(_Tp* ) { return less<_Tp>(); }

template <class _Tp>
equal_to<_Tp> __equal_to(_Tp* ) { return equal_to<_Tp>(); }

}

template <class _Tp>
struct plus : public binary_function<_Tp, _Tp, _Tp> {
  _Tp operator()(const _Tp& __x, const _Tp& __y) const { return __x + __y; }
};

template <class _Tp>
struct minus : public binary_function<_Tp, _Tp, _Tp> {
  _Tp operator()(const _Tp& __x, const _Tp& __y) const { return __x - __y; }
};

namespace priv {

template <class _Tp>
plus<_Tp> __plus(_Tp* ) { return plus<_Tp>(); }

template <class _Tp>
minus<_Tp> __minus(_Tp* ) { return minus<_Tp>(); }

}

template <class _Tp>
struct multiplies : public binary_function<_Tp, _Tp, _Tp> {
  _Tp operator()(const _Tp& __x, const _Tp& __y) const { return __x * __y; }
};

namespace priv {

template <class _Pair>
struct _Select1st : public unary_function<_Pair, typename _Pair::first_type> {
  const typename _Pair::first_type& operator()(const _Pair& __x) const {
    return __x.first;
  }
};

template <class _Pair>
struct _Select2nd : public unary_function<_Pair, typename _Pair::second_type> {
  const typename _Pair::second_type& operator()(const _Pair& __x) const {
    return __x.second;
  }
};


template <class _Arg1, class _Arg2>
struct _Project1st : public binary_function<_Arg1, _Arg2, _Arg1> {
  _Arg1 operator()(const _Arg1& __x, const _Arg2&) const { return __x; }
};

template <class _Arg1, class _Arg2>
struct _Project2nd : public binary_function<_Arg1, _Arg2, _Arg2> {
  _Arg2 operator()(const _Arg1&, const _Arg2& __y) const { return __y; }
};
# 177 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_function_base.h"
template <class _Tp>
struct _Identity : public unary_function<_Tp,_Tp> {
  const _Tp& operator()(const _Tp& __x) const { return __x; }
};

template <class _Result, class _Argument>
struct _Constant_unary_fun {
  typedef _Argument argument_type;
  typedef _Result result_type;
  result_type _M_val;

  _Constant_unary_fun(const result_type& __v) : _M_val(__v) {}
  const result_type& operator()(const _Argument&) const { return _M_val; }
};

template <class _Result, class _Arg1, class _Arg2>
struct _Constant_binary_fun {
  typedef _Arg1 first_argument_type;
  typedef _Arg2 second_argument_type;
  typedef _Result result_type;
  _Result _M_val;

  _Constant_binary_fun(const _Result& __v) : _M_val(__v) {}
  const result_type& operator()(const _Arg1&, const _Arg2&) const {
    return _M_val;
  }
};


template <class _Tp> inline _Tp __identity_element(plus<_Tp>) { return _Tp(0); }
template <class _Tp> inline _Tp __identity_element(multiplies<_Tp>) { return _Tp(1); }

}

}
# 34 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_algobase.c" 2


namespace std {

template <class _InputIter1, class _InputIter2>
bool lexicographical_compare(_InputIter1 __first1, _InputIter1 __last1,
                             _InputIter2 __first2, _InputIter2 __last2) {
 
 
  for ( ; __first1 != __last1 && __first2 != __last2
        ; ++__first1, ++__first2) {
    if (*__first1 < *__first2) {
     
      return true;
    }
    if (*__first2 < *__first1)
      return false;
  }
  return __first1 == __last1 && __first2 != __last2;
}

template <class _InputIter1, class _InputIter2, class _Compare>
bool lexicographical_compare(_InputIter1 __first1, _InputIter1 __last1,
                             _InputIter2 __first2, _InputIter2 __last2,
                             _Compare __comp) {
 
 
  for ( ; __first1 != __last1 && __first2 != __last2
        ; ++__first1, ++__first2) {
    if (__comp(*__first1, *__first2)) {
     

      return true;
    }
    if (__comp(*__first2, *__first1))
      return false;
  }
  return __first1 == __last1 && __first2 != __last2;
}


namespace priv {

template <class _InputIter1, class _InputIter2>
int __lexicographical_compare_3way(_InputIter1 __first1, _InputIter1 __last1,
                                   _InputIter2 __first2, _InputIter2 __last2) {
  while (__first1 != __last1 && __first2 != __last2) {
    if (*__first1 < *__first2) {
     
      return -1;
    }
    if (*__first2 < *__first1)
      return 1;
    ++__first1;
    ++__first2;
  }
  if (__first2 == __last2) {
    return !(__first1 == __last1);
  }
  else {
    return -1;
  }
}

}

template <class _InputIter1, class _InputIter2>
int lexicographical_compare_3way(_InputIter1 __first1, _InputIter1 __last1,
                                 _InputIter2 __first2, _InputIter2 __last2) {
 
 
  return ::std::priv:: __lexicographical_compare_3way(__first1, __last1, __first2, __last2);
}


namespace priv {

template <class _RandomAccessIter, class _Tp>
inline _RandomAccessIter __find(_RandomAccessIter __first, _RandomAccessIter __last,
                                           const _Tp& __val,
                                           const random_access_iterator_tag &) {
  typename iterator_traits<_RandomAccessIter>::difference_type __trip_count = (__last - __first) >> 2;

  for ( ; __trip_count > 0 ; --__trip_count) {
    if (*__first == __val) return __first;
    ++__first;

    if (*__first == __val) return __first;
    ++__first;

    if (*__first == __val) return __first;
    ++__first;

    if (*__first == __val) return __first;
    ++__first;
  }

  switch (__last - __first) {
  case 3:
    if (*__first == __val) return __first;
    ++__first;
  case 2:
    if (*__first == __val) return __first;
    ++__first;
  case 1:
    if (*__first == __val) return __first;

  case 0:
  default:
    return __last;
  }
}

inline char*
__find(char* __first, char* __last, char __val, const random_access_iterator_tag &) {
  void *res = memchr(__first, __val, __last - __first);
  return res != 0 ? static_cast<char*>(res) : __last;
}
inline const char*
__find(const char* __first, const char* __last, char __val, const random_access_iterator_tag &) {
  const void *res = memchr(__first, __val, __last - __first);
  return res != 0 ? static_cast<const char*>(res) : __last;
}

template <class _RandomAccessIter, class _Predicate>
inline _RandomAccessIter __find_if(_RandomAccessIter __first, _RandomAccessIter __last,
                                              _Predicate __pred,
                                              const random_access_iterator_tag &) {
  typename iterator_traits<_RandomAccessIter>::difference_type __trip_count = (__last - __first) >> 2;

  for ( ; __trip_count > 0 ; --__trip_count) {
    if (__pred(*__first)) return __first;
    ++__first;

    if (__pred(*__first)) return __first;
    ++__first;

    if (__pred(*__first)) return __first;
    ++__first;

    if (__pred(*__first)) return __first;
    ++__first;
  }

  switch(__last - __first) {
  case 3:
    if (__pred(*__first)) return __first;
    ++__first;
  case 2:
    if (__pred(*__first)) return __first;
    ++__first;
  case 1:
    if (__pred(*__first)) return __first;

  case 0:
  default:
    return __last;
  }
}

template <class _InputIter, class _Tp>
inline _InputIter __find(_InputIter __first, _InputIter __last,
                                    const _Tp& __val,
                                    const input_iterator_tag &) {
  while (__first != __last && !(*__first == __val)) ++__first;
  return __first;
}

template <class _InputIter, class _Predicate>
inline _InputIter __find_if(_InputIter __first, _InputIter __last,
                                       _Predicate __pred,
                                       const input_iterator_tag &) {
  while (__first != __last && !__pred(*__first))
    ++__first;
  return __first;
}

}

template <class _InputIter, class _Predicate>
_InputIter find_if(_InputIter __first, _InputIter __last,
                   _Predicate __pred) {
 
  return ::std::priv:: __find_if(__first, __last, __pred, typename ::std::iterator_traits< _InputIter >::iterator_category());
}

template <class _InputIter, class _Tp>
_InputIter find(_InputIter __first, _InputIter __last, const _Tp& __val) {
 
  return ::std::priv:: __find(__first, __last, __val, typename ::std::iterator_traits< _InputIter >::iterator_category());
}

template <class _ForwardIter1, class _ForwardIter2, class _BinaryPred>
_ForwardIter1 search(_ForwardIter1 __first1, _ForwardIter1 __last1,
                     _ForwardIter2 __first2, _ForwardIter2 __last2,
                     _BinaryPred __pred) {
 
 

  if (__first1 == __last1 || __first2 == __last2)
    return __first1;


  _ForwardIter2 __p1(__first2);

  if ( ++__p1 == __last2 ) {
    while (__first1 != __last1 && !__pred(*__first1, *__first2)) {
      ++__first1;
    }
    return __first1;
  }



  for ( ; ; ) {
    while (__first1 != __last1 && !__pred(*__first1, *__first2)) {
      ++__first1;
    }
    if (__first1 == __last1) {
      return __last1;
    }
    _ForwardIter2 __p = __p1;
    _ForwardIter1 __current = __first1;
    if (++__current == __last1) return __last1;

    while (__pred(*__current, *__p)) {
      if (++__p == __last2)
        return __first1;
      if (++__current == __last1)
        return __last1;
    }
    ++__first1;
  }
  return __first1;
}

namespace priv {
template <class _Tp>
struct _IsCharLikeType
{ typedef __false_type _Ret; };

template<> struct _IsCharLikeType<char>
{ typedef __true_type _Ret; };

template<> struct _IsCharLikeType<unsigned char>
{ typedef __true_type _Ret; };


template<> struct _IsCharLikeType<signed char>
{ typedef __true_type _Ret; };


template <class _Tp1, class _Tp2>
inline bool __stlp_eq(_Tp1 __val1, _Tp2 __val2)
{ return __val1 == __val2; }


template <class _Tp>
inline bool __stlp_eq(_Tp, _Tp)
{ return true; }


template <class _InputIter, class _ForwardIter, class _Tp2, class _Predicate>
inline _InputIter __find_first_of_aux2(_InputIter __first1, _InputIter __last1,
                                       _ForwardIter __first2, _ForwardIter __last2,
                                       _Tp2*, _Predicate __pred,
                                       const __true_type& ) {
  unsigned char __hints[(0xffU + 1) / 8];
  memset(__hints, 0, sizeof(__hints) / sizeof(unsigned char));
  for (; __first2 != __last2; ++__first2) {
    unsigned char __tmp = (unsigned char)*__first2;
    __hints[__tmp / 8] |= (1 << (__tmp % 8));
  }

  for (; __first1 != __last1; ++__first1) {
    _Tp2 __tmp = (_Tp2)*__first1;
    if (__stlp_eq(*__first1, __tmp) &&
        __pred((__hints[(unsigned char)__tmp / 8] & (1 << ((unsigned char)__tmp % 8))) != 0))
      break;
  }
  return __first1;
}

template <class _InputIter, class _ForwardIter, class _Tp2, class _Predicate>
inline _InputIter __find_first_of_aux2(_InputIter __first1, _InputIter __last1,
                                       _ForwardIter __first2, _ForwardIter __last2,
                                       _Tp2* , _Predicate ,
                                       const __false_type& ) {
  return ::std::priv:: __find_first_of(__first1, __last1, __first2, __last2,
                                    ::std::priv:: __equal_to((typename ::std::iterator_traits< _InputIter >::value_type*)0));
}

template <class _InputIter, class _ForwardIter, class _Tp1, class _Tp2>
inline _InputIter __find_first_of_aux1(_InputIter __first1, _InputIter __last1,
                                       _ForwardIter __first2, _ForwardIter __last2,
                                       _Tp1* __pt1, _Tp2* __pt2) {
  typedef typename ::std::_IsIntegral<_Tp1>::_Ret _IsIntegral;
  typedef typename ::std::priv:: _IsCharLikeType<_Tp2>::_Ret _IsCharLike;
  typedef typename ::std::_Land2<_IsIntegral, _IsCharLike>::_Ret _UseStrcspnLikeAlgo;
  return ::std::priv:: __find_first_of_aux2(__first1, __last1,
                                         __first2, __last2,
                                         __pt2, _Identity<bool>(), _UseStrcspnLikeAlgo());
}

template <class _InputIter, class _ForwardIter>
inline _InputIter __find_first_of(_InputIter __first1, _InputIter __last1,
                                  _ForwardIter __first2, _ForwardIter __last2) {
  return ::std::priv:: __find_first_of_aux1(__first1, __last1, __first2, __last2,
                                         (typename ::std::iterator_traits< _InputIter >::value_type*)0,
                                         (typename ::std::iterator_traits< _ForwardIter >::value_type*)0);
}


template <class _InputIter, class _ForwardIter, class _BinaryPredicate>
_InputIter __find_first_of(_InputIter __first1, _InputIter __last1,
                           _ForwardIter __first2, _ForwardIter __last2,
                           _BinaryPredicate __comp) {
  for ( ; __first1 != __last1; ++__first1) {
    for (_ForwardIter __iter = __first2; __iter != __last2; ++__iter) {
      if (__comp(*__first1, *__iter)) {
        return __first1;
      }
    }
  }
  return __last1;
}







template <class _ForwardIter1, class _ForwardIter2,
  class _BinaryPredicate>
_ForwardIter1 __find_end(_ForwardIter1 __first1, _ForwardIter1 __last1,
                         _ForwardIter2 __first2, _ForwardIter2 __last2,
                         const forward_iterator_tag &, const forward_iterator_tag &,
                         _BinaryPredicate __comp) {
  if (__first2 == __last2)
    return __last1;
  else {
    _ForwardIter1 __result = __last1;
    for (;;) {
      _ForwardIter1 __new_result = ::std::search(__first1, __last1, __first2, __last2, __comp);
      if (__new_result == __last1)
        return __result;
      else {
        __result = __new_result;
        __first1 = __new_result;
        ++__first1;
      }
    }
  }
}

}





}
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_iterator.h" 1
# 37 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_iterator.h"
namespace std {
# 46 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_iterator.h"
template <class _Iterator>
class reverse_iterator :
  public iterator<typename iterator_traits<_Iterator>::iterator_category,
                  typename iterator_traits<_Iterator>::value_type,
                  typename iterator_traits<_Iterator>::difference_type,
                  typename iterator_traits<_Iterator>::pointer,
                  typename iterator_traits<_Iterator>::reference> {
protected:
  _Iterator current;
  typedef reverse_iterator<_Iterator> _Self;
public:
  typedef typename iterator_traits<_Iterator>::difference_type difference_type;

  typedef typename iterator_traits<_Iterator>::pointer pointer;
  typedef typename iterator_traits<_Iterator>::reference reference;
  typedef _Iterator iterator_type;
public:
  reverse_iterator() {}
  explicit reverse_iterator(iterator_type __x) : current(__x) {}
  reverse_iterator(const _Self& __x) : current(__x.current) {}
  _Self& operator = (const _Self& __x) { current = __x.base(); return *this; }

  template <class _Iter>
  reverse_iterator(const reverse_iterator<_Iter>& __x) : current(__x.base()) {}
  template <class _Iter>
  _Self& operator = (const reverse_iterator<_Iter>& __x) { current = __x.base(); return *this; }


  iterator_type base() const { return current; }
  reference operator*() const {
    _Iterator __tmp = current;
    return *--__tmp;
  }
  pointer operator->() const { return &(operator*()); }
  _Self& operator++() {
    --current;
    return *this;
  }
  _Self operator++(int) {
    _Self __tmp = *this;
    --current;
    return __tmp;
  }
  _Self& operator--() {
    ++current;
    return *this;
  }
  _Self operator--(int) {
    _Self __tmp = *this;
    ++current;
    return __tmp;
  }

  _Self operator+(difference_type __n) const { return _Self(current - __n); }
  _Self& operator+=(difference_type __n) {
    current -= __n;
    return *this;
  }
  _Self operator-(difference_type __n) const { return _Self(current + __n); }
  _Self& operator-=(difference_type __n) {
    current += __n;
    return *this;
  }
  reference operator[](difference_type __n) const { return *(*this + __n); }
};

template <class _Iterator>
inline bool operator==(const reverse_iterator<_Iterator>& __x,
                                   const reverse_iterator<_Iterator>& __y)
{ return __x.base() == __y.base(); }

template <class _Iterator>
inline bool operator<(const reverse_iterator<_Iterator>& __x,
                                 const reverse_iterator<_Iterator>& __y)
{ return __y.base() < __x.base(); }


template <class _Iterator>
inline bool operator!=(const reverse_iterator<_Iterator>& __x,
                                  const reverse_iterator<_Iterator>& __y)
{ return !(__x == __y); }

template <class _Iterator>
inline bool operator>(const reverse_iterator<_Iterator>& __x,
                                 const reverse_iterator<_Iterator>& __y)
{ return __y < __x; }

template <class _Iterator>
inline bool operator<=(const reverse_iterator<_Iterator>& __x,
                                  const reverse_iterator<_Iterator>& __y)
{ return !(__y < __x); }

template <class _Iterator>
inline bool operator>=(const reverse_iterator<_Iterator>& __x,
                                  const reverse_iterator<_Iterator>& __y)
{ return !(__x < __y); }


template <class _Iterator>



inline typename reverse_iterator<_Iterator>::difference_type

operator-(const reverse_iterator<_Iterator>& __x,
          const reverse_iterator<_Iterator>& __y)
{ return __y.base() - __x.base(); }

template <class _Iterator, class _DifferenceType>
inline reverse_iterator<_Iterator>
operator+(_DifferenceType n,const reverse_iterator<_Iterator>& x)
{ return x.operator+(n); }


template <class _Container>
class back_insert_iterator
  : public iterator<output_iterator_tag, void, void, void, void> {
  typedef back_insert_iterator<_Container> _Self;
protected:

  _Container *container;
public:
  typedef _Container container_type;
  typedef output_iterator_tag iterator_category;

  explicit back_insert_iterator(_Container& __x) : container(&__x) {}

  _Self& operator=(const _Self& __other) {
    container = __other.container;
    return *this;
  }
  _Self& operator=(const typename _Container::value_type& __val) {
    container->push_back(__val);
    return *this;
  }
  _Self& operator*() { return *this; }
  _Self& operator++() { return *this; }
  _Self operator++(int) { return *this; }
};

template <class _Container>
inline back_insert_iterator<_Container> back_inserter(_Container& __x)
{ return back_insert_iterator<_Container>(__x); }

template <class _Container>
class front_insert_iterator
  : public iterator<output_iterator_tag, void, void, void, void> {
  typedef front_insert_iterator<_Container> _Self;
protected:

  _Container *container;
public:
  typedef _Container container_type;
  typedef output_iterator_tag iterator_category;
  explicit front_insert_iterator(_Container& __x) : container(&__x) {}

  _Self& operator=(const _Self& __other) {
    container = __other.container;
    return *this;
  }
  _Self& operator=(const typename _Container::value_type& __val) {
    container->push_front(__val);
    return *this;
  }
  _Self& operator*() { return *this; }
  _Self& operator++() { return *this; }
  _Self operator++(int) { return *this; }
};

template <class _Container>
inline front_insert_iterator<_Container> front_inserter(_Container& __x)
{ return front_insert_iterator<_Container>(__x); }

template <class _Container>
class insert_iterator
  : public iterator<output_iterator_tag, void, void, void, void> {
  typedef insert_iterator<_Container> _Self;
protected:

  _Container *container;
  typename _Container::iterator _M_iter;
public:
  typedef _Container container_type;
  typedef output_iterator_tag iterator_category;
  insert_iterator(_Container& __x, typename _Container::iterator __i)
    : container(&__x), _M_iter(__i) {}

  _Self& operator=(_Self const& __other) {
    container = __other.container;
    _M_iter = __other._M_iter;
    return *this;
  }
  _Self& operator=(const typename _Container::value_type& __val) {
    _M_iter = container->insert(_M_iter, __val);
    ++_M_iter;
    return *this;
  }
  _Self& operator*() { return *this; }
  _Self& operator++() { return *this; }
  _Self& operator++(int) { return *this; }
};

template <class _Container, class _Iterator>
inline insert_iterator<_Container>
inserter(_Container& __x, _Iterator __i) {
  typedef typename _Container::iterator __iter;
  return insert_iterator<_Container>(__x, __iter(__i));
}

}
# 398 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_algobase.c" 2
namespace std {


namespace priv {

template <class _BidirectionalIter1, class _BidirectionalIter2,
          class _BinaryPredicate>
_BidirectionalIter1
__find_end(_BidirectionalIter1 __first1, _BidirectionalIter1 __last1,
           _BidirectionalIter2 __first2, _BidirectionalIter2 __last2,
           const bidirectional_iterator_tag &, const bidirectional_iterator_tag &,
           _BinaryPredicate __comp) {
  typedef ::std::reverse_iterator<_BidirectionalIter1> _RevIter1;
  typedef ::std::reverse_iterator<_BidirectionalIter2> _RevIter2;

  _RevIter1 __rlast1(__first1);
  _RevIter2 __rlast2(__first2);
  _RevIter1 __rresult = ::std::search(_RevIter1(__last1), __rlast1,
                                          _RevIter2(__last2), __rlast2,
                                          __comp);

  if (__rresult == __rlast1)
    return __last1;
  else {
    _BidirectionalIter1 __result = __rresult.base();
    ::std::advance(__result, -::std::distance(__first2, __last2));
    return __result;
  }
}

}


template <class _ForwardIter1, class _ForwardIter2,
          class _BinaryPredicate>
_ForwardIter1
find_end(_ForwardIter1 __first1, _ForwardIter1 __last1,
         _ForwardIter2 __first2, _ForwardIter2 __last2,
         _BinaryPredicate __comp) {
 
 
  return ::std::priv:: __find_end(__first1, __last1, __first2, __last2,

                               typename ::std::iterator_traits< _ForwardIter1 >::iterator_category(),
                               typename ::std::iterator_traits< _ForwardIter2 >::iterator_category(),




                               __comp);
}

namespace priv {

template <class _ForwardIter, class _Tp, class _Compare1, class _Compare2, class _Distance>
_ForwardIter __lower_bound(_ForwardIter __first, _ForwardIter __last, const _Tp& __val,
                           _Compare1 __comp1, _Compare2 __comp2, _Distance*) {
  _Distance __len = ::std::distance(__first, __last);
  _Distance __half;
  _ForwardIter __middle;

  while (__len > 0) {
    __half = __len >> 1;
    __middle = __first;
    ::std::advance(__middle, __half);
    if (__comp1(*__middle, __val)) {
     
      __first = __middle;
      ++__first;
      __len = __len - __half - 1;
    }
    else
      __len = __half;
  }
  return __first;
}

}

}
# 721 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_algobase.h" 2
# 34 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/vector" 2



# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_vector.h" 1
# 38 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_vector.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_alloc.h" 1
# 47 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_alloc.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_new.h" 1
# 47 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_new.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/../../gabi++/include/new" 1
# 33 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/../../gabi++/include/new"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/cstddef" 1
# 34 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/cstddef"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/../../gabi++/include/cstddef" 1
# 39 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/../../gabi++/include/cstddef"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stddef.h" 1
# 34 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stddef.h"
# 1 "/home/petya/download/android-ndk-r8b/toolchains/arm-linux-androideabi-4.4.3/prebuilt/linux-x86/bin/../lib/gcc/arm-linux-androideabi/4.4.3/include/../include/stddef.h" 1 3 4
# 35 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stddef.h" 2
# 40 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/../../gabi++/include/cstddef" 2

extern "C++" {

namespace std {
using ::ptrdiff_t;
using ::size_t;
}

}
# 35 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/cstddef" 2
# 34 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/../../gabi++/include/new" 2

namespace std
{
  struct nothrow_t {};
  extern const nothrow_t nothrow;
  typedef void (*new_handler)();
}


void* operator new(std::size_t size) throw( );
void* operator new(std::size_t size, const std::nothrow_t&) throw();
void* operator new[](std::size_t size) throw( );
void* operator new[](std::size_t size, const std::nothrow_t&) throw();

void operator delete[](void* ptr) throw();
void operator delete[](void* const, std::nothrow_t&) throw();
void operator delete(void* ptr) throw();
void operator delete(void*, const std::nothrow_t&) throw();

inline void* operator new(std::size_t, void* p) throw() { return p; }
inline void* operator new[](std::size_t, void* p) throw() { return p; }
inline void operator delete(void*, void*) throw() {}
inline void operator delete[](void*, void*) throw() {}
# 48 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_new.h" 2
# 114 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_new.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_cstdio.h" 1
# 52 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_cstdio.h"
namespace std {
using ::FILE;
using ::fpos_t;
using ::size_t;
# 66 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_cstdio.h"
using ::clearerr;
using ::fclose;
using ::feof;
using ::ferror;
using ::fflush;
using ::fgetc;
using ::fgetpos;
using ::fgets;
using ::fopen;
using ::fprintf;
using ::fputc;
using ::fputs;
using ::fread;

using ::freopen;

using ::fscanf;
using ::fseek;
using ::fsetpos;
using ::ftell;
using ::fwrite;



 using ::getc;
 using ::putc;

 using ::getchar;
 using ::putchar;


using ::gets;

using ::perror;

using ::printf;
using ::puts;

using ::remove;
using ::rename;
using ::rewind;
using ::setbuf;
using ::tmpfile;
using ::tmpnam;

using ::scanf;
using ::setvbuf;
using ::sprintf;
using ::sscanf;
using ::ungetc;
using ::vfprintf;
using ::vprintf;
using ::vsprintf;





}
# 115 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_new.h" 2
# 128 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_new.h"
namespace std {





inline void* __stl_new(size_t __n) { return ::operator new(__n); }
inline void __stl_delete(void* __p) { ::operator delete(__p); }

}
# 48 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_alloc.h" 2



# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_construct.h" 1
# 53 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_construct.h"
namespace std {

template <class _Tp>
inline void __destroy_aux(_Tp* __pointer, const __false_type& )
{ __pointer->~_Tp(); }

template <class _Tp>
inline void __destroy_aux(_Tp*, const __true_type& ) {}

template <class _Tp>
inline void _Destroy(_Tp* __pointer) {
  typedef typename __type_traits<_Tp>::has_trivial_destructor _Trivial_destructor;
  __destroy_aux(__pointer, _Trivial_destructor());



}

template <class _Tp>
inline void _Destroy_Moved(_Tp* __pointer) {

  typedef typename __move_traits<_Tp>::complete _Trivial_destructor;
  __destroy_aux(__pointer, _Trivial_destructor());






}






template <class _T1>
inline void _Construct_aux (_T1* __p, const __false_type&) {
  new(__p) _T1();
}

template <class _T1>
inline void _Construct_aux (_T1* __p, const __true_type&) {





  *__p = _T1();

}

template <class _T1>
inline void _Construct(_T1* __p) {






  _Construct_aux (__p, _Is_POD(__p)._Answer());

}

template <class _Tp>
inline void _Copy_Construct_aux(_Tp* __p, const _Tp& __val, const __false_type&) {
  new(__p) _Tp(__val);
}

template <class _Tp>
inline void _Copy_Construct_aux(_Tp* __p, const _Tp& __val, const __true_type&) {


  *__p = __val;
}

template <class _Tp>
inline void _Copy_Construct(_Tp* __p, const _Tp& __val) {



  _Copy_Construct_aux(__p, __val, _Is_POD(__p)._Answer());
}

template <class _T1, class _T2>
inline void _Param_Construct_aux(_T1* __p, const _T2& __val, const __false_type&) {
  new(__p) _T1(__val);
}

template <class _T1, class _T2>
inline void _Param_Construct_aux(_T1* __p, const _T2& __val, const __true_type&) {


  *__p = _T1(__val);
}

template <class _T1, class _T2>
inline void _Param_Construct(_T1* __p, const _T2& __val) {



  _Param_Construct_aux(__p, __val, _Is_POD(__p)._Answer());
}

template <class _T1, class _T2>
inline void _Move_Construct_Aux(_T1* __p, _T2& __val, const __false_type& ) {

  new(__p) _T1(::std::priv:: _AsMoveSource(__val));



}

template <class _T1, class _T2>
inline void _Move_Construct_Aux(_T1* __p, _T2& __val, const __true_type& ) {


  *__p = _T1(__val);
}

template <class _T1, class _T2>
inline void _Move_Construct(_T1* __p, _T2& __val) {



  _Move_Construct_Aux(__p, __val, _Is_POD(__p)._Answer());
}
# 188 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_construct.h"
template <class _ForwardIterator, class _Tp>
inline void
__destroy_range_aux(_ForwardIterator __first, _ForwardIterator __last, _Tp*, const __false_type& ) {
  for ( ; __first != __last; ++__first) {
    __destroy_aux(&(*__first), __false_type());



  }
}

template <class _ForwardIterator, class _Tp>







inline void
__destroy_range_aux(_ForwardIterator, _ForwardIterator, _Tp*, const __true_type& ) {}


template <class _ForwardIterator, class _Tp>
inline void
__destroy_range(_ForwardIterator __first, _ForwardIterator __last, _Tp *__ptr) {
  typedef typename __type_traits<_Tp>::has_trivial_destructor _Trivial_destructor;
  __destroy_range_aux(__first, __last, __ptr, _Trivial_destructor());
}

template <class _ForwardIterator>
inline void _Destroy_Range(_ForwardIterator __first, _ForwardIterator __last) {
  __destroy_range(__first, __last, (typename ::std::iterator_traits< _ForwardIterator >::value_type*)0);
}

inline void _Destroy_Range(char*, char*) {}

inline void _Destroy_Range(wchar_t*, wchar_t*) {}
inline void _Destroy_Range(const wchar_t*, const wchar_t*) {}



template <class _ForwardIterator, class _Tp>
inline void
__destroy_mv_srcs(_ForwardIterator __first, _ForwardIterator __last, _Tp *__ptr) {
  typedef typename __move_traits<_Tp>::complete _CompleteMove;
  __destroy_range_aux(__first, __last, __ptr, _CompleteMove());
}


template <class _ForwardIterator>
inline void _Destroy_Moved_Range(_ForwardIterator __first, _ForwardIterator __last)

{ __destroy_mv_srcs(__first, __last, (typename ::std::iterator_traits< _ForwardIterator >::value_type*)0); }
# 273 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_construct.h"
template <class _T1, class _T2>
inline void construct(_T1* __p, const _T2& __val) {_Param_Construct(__p, __val); }
template <class _T1>
inline void construct(_T1* __p) { ::std::_Construct(__p); }
template <class _Tp>
inline void destroy(_Tp* __pointer) { ::std::_Destroy(__pointer); }
template <class _ForwardIterator>
inline void destroy(_ForwardIterator __first, _ForwardIterator __last) { ::std::_Destroy_Range(__first, __last); }


}
# 52 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_alloc.h" 2


namespace std {





typedef void (* __oom_handler_type)();


class __attribute__((visibility("default"))) __malloc_alloc {
public:

  typedef char value_type;
  static void* allocate(size_t __n)

  ;
# 80 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_alloc.h"
  static void deallocate(void* __p, size_t ) { free((char*)__p); }

  static __oom_handler_type set_malloc_handler(__oom_handler_type __f);

};



class __attribute__((visibility("default"))) __new_alloc {
public:

  typedef char value_type;
  static void* allocate(size_t __n) { return __stl_new(__n); }
  static void deallocate(void* __p, size_t) { __stl_delete(__p); }
};
# 103 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_alloc.h"
template <class _Alloc>
class __debug_alloc : public _Alloc {
public:
  typedef _Alloc __allocator_type;
  typedef typename _Alloc::value_type value_type;
private:
  struct __alloc_header {
    size_t __magic: 16;
    size_t __type_size:16;
    unsigned long _M_size;
  };

  enum { __pad = 8, __magic = 0xdeba, __deleted_magic = 0xdebd,
         __shred_byte = 0xA3 };

  enum { __extra_before = 16, __extra_after = 8 };



  static size_t __extra_before_chunk() {
    return (long)__extra_before / sizeof(value_type) +
      (size_t)((long)__extra_before % sizeof(value_type) > 0);
  }
  static size_t __extra_after_chunk() {
    return (long)__extra_after / sizeof(value_type) +
      (size_t)((long)__extra_after % sizeof(value_type) > 0);
  }
public:
  __debug_alloc() {}
  ~__debug_alloc() {}
  static void* allocate(size_t);
  static void deallocate(void *, size_t);
};





enum { _MAX_BYTES = 32 * sizeof(void*) };






class __attribute__((visibility("default"))) __node_alloc {
  static void * _M_allocate(size_t& __n);

  static void _M_deallocate(void *__p, size_t __n);

public:

  typedef char value_type;

  static void* allocate(size_t& __n)
  { return (__n > (size_t)_MAX_BYTES) ? __stl_new(__n) : _M_allocate(__n); }

  static void deallocate(void *__p, size_t __n)
  { if (__n > (size_t)_MAX_BYTES) __stl_delete(__p); else _M_deallocate(__p, __n); }
};
# 196 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_alloc.h"
template <class _Tp, class _Allocator>
struct _Alloc_traits {
  typedef _Allocator _Orig;

  typedef typename _Allocator::template rebind<_Tp> _Rebind_type;
  typedef typename _Rebind_type::other allocator_type;
  static allocator_type create_allocator(const _Orig& __a)
  { return allocator_type(__a); }





};
# 224 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_alloc.h"
typedef __node_alloc __alloc_type;





typedef __alloc_type __sgi_alloc;



typedef __sgi_alloc __single_client_alloc;
typedef __sgi_alloc __multithreaded_alloc;
# 269 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_alloc.h"
template <class _Tp>
class allocator



                : public __stlport_class<allocator<_Tp> >
{
public:
  typedef _Tp value_type;
  typedef _Tp* pointer;
  typedef const _Tp* const_pointer;
  typedef _Tp& reference;
  typedef const _Tp& const_reference;
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;

  template <class _Tp1> struct rebind {
    typedef allocator<_Tp1> other;
  };

  allocator() {}

  template <class _Tp1> allocator(const allocator<_Tp1>&) {}

  allocator(const allocator<_Tp>&) {}

  allocator(__move_source<allocator<_Tp> > src) {}

  ~allocator() {}
  pointer address(reference __x) const {return &__x;}
  const_pointer address(const_reference __x) const { return &__x; }

  _Tp* allocate(size_type __n, const void* = 0) {
    if (__n > max_size()) {
      puts("out of memory\n"); exit(1);
    }
    if (__n != 0) {
      size_type __buf_size = __n * sizeof(value_type);
      _Tp* __ret = reinterpret_cast<_Tp*>(__sgi_alloc::allocate(__buf_size));



      return __ret;
    }

    return 0;
  }

  void deallocate(pointer __p, size_type __n) {
   
    if (__p != 0) {



      __sgi_alloc::deallocate((void*)__p, __n * sizeof(value_type));
    }
  }


  void deallocate(pointer __p) const { if (__p != 0) __sgi_alloc::deallocate((void*)__p, sizeof(value_type)); }

  size_type max_size() const { return size_t(-1) / sizeof(value_type); }
  void construct(pointer __p, const_reference __val) { ::std::_Copy_Construct(__p, __val); }
  void destroy(pointer __p) { ::std::_Destroy(__p); }
# 341 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_alloc.h"
  _Tp* _M_allocate(size_type __n, size_type& __allocated_n) {
    if (__n > max_size()) {
      puts("out of memory\n"); exit(1);
    }

    if (__n != 0) {
      size_type __buf_size = __n * sizeof(value_type);
      _Tp* __ret = reinterpret_cast<_Tp*>(__sgi_alloc::allocate(__buf_size));



      __allocated_n = __buf_size / sizeof(value_type);
      return __ret;
    }

    return 0;
  }



};

template<>
class __attribute__((visibility("default"))) allocator<void> {
public:
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef void* pointer;
  typedef const void* const_pointer;

  typedef void value_type;


  template <class _Tp1> struct rebind {
    typedef allocator<_Tp1> other;
  };

};

template <class _T1, class _T2>
inline bool operator==(const allocator<_T1>&, const allocator<_T2>&)
{ return true; }
template <class _T1, class _T2>
inline bool operator!=(const allocator<_T1>&, const allocator<_T2>&)
{ return false; }
# 397 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_alloc.h"
namespace priv {

template <class _Tp>
struct __alloc_type_traits {

  typedef typename _IsSTLportClass<allocator<_Tp> >::_Ret _STLportAlloc;






  typedef _STLportAlloc has_trivial_default_constructor;
  typedef _STLportAlloc has_trivial_copy_constructor;
  typedef _STLportAlloc has_trivial_assignment_operator;
  typedef _STLportAlloc has_trivial_destructor;
  typedef _STLportAlloc is_POD_type;
};

}


template <class _Tp>
struct __type_traits<allocator<_Tp> > : ::std::priv:: __alloc_type_traits<_Tp> {};
# 451 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_alloc.h"
template <class _Tp, class _Alloc>
inline typename _Alloc_traits<_Tp, _Alloc>::allocator_type
__stl_alloc_create(const _Alloc& __a, const _Tp*) {
  typedef typename _Alloc::template rebind<_Tp>::other _Rebound_type;
  return _Rebound_type(__a);
}
# 468 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_alloc.h"
namespace priv {


template <class _Value, class _Tp, class _MaybeReboundAlloc>
class _STLP_alloc_proxy : public _MaybeReboundAlloc {
private:
  typedef _MaybeReboundAlloc _Base;
  typedef typename _Base::size_type size_type;
  typedef _STLP_alloc_proxy<_Value, _Tp, _MaybeReboundAlloc> _Self;
public:
  _Value _M_data;

  _STLP_alloc_proxy (const _MaybeReboundAlloc& __a, _Value __p) :
    _MaybeReboundAlloc(__a), _M_data(__p) {}


  _STLP_alloc_proxy (__move_source<_Self> src) :
    _Base(::std::priv:: _AsMoveSource(src.get()._M_base())),
    _M_data(::std::priv:: _AsMoveSource(src.get()._M_data)) {}

  _Base& _M_base()
  { return *this; }


private:




  void _M_swap_alloc(_Self&, const __true_type& )
  {}

  void _M_swap_alloc(_Self& __x, const __false_type& ) {
    _MaybeReboundAlloc &__base_this = *this;
    _MaybeReboundAlloc &__base_x = __x;
    ::std::swap(__base_this, __base_x);
  }

public:
  void _M_swap_alloc(_Self& __x) {

    typedef typename _IsStateless<_MaybeReboundAlloc>::_Ret _StatelessAlloc;



    _M_swap_alloc(__x, _StatelessAlloc());
  }





  void swap(_Self& __x) {
    _M_swap_alloc(__x);
    ::std::swap(_M_data, __x._M_data);
  }

  _Tp* allocate(size_type __n, size_type& __allocated_n) {

    typedef typename _IsSTLportClass<_MaybeReboundAlloc>::_Ret _STLportAlloc;



    return allocate(__n, __allocated_n, _STLportAlloc());
  }
# 547 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_alloc.h"
  _Tp* allocate(size_type __n)
  { return _Base::allocate(__n); }
private:
  _Tp* allocate(size_type __n, size_type& __allocated_n, const __true_type& )
  { return _Base::_M_allocate(__n, __allocated_n); }


  _Tp* allocate(size_type __n, size_type& __allocated_n, const __false_type& )
  { __allocated_n = __n; return allocate(__n); }
};
# 568 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_alloc.h"
}
}


# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_alloc.c" 1
# 35 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_alloc.c"
namespace std {

template <class _Alloc>
void * __debug_alloc<_Alloc>::allocate(size_t __n) {
  size_t __total_extra = __extra_before_chunk() + __extra_after_chunk();
  size_t __real_n = __n + __total_extra;
  if (__real_n < __n) {

    puts("out of memory\n"); exit(1);
  }
  __alloc_header *__result = (__alloc_header *)__allocator_type::allocate(__real_n);
  memset((char*)__result, __shred_byte, __real_n * sizeof(value_type));
  __result->__magic = __magic;
  __result->__type_size = sizeof(value_type);
  __result->_M_size = (unsigned long)__n;
  return ((char*)__result) + (long)__extra_before;
}

template <class _Alloc>
void
__debug_alloc<_Alloc>::deallocate(void *__p, size_t __n) {
  __alloc_header * __real_p = (__alloc_header*)((char *)__p -(long)__extra_before);

 
 
 
 

  unsigned char* __tmp;
  for (__tmp = (unsigned char*)(__real_p + 1); __tmp < (unsigned char*)__p; ++__tmp) {
   
  }

  size_t __real_n = __n + __extra_before_chunk() + __extra_after_chunk();

  for (__tmp= ((unsigned char*)__p) + __n * sizeof(value_type);
       __tmp < ((unsigned char*)__real_p) + __real_n ; ++__tmp) {
   
  }


  __real_p->__magic = __deleted_magic;
  memset((char*)__p, __shred_byte, __n * sizeof(value_type));
  __allocator_type::deallocate(__real_p, __real_n);
}

}
# 573 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_alloc.h" 2
# 39 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_vector.h" 2







# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_uninitialized.h" 1
# 45 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_uninitialized.h"
namespace std {

namespace priv {



template <class _InputIter, class _OutputIter, class _Distance>
inline _OutputIter __ucopy(_InputIter __first, _InputIter __last,
                           _OutputIter __result, _Distance*) {
  _OutputIter __cur = __result;
  {
    for ( ; __first != __last; ++__first, ++__cur)
      _Param_Construct(&*__cur, *__first);
    return __cur;
  }
 
 
}

template <class _InputIter, class _OutputIter, class _Distance>
inline _OutputIter __ucopy(_InputIter __first, _InputIter __last,
                           _OutputIter __result, const input_iterator_tag &, _Distance* __d)
{ return __ucopy(__first, __last, __result, __d); }
# 81 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_uninitialized.h"
template <class _RandomAccessIter, class _OutputIter, class _Distance>
inline _OutputIter __ucopy(_RandomAccessIter __first, _RandomAccessIter __last,
                           _OutputIter __result, const random_access_iterator_tag &, _Distance*) {
  _OutputIter __cur = __result;
  {
    for (_Distance __n = __last - __first; __n > 0; --__n) {
      _Param_Construct(&*__cur, *__first);
      ++__first;
      ++__cur;
    }
    return __cur;
  }
 
 
}


template <class _RandomAccessIter, class _OutputIter>
inline _OutputIter __ucopy(_RandomAccessIter __first, _RandomAccessIter __last, _OutputIter __result)
{ return __ucopy(__first, __last, __result, random_access_iterator_tag(), (ptrdiff_t*)0); }

inline void*
__ucopy_trivial(const void* __first, const void* __last, void* __result) {

  return (__last == __first) ? __result :
    ((char*)memcpy(__result, __first, ((const char*)__last - (const char*)__first))) +
    ((const char*)__last - (const char*)__first);
}

template <class _InputIter, class _OutputIter>
inline _OutputIter __ucopy_ptrs(_InputIter __first, _InputIter __last, _OutputIter __result,
                                const __false_type& )
{ return __ucopy(__first, __last, __result, random_access_iterator_tag(), (ptrdiff_t*)0); }

template <class _InputIter, class _OutputIter>
inline _OutputIter __ucopy_ptrs(_InputIter __first, _InputIter __last, _OutputIter __result,
                                const __true_type& ) {


  return (_OutputIter)__ucopy_trivial(__first, __last, __result);
}

template <class _InputIter, class _OutputIter>
inline _OutputIter __ucopy_aux(_InputIter __first, _InputIter __last, _OutputIter __result,
                               const __true_type& ) {
  return __ucopy_ptrs(__first, __last, __result,
                      _UseTrivialUCopy((typename ::std::iterator_traits< _InputIter >::value_type*)0,
                                       (typename ::std::iterator_traits< _OutputIter >::value_type*)0)._Answer());
}

template <class _InputIter, class _OutputIter>
inline _OutputIter __ucopy_aux(_InputIter __first, _InputIter __last, _OutputIter __result,
                               const __false_type& ) {
  return __ucopy(__first, __last, __result,
                 typename ::std::iterator_traits< _InputIter >::iterator_category(),
                 (typename ::std::iterator_traits< _InputIter >::difference_type*)0);
}

}

template <class _InputIter, class _ForwardIter>
inline _ForwardIter
uninitialized_copy(_InputIter __first, _InputIter __last, _ForwardIter __result)
{ return ::std::priv:: __ucopy_aux(__first, __last, __result, _BothPtrType< _InputIter, _ForwardIter>::_Answer()); }

inline char*
uninitialized_copy(const char* __first, const char* __last, char* __result)
{ return (char*)::std::priv:: __ucopy_trivial(__first, __last, __result); }


inline wchar_t*
uninitialized_copy(const wchar_t* __first, const wchar_t* __last, wchar_t* __result)
{ return (wchar_t*)::std::priv:: __ucopy_trivial (__first, __last, __result); }



namespace priv {

template <class _InputIter, class _Size, class _ForwardIter>
inline
pair<_InputIter, _ForwardIter>
__ucopy_n(_InputIter __first, _Size __count, _ForwardIter __result,
          const input_iterator_tag &) {
  _ForwardIter __cur = __result;
  {
    for ( ; __count > 0 ; --__count, ++__first, ++__cur)
      _Param_Construct(&*__cur, *__first);
    return pair<_InputIter, _ForwardIter>(__first, __cur);
  }
 
 
}
# 190 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_uninitialized.h"
template <class _RandomAccessIter, class _Size, class _ForwardIter>
inline pair<_RandomAccessIter, _ForwardIter>
__ucopy_n(_RandomAccessIter __first, _Size __count, _ForwardIter __result,
                       const random_access_iterator_tag &) {
  _RandomAccessIter __last = __first + __count;
  return pair<_RandomAccessIter, _ForwardIter>(__last, uninitialized_copy(__first, __last, __result));
}


template <class _InputIter, class _Size, class _ForwardIter>
inline pair<_InputIter, _ForwardIter>
__ucopy_n(_InputIter __first, _Size __count, _ForwardIter __result)
{ return ::std::priv:: __ucopy_n(__first, __count, __result, typename ::std::iterator_traits< _InputIter >::iterator_category()); }



}

template <class _InputIter, class _Size, class _ForwardIter>
inline pair<_InputIter, _ForwardIter>
uninitialized_copy_n(_InputIter __first, _Size __count, _ForwardIter __result)
{ return ::std::priv:: __ucopy_n(__first, __count, __result); }

namespace priv {



template <class _ForwardIter, class _Tp, class _Distance>
inline void __ufill(_ForwardIter __first, _ForwardIter __last, const _Tp& __x, _Distance*) {
  _ForwardIter __cur = __first;
  {
    for ( ; __cur != __last; ++__cur)
      _Param_Construct(&*__cur, __x);
  }
 
}

template <class _ForwardIter, class _Tp, class _Distance>
inline void __ufill(_ForwardIter __first, _ForwardIter __last,
                    const _Tp& __x, const input_iterator_tag &, _Distance* __d)
{ __ufill(__first, __last, __x, __d); }
# 244 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_uninitialized.h"
template <class _ForwardIter, class _Tp, class _Distance>
inline void __ufill(_ForwardIter __first, _ForwardIter __last,
                    const _Tp& __x, const random_access_iterator_tag &, _Distance*) {
  _ForwardIter __cur = __first;
  {
    for (_Distance __n = __last - __first; __n > 0; --__n, ++__cur)
      _Param_Construct(&*__cur, __x);
  }
 
}

}

template <class _ForwardIter, class _Tp>
inline void uninitialized_fill(_ForwardIter __first, _ForwardIter __last, const _Tp& __x) {
  ::std::priv:: __ufill(__first, __last, __x,
                     typename ::std::iterator_traits< _ForwardIter >::iterator_category(),
                     (typename ::std::iterator_traits< _ForwardIter >::difference_type*)0);
}


inline void uninitialized_fill(unsigned char* __first, unsigned char* __last,
                               const unsigned char& __val) {
  unsigned char __tmp = __val;
  memset(__first, __tmp, __last - __first);
}

inline void uninitialized_fill(signed char* __first, signed char* __last,
                               const signed char& __val) {
  signed char __tmp = __val;
  memset(__first, static_cast<unsigned char>(__tmp), __last - __first);
}

inline void uninitialized_fill(char* __first, char* __last, const char& __val) {
  char __tmp = __val;
  memset(__first, static_cast<unsigned char>(__tmp), __last - __first);
}

namespace priv {

template <class _ForwardIter, class _Size, class _Tp>
inline _ForwardIter __ufill_n(_ForwardIter __first, _Size __n, const _Tp& __x) {
  _ForwardIter __cur = __first;
  {
    for ( ; __n > 0; --__n, ++__cur)
      _Param_Construct(&*__cur, __x);
  }
 
  return __cur;
}

template <class _ForwardIter, class _Size, class _Tp>
inline _ForwardIter __ufill_n(_ForwardIter __first, _Size __n, const _Tp& __x,
                              const input_iterator_tag &)
{ return __ufill_n(__first, __n, __x); }
# 312 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_uninitialized.h"
template <class _ForwardIter, class _Size, class _Tp>
inline _ForwardIter __uninitialized_fill_n(_ForwardIter __first, _Size __n, const _Tp& __x) {
  _ForwardIter __last = __first + __n;
  __ufill(__first, __last, __x, random_access_iterator_tag(), (ptrdiff_t*)0);
  return __last;
}

template <class _ForwardIter, class _Size, class _Tp>
inline _ForwardIter __ufill_n(_ForwardIter __first, _Size __n, const _Tp& __x,
                              const random_access_iterator_tag &)
{ return __uninitialized_fill_n(__first, __n, __x); }





template <class _ForwardIter, class _Size, class _Tp>
inline _ForwardIter __uinit_aux_aux(_ForwardIter __first, _Size __n, const _Tp& __val,
                                    const __false_type& )
{ return __uninitialized_fill_n(__first, __n, __val); }

template <class _ForwardIter, class _Size, class _Tp>
inline _ForwardIter __uinit_aux_aux(_ForwardIter __first, _Size __n, const _Tp& ,
                                    const __true_type& ) {
  memset((unsigned char*)__first, 0, __n * sizeof(_Tp));
  return __first + __n;
}

template <class _ForwardIter, class _Size, class _Tp>
inline _ForwardIter __uinit_aux(_ForwardIter __first, _Size __n, const _Tp&,
                                const __true_type& )
{ return __first + __n; }

template <class _ForwardIter, class _Size, class _Tp>
inline _ForwardIter __uinit_aux(_ForwardIter __first, _Size __n, const _Tp& __val,
                                const __false_type& )
{ return __uinit_aux_aux(__first, __n, __val, _HasDefaultZeroValue(__first)._Answer()); }

template <class _ForwardIter, class _Size, class _Tp>
inline _ForwardIter __uninitialized_init(_ForwardIter __first, _Size __n, const _Tp& __val)
{ return __uinit_aux(__first, __n, __val, _UseTrivialInit(__first)._Answer()); }

}

template <class _ForwardIter, class _Size, class _Tp>
inline void
uninitialized_fill_n(_ForwardIter __first, _Size __n, const _Tp& __x)
{ ::std::priv:: __ufill_n(__first, __n, __x, typename ::std::iterator_traits< _ForwardIter >::iterator_category()); }
# 369 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_uninitialized.h"
namespace priv {

template <class _InputIter1, class _InputIter2, class _ForwardIter>
inline _ForwardIter
__uninitialized_copy_copy(_InputIter1 __first1, _InputIter1 __last1,
                          _InputIter2 __first2, _InputIter2 __last2,
                          _ForwardIter __result) {
  _ForwardIter __new_result = uninitialized_copy(__first1, __last1, __result);
  {
    return uninitialized_copy(__first2, __last2, __new_result);
  }
 
 
}




template <class _ForwardIter, class _Tp, class _InputIter>
inline _ForwardIter
__uninitialized_fill_copy(_ForwardIter __result, _ForwardIter __mid, const _Tp& __x,
                          _InputIter __first, _InputIter __last) {
  uninitialized_fill(__result, __mid, __x);
  {
    return uninitialized_copy(__first, __last, __mid);
  }
 
 
}




template <class _Iter, class _Tp>
inline void
__uninitialized_copy_fill(_Iter __first1, _Iter __last1, _Iter __first2, _Iter __last2,
                          const _Tp& __x) {
  _Iter __mid2 = uninitialized_copy(__first1, __last1, __first2);
  {
    uninitialized_fill(__mid2, __last2, __x);
  }
 
}




template <class _InputIter, class _ForwardIter, class _TrivialUCpy>
inline _ForwardIter
__uninitialized_move(_InputIter __first, _InputIter __last, _ForwardIter __result,
                     _TrivialUCpy __trivial_ucpy, const __false_type& )
{ return __ucopy_ptrs(__first, __last, __result, __trivial_ucpy); }

template <class _InputIter, class _ForwardIter, class _TrivialUCpy>
inline
_ForwardIter
__uninitialized_move(_InputIter __first, _InputIter __last, _ForwardIter __result,
                     _TrivialUCpy , const __true_type& ) {

  for (ptrdiff_t __n = __last - __first ; __n > 0; --__n) {
    _Move_Construct(&*__result, *__first);
    ++__first; ++__result;
  }
  return __result;
}

}

}
# 47 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_vector.h" 2


namespace std {





namespace priv {

template <class _Tp, class _Alloc>
class _Vector_base {
public:
  typedef _Vector_base<_Tp, _Alloc> _Self;
 
  typedef _Alloc allocator_type;
  typedef _Tp* pointer;
  typedef _STLP_alloc_proxy<pointer, _Tp, allocator_type> _AllocProxy;

  _Vector_base(const _Alloc& __a)
    : _M_start(0), _M_finish(0), _M_end_of_storage(__a, 0) {}

  _Vector_base(size_t __n, const _Alloc& __a)
    : _M_start(0), _M_finish(0), _M_end_of_storage(__a, 0) {
    _M_start = _M_end_of_storage.allocate(__n, __n);
    _M_finish = _M_start;
    _M_end_of_storage._M_data = _M_start + __n;
   
  }


  _Vector_base(__move_source<_Self> src)
    : _M_start(src.get()._M_start), _M_finish(src.get()._M_finish),
      _M_end_of_storage(__move_source<_AllocProxy>(src.get()._M_end_of_storage)) {

    src.get()._M_finish = src.get()._M_end_of_storage._M_data = src.get()._M_start = 0;
  }


  ~_Vector_base() {
    if (_M_start != pointer())
      _M_end_of_storage.deallocate(_M_start, _M_end_of_storage._M_data - _M_start);
  }

protected:
  void _M_throw_length_error() const;
  void _M_throw_out_of_range() const;

  pointer _M_start;
  pointer _M_finish;
  _AllocProxy _M_end_of_storage;
};






}


template <class _Tp, class _Alloc = allocator<_Tp> >
class vector : protected ::std::priv:: _Vector_base<_Tp, _Alloc>



{
private:
  typedef ::std::priv:: _Vector_base<_Tp, _Alloc> _Base;
  typedef vector<_Tp, _Alloc> _Self;
public:
 
  typedef typename _Base::allocator_type allocator_type;

  typedef _Tp value_type;
  typedef value_type* pointer;
  typedef const value_type* const_pointer;
  typedef value_type* iterator;
  typedef const value_type* const_iterator;

  typedef value_type& reference;
  typedef const value_type& const_reference;
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef random_access_iterator_tag _Iterator_category;

  typedef ::std::reverse_iterator<const_iterator> const_reverse_iterator; typedef ::std::reverse_iterator<iterator> reverse_iterator;

  allocator_type get_allocator() const
  { return (const allocator_type&)this->_M_end_of_storage; }

private:





  void _M_insert_overflow_aux(pointer __pos, const _Tp& __x, const __false_type& ,
                              size_type __fill_len, bool __atend);
  void _M_insert_overflow_aux(pointer __pos, const _Tp& __x, const __true_type& ,
                              size_type __fill_len, bool __atend) {

    if (_M_is_inside(__x)) {
      value_type __x_copy = __x;
      _M_insert_overflow_aux(__pos, __x_copy, __false_type(), __fill_len, __atend);
      return;
    }
    _M_insert_overflow_aux(__pos, __x, __false_type(), __fill_len, __atend);
  }

  void _M_insert_overflow(pointer __pos, const _Tp& __x, const __false_type& ,
                          size_type __fill_len, bool __atend = false) {

    typedef typename __move_traits<_Tp>::implemented _Movable;

    _M_insert_overflow_aux(__pos, __x, _Movable(), __fill_len, __atend);
  }
  void _M_insert_overflow(pointer __pos, const _Tp& __x, const __true_type& ,
                          size_type __fill_len, bool __atend = false);
  void _M_range_check(size_type __n) const {
    if (__n >= size_type(this->_M_finish - this->_M_start))
      this->_M_throw_out_of_range();
  }

  size_type _M_compute_next_size(size_type __n) {
    const size_type __size = size();
    if (__n > max_size() - __size)
      this->_M_throw_length_error();
    size_type __len = __size + (max)(__n, __size);
    if (__len > max_size() || __len < __size)
      __len = max_size();
    return __len;
  }

public:
  iterator begin() { return this->_M_start; }
  const_iterator begin() const { return this->_M_start; }
  iterator end() { return this->_M_finish; }
  const_iterator end() const { return this->_M_finish; }

  reverse_iterator rbegin() { return reverse_iterator(end()); }
  const_reverse_iterator rbegin() const { return const_reverse_iterator(end()); }
  reverse_iterator rend() { return reverse_iterator(begin()); }
  const_reverse_iterator rend() const { return const_reverse_iterator(begin()); }

  size_type size() const { return size_type(this->_M_finish - this->_M_start); }
  size_type max_size() const {
    size_type __vector_max_size = size_type(-1) / sizeof(_Tp);
    typename allocator_type::size_type __alloc_max_size = this->_M_end_of_storage.max_size();
    return (__alloc_max_size < __vector_max_size)?__alloc_max_size:__vector_max_size;
  }

  size_type capacity() const { return size_type(this->_M_end_of_storage._M_data - this->_M_start); }
  bool empty() const { return this->_M_start == this->_M_finish; }

  reference operator[](size_type __n) { return *(begin() + __n); }
  const_reference operator[](size_type __n) const { return *(begin() + __n); }

  reference front() { return *begin(); }
  const_reference front() const { return *begin(); }
  reference back() { return *(end() - 1); }
  const_reference back() const { return *(end() - 1); }

  reference at(size_type __n) { _M_range_check(__n); return (*this)[__n]; }
  const_reference at(size_type __n) const { _M_range_check(__n); return (*this)[__n]; }


  explicit vector(const allocator_type& __a = allocator_type())





    : ::std::priv:: _Vector_base<_Tp, _Alloc>(__a) {}


private:



  void _M_initialize(size_type __n, const _Tp& __val = _Tp())
  { this->_M_finish = ::std::priv:: __uninitialized_init(this->_M_start, __n, __val); }
public:
  explicit vector(size_type __n)
    : ::std::priv:: _Vector_base<_Tp, _Alloc>(__n, allocator_type())
  { _M_initialize(__n); }
  vector(size_type __n, const _Tp& __val, const allocator_type& __a = allocator_type())
# 243 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_vector.h"
    : ::std::priv:: _Vector_base<_Tp, _Alloc>(__n, __a)
  { this->_M_finish = ::std::priv:: __uninitialized_fill_n(this->_M_start, __n, __val); }

  vector(const _Self& __x)
    : ::std::priv:: _Vector_base<_Tp, _Alloc>(__x.size(), __x.get_allocator()) {
    typedef typename __type_traits<_Tp>::has_trivial_copy_constructor _TrivialUCopy;
    this->_M_finish = ::std::priv:: __ucopy_ptrs(__x.begin(), __x.end(), this->_M_start, _TrivialUCopy());
  }


  vector(__move_source<_Self> src)
    : ::std::priv:: _Vector_base<_Tp, _Alloc>(__move_source<_Base>(src.get()))
  {}



private:
  template <class _Integer>
  void _M_initialize_aux(_Integer __n, _Integer __val,
                         const __true_type& ) {
    size_type __real_n = __n;
    this->_M_start = this->_M_end_of_storage.allocate(__n, __real_n);
    this->_M_end_of_storage._M_data = this->_M_start + __real_n;
    this->_M_finish = ::std::priv:: __uninitialized_fill_n(this->_M_start, __n, __val);
  }

  template <class _InputIterator>
  void _M_initialize_aux(_InputIterator __first, _InputIterator __last,
                         const __false_type& )
  { _M_range_initialize(__first, __last, typename ::std::iterator_traits< _InputIterator >::iterator_category()); }

public:

  template <class _InputIterator>
  vector(_InputIterator __first, _InputIterator __last,
               const allocator_type& __a = allocator_type() )
    : ::std::priv:: _Vector_base<_Tp, _Alloc>(__a) {
    typedef typename _IsIntegral<_InputIterator>::_Ret _Integral;
    _M_initialize_aux(__first, __last, _Integral());
  }
# 304 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_vector.h"
  ~vector() { ::std::_Destroy_Range(rbegin(), rend()); }

  _Self& operator=(const _Self& __x);

  void reserve(size_type __n);






  void assign(size_type __n, const _Tp& __val) { _M_fill_assign(__n, __val); }
  void _M_fill_assign(size_type __n, const _Tp& __val);


  template <class _ForwardIter>
  void _M_assign_aux(_ForwardIter __first, _ForwardIter __last, const forward_iterator_tag &) {




    const size_type __len = ::std::distance(__first, __last);
    if (__len > capacity()) {
      size_type __n = __len;
      iterator __tmp = _M_allocate_and_copy(__n, __first, __last);
      _M_clear();
      _M_set(__tmp, __tmp + __len, __tmp + __n);
    }
    else if (size() >= __len) {
      iterator __new_finish = copy(__first, __last, this->_M_start);
      ::std::_Destroy_Range(__new_finish, this->_M_finish);
      this->_M_finish = __new_finish;
    }
    else {
      _ForwardIter __mid = __first;
      ::std::advance(__mid, size());
      ::std::copy(__first, __mid, this->_M_start);
      this->_M_finish = ::std::uninitialized_copy(__mid, __last, this->_M_finish);
    }
  }


  template <class _InputIter>
  void _M_assign_aux(_InputIter __first, _InputIter __last,
                     const input_iterator_tag &) {
    iterator __cur = begin();
    for ( ; __first != __last && __cur != end(); ++__cur, ++__first)
      *__cur = *__first;
    if (__first == __last)
      erase(__cur, end());
    else
      insert(end(), __first, __last);
  }

  template <class _Integer>
  void _M_assign_dispatch(_Integer __n, _Integer __val,
                          const __true_type& )
  { _M_fill_assign(__n, __val); }

  template <class _InputIter>
  void _M_assign_dispatch(_InputIter __first, _InputIter __last,
                          const __false_type& )
  { _M_assign_aux(__first, __last, typename ::std::iterator_traits< _InputIter >::iterator_category()); }

  template <class _InputIterator>
  void assign(_InputIterator __first, _InputIterator __last) {
    typedef typename _IsIntegral<_InputIterator>::_Ret _Integral;
    _M_assign_dispatch(__first, __last, _Integral());
  }



  void push_back(const _Tp& __x = _Tp()) {



    if (this->_M_finish != this->_M_end_of_storage._M_data) {
      _Copy_Construct(this->_M_finish, __x);
      ++this->_M_finish;
    }
    else {
      typedef typename __type_traits<_Tp>::has_trivial_assignment_operator _TrivialCopy;
      _M_insert_overflow(this->_M_finish, __x, _TrivialCopy(), 1, true);
    }
  }


  iterator insert(iterator __pos, const _Tp& __x = _Tp());
# 401 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_vector.h"
  void swap(_Self& __x) {
    ::std::swap(this->_M_start, __x._M_start);
    ::std::swap(this->_M_finish, __x._M_finish);
    this->_M_end_of_storage.swap(__x._M_end_of_storage);
  }




private:
  void _M_fill_insert_aux (iterator __pos, size_type __n, const _Tp& __x, const __true_type& );
  void _M_fill_insert_aux (iterator __pos, size_type __n, const _Tp& __x, const __false_type& );
  void _M_fill_insert (iterator __pos, size_type __n, const _Tp& __x);

  bool _M_is_inside(const value_type& __x) const {
    return (&__x >= this->_M_start && &__x < this->_M_finish);
  }


  template <class _ForwardIterator>
  void _M_range_insert_realloc(iterator __pos,
                               _ForwardIterator __first, _ForwardIterator __last,




                               size_type __n) {
    typedef typename __type_traits<_Tp>::has_trivial_copy_constructor _TrivialUCopy;

    typedef typename __move_traits<_Tp>::implemented _Movable;

    size_type __len = _M_compute_next_size(__n);
    pointer __new_start = this->_M_end_of_storage.allocate(__len, __len);
    pointer __new_finish = __new_start;
    {
      __new_finish = ::std::priv:: __uninitialized_move(this->_M_start, __pos, __new_start, _TrivialUCopy(), _Movable());
      __new_finish = uninitialized_copy(__first, __last, __new_finish);
      __new_finish = ::std::priv:: __uninitialized_move(__pos, this->_M_finish, __new_finish, _TrivialUCopy(), _Movable());
    }
   

    _M_clear_after_move();
    _M_set(__new_start, __new_finish, __new_start + __len);
  }


  template <class _ForwardIterator>
  void _M_range_insert_aux(iterator __pos,
                           _ForwardIterator __first, _ForwardIterator __last,




                           size_type __n, const __true_type& ) {
    iterator __src = this->_M_finish - 1;
    iterator __dst = __src + __n;
    for (; __src >= __pos; --__dst, --__src) {
      ::std::_Move_Construct(__dst, *__src);
      ::std::_Destroy_Moved(__src);
    }
    uninitialized_copy(__first, __last, __pos);
    this->_M_finish += __n;
  }


  template <class _ForwardIterator>
  void _M_range_insert_aux(iterator __pos,
                           _ForwardIterator __first, _ForwardIterator __last,




                           size_type __n, const __false_type& ) {
    typedef typename __type_traits<_Tp>::has_trivial_copy_constructor _TrivialUCopy;
    typedef typename __type_traits<_Tp>::has_trivial_assignment_operator _TrivialCopy;
    const size_type __elems_after = this->_M_finish - __pos;
    pointer __old_finish = this->_M_finish;
    if (__elems_after > __n) {
      ::std::priv:: __ucopy_ptrs(this->_M_finish - __n, this->_M_finish, this->_M_finish, _TrivialUCopy());
      this->_M_finish += __n;
      ::std::priv:: __copy_backward_ptrs(__pos, __old_finish - __n, __old_finish, _TrivialCopy());
      copy(__first, __last, __pos);
    }
    else {

      _ForwardIterator __mid = __first;
      ::std::advance(__mid, __elems_after);



      uninitialized_copy(__mid, __last, this->_M_finish);
      this->_M_finish += __n - __elems_after;
      ::std::priv:: __ucopy_ptrs(__pos, __old_finish, this->_M_finish, _TrivialUCopy());
      this->_M_finish += __elems_after;
      copy(__first, __mid, __pos);
    }
  }



  template <class _Integer>
  void _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val,
                          const __true_type&)
  { _M_fill_insert(__pos, (size_type) __n, (_Tp) __val); }

  template <class _InputIterator>
  void _M_insert_dispatch(iterator __pos,
                          _InputIterator __first, _InputIterator __last,
                          const __false_type&)
  { _M_range_insert(__pos, __first, __last, typename ::std::iterator_traits< _InputIterator >::iterator_category()); }

public:

  template <class _InputIterator>
  void insert(iterator __pos, _InputIterator __first, _InputIterator __last) {
    typedef typename _IsIntegral<_InputIterator>::_Ret _Integral;
    _M_insert_dispatch(__pos, __first, __last, _Integral());
  }

private:
  template <class _InputIterator>
  void _M_range_insert(iterator __pos,
                       _InputIterator __first, _InputIterator __last,
                       const input_iterator_tag &) {
    for ( ; __first != __last; ++__first) {
      __pos = insert(__pos, *__first);
      ++__pos;
    }
  }

  template <class _ForwardIterator>
  void _M_range_insert(iterator __pos,
                       _ForwardIterator __first, _ForwardIterator __last,
                       const forward_iterator_tag &) {






    typedef typename __move_traits<_Tp>::implemented _Movable;




    if (__first != __last) {
      size_type __n = ::std::distance(__first, __last);

      if (size_type(this->_M_end_of_storage._M_data - this->_M_finish) >= __n) {
        _M_range_insert_aux(__pos, __first, __last, __n, _Movable());
      }
      else {
        _M_range_insert_realloc(__pos, __first, __last, __n);
      }
    }
  }

public:
  void insert (iterator __pos, size_type __n, const _Tp& __x)
  { _M_fill_insert(__pos, __n, __x); }

  void pop_back() {
    --this->_M_finish;
    ::std::_Destroy(this->_M_finish);
  }

private:
  iterator _M_erase(iterator __pos, const __true_type& ) {
    ::std::_Destroy(__pos);
    iterator __dst = __pos, __src = __dst + 1;
    iterator __end = end();
    for (; __src != __end; ++__dst, ++__src) {
      ::std::_Move_Construct(__dst, *__src);
      ::std::_Destroy_Moved(__src);
    }
    this->_M_finish = __dst;
    return __pos;
  }
  iterator _M_erase(iterator __pos, const __false_type& ) {
    if (__pos + 1 != end()) {
      typedef typename __type_traits<_Tp>::has_trivial_assignment_operator _TrivialCopy;
      ::std::priv:: __copy_ptrs(__pos + 1, this->_M_finish, __pos, _TrivialCopy());
    }
    --this->_M_finish;
    ::std::_Destroy(this->_M_finish);
    return __pos;
  }
  iterator _M_erase(iterator __first, iterator __last, const __true_type& ) {
    iterator __dst = __first, __src = __last;
    iterator __end = end();
    for (; __dst != __last && __src != __end; ++__dst, ++__src) {
      ::std::_Destroy(__dst);
      ::std::_Move_Construct(__dst, *__src);
    }
    if (__dst != __last) {

      ::std::_Destroy_Range(__dst, __last);
      ::std::_Destroy_Moved_Range(__last, __end);
    }
    else {

      for (; __src != __end; ++__dst, ++__src) {
        ::std::_Destroy_Moved(__dst);
        ::std::_Move_Construct(__dst, *__src);
      }
      ::std::_Destroy_Moved_Range(__dst, __end);
    }
    this->_M_finish = __dst;
    return __first;
  }
  iterator _M_erase(iterator __first, iterator __last, const __false_type& ) {
    typedef typename __type_traits<_Tp>::has_trivial_assignment_operator _TrivialCopy;
    pointer __i = ::std::priv:: __copy_ptrs(__last, this->_M_finish, __first, _TrivialCopy());
    ::std::_Destroy_Range(__i, this->_M_finish);
    this->_M_finish = __i;
    return __first;
  }

public:
  iterator erase(iterator __pos) {

    typedef typename __move_traits<_Tp>::implemented _Movable;

    return _M_erase(__pos, _Movable());
  }
  iterator erase(iterator __first, iterator __last) {

    typedef typename __move_traits<_Tp>::implemented _Movable;

    if (__first == __last)
      return __first;
    return _M_erase(__first, __last, _Movable());
  }


  void resize(size_type __new_size, const _Tp& __x = _Tp()) {



    if (__new_size < size())
      erase(begin() + __new_size, end());
    else
      insert(end(), __new_size - size(), __x);
  }





  void clear() {
    erase(begin(), end());
  }

private:
  void _M_clear() {
    ::std::_Destroy_Range(rbegin(), rend());
    this->_M_end_of_storage.deallocate(this->_M_start, this->_M_end_of_storage._M_data - this->_M_start);
  }

  void _M_clear_after_move() {
    ::std::_Destroy_Moved_Range(rbegin(), rend());
    this->_M_end_of_storage.deallocate(this->_M_start, this->_M_end_of_storage._M_data - this->_M_start);
  }

  void _M_set(pointer __s, pointer __f, pointer __e) {
    this->_M_start = __s;
    this->_M_finish = __f;
    this->_M_end_of_storage._M_data = __e;
  }


  template <class _ForwardIterator>
  pointer _M_allocate_and_copy(size_type& __n,
                               _ForwardIterator __first, _ForwardIterator __last)




  {
    pointer __result = this->_M_end_of_storage.allocate(__n, __n);
    {
      uninitialized_copy(__first, __last, __result);
      return __result;
    }
   
   
  }



  template <class _InputIterator>
  void _M_range_initialize(_InputIterator __first, _InputIterator __last,
                           const input_iterator_tag &) {
    for ( ; __first != __last; ++__first)
      push_back(*__first);
  }

  template <class _ForwardIterator>
  void _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
                           const forward_iterator_tag &) {
    size_type __n = ::std::distance(__first, __last);
    this->_M_start = this->_M_end_of_storage.allocate(__n, __n);
    this->_M_end_of_storage._M_data = this->_M_start + __n;
    this->_M_finish = uninitialized_copy(__first, __last, this->_M_start);
  }

};






}


# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_vector.c" 1
# 33 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_vector.c"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_range_errors.h" 1
# 34 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_range_errors.h"
namespace std {
void __attribute__((visibility("default"))) __stl_throw_runtime_error(const char* __msg);
void __attribute__((visibility("default"))) __stl_throw_range_error(const char* __msg);
void __attribute__((visibility("default"))) __stl_throw_out_of_range(const char* __msg);
void __attribute__((visibility("default"))) __stl_throw_length_error(const char* __msg);
void __attribute__((visibility("default"))) __stl_throw_invalid_argument(const char* __msg);
void __attribute__((visibility("default"))) __stl_throw_overflow_error(const char* __msg);
# 50 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_range_errors.h"
}
# 34 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_vector.c" 2

namespace std {

namespace priv {

template <class _Tp, class _Alloc>
void _Vector_base<_Tp,_Alloc>::_M_throw_length_error() const
{ __stl_throw_length_error("vector"); }

template <class _Tp, class _Alloc>
void _Vector_base<_Tp, _Alloc>::_M_throw_out_of_range() const
{ __stl_throw_out_of_range("vector"); }






}
# 61 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_vector.c"
template <class _Tp, class _Alloc>
void vector<_Tp, _Alloc>::reserve(size_type __n) {
  if (capacity() < __n) {
    if (max_size() < __n) {
      this->_M_throw_length_error();
    }

    const size_type __old_size = size();
    pointer __tmp;
    if (this->_M_start) {
      __tmp = _M_allocate_and_copy(__n, this->_M_start, this->_M_finish);
      _M_clear();
    } else {
      __tmp = this->_M_end_of_storage.allocate(__n, __n);
    }
    _M_set(__tmp, __tmp + __old_size, __tmp + __n);
  }
}

template <class _Tp, class _Alloc>
void vector<_Tp, _Alloc>::_M_insert_overflow_aux(pointer __pos, const _Tp& __x, const __false_type& ,
                                                 size_type __fill_len, bool __atend ) {
  typedef typename __type_traits<_Tp>::has_trivial_copy_constructor _TrivialUCopy;

  typedef typename __move_traits<_Tp>::implemented _Movable;

  size_type __len = _M_compute_next_size(__fill_len);
  pointer __new_start = this->_M_end_of_storage.allocate(__len, __len);
  pointer __new_finish = __new_start;
  {
    __new_finish = ::std::priv:: __uninitialized_move(this->_M_start, __pos, __new_start, _TrivialUCopy(), _Movable());

    if (__fill_len == 1) {
      _Copy_Construct(__new_finish, __x);
      ++__new_finish;
    } else
      __new_finish = ::std::priv:: __uninitialized_fill_n(__new_finish, __fill_len, __x);
    if (!__atend)
      __new_finish = ::std::priv:: __uninitialized_move(__pos, this->_M_finish, __new_finish, _TrivialUCopy(), _Movable());
  }
 

  _M_clear_after_move();
  _M_set(__new_start, __new_finish, __new_start + __len);
}

template <class _Tp, class _Alloc>
void vector<_Tp, _Alloc>::_M_insert_overflow(pointer __pos, const _Tp& __x, const __true_type& ,
                                             size_type __fill_len, bool __atend ) {
  size_type __len = _M_compute_next_size(__fill_len);
  pointer __new_start = this->_M_end_of_storage.allocate(__len, __len);
  pointer __new_finish = static_cast<pointer>(::std::priv:: __copy_trivial(this->_M_start, __pos, __new_start));

  __new_finish = ::std::priv:: __fill_n(__new_finish, __fill_len, __x);
  if (!__atend)
    __new_finish = static_cast<pointer>(::std::priv:: __copy_trivial(__pos, this->_M_finish, __new_finish));
  _M_clear();
  _M_set(__new_start, __new_finish, __new_start + __len);
}

template <class _Tp, class _Alloc>
void vector<_Tp, _Alloc>::_M_fill_insert_aux(iterator __pos, size_type __n,
                                             const _Tp& __x, const __true_type& ) {
  if (_M_is_inside(__x)) {
    _Tp __x_copy = __x;
    _M_fill_insert_aux(__pos, __n, __x_copy, __true_type());
    return;
  }
  iterator __src = this->_M_finish - 1;
  iterator __dst = __src + __n;
  for (; __src >= __pos; --__dst, --__src) {
    ::std::_Move_Construct(__dst, *__src);
    ::std::_Destroy_Moved(__src);
  }
  ::std::priv:: __uninitialized_fill_n(__pos, __n, __x);
  this->_M_finish += __n;
}

template <class _Tp, class _Alloc>
void vector<_Tp, _Alloc>::_M_fill_insert_aux (iterator __pos, size_type __n,
                                              const _Tp& __x, const __false_type& ) {
  typedef typename __type_traits<_Tp>::has_trivial_copy_constructor _TrivialUCopy;
  typedef typename __type_traits<_Tp>::has_trivial_assignment_operator _TrivialCopy;

  if (_M_is_inside(__x)) {
    _Tp __x_copy = __x;
    _M_fill_insert_aux(__pos, __n, __x_copy, __false_type());
    return;
  }
  const size_type __elems_after = this->_M_finish - __pos;
  pointer __old_finish = this->_M_finish;
  if (__elems_after > __n) {
    ::std::priv:: __ucopy_ptrs(this->_M_finish - __n, this->_M_finish, this->_M_finish, _TrivialUCopy());
    this->_M_finish += __n;
    ::std::priv:: __copy_backward_ptrs(__pos, __old_finish - __n, __old_finish, _TrivialCopy());
    ::std::fill(__pos, __pos + __n, __x);
  } else {
    this->_M_finish = ::std::priv:: __uninitialized_fill_n(this->_M_finish, __n - __elems_after, __x);
    ::std::priv:: __ucopy_ptrs(__pos, __old_finish, this->_M_finish, _TrivialUCopy());
    this->_M_finish += __elems_after;
    ::std::fill(__pos, __old_finish, __x);
  }
}

template <class _Tp, class _Alloc>
void vector<_Tp, _Alloc>::_M_fill_insert(iterator __pos,
                                         size_type __n, const _Tp& __x) {

  typedef typename __move_traits<_Tp>::implemented _Movable;

  if (__n != 0) {
    if (size_type(this->_M_end_of_storage._M_data - this->_M_finish) >= __n) {
      _M_fill_insert_aux(__pos, __n, __x, _Movable());
    } else {
      typedef typename __type_traits<_Tp>::has_trivial_assignment_operator _TrivialCopy;
      _M_insert_overflow(__pos, __x, _TrivialCopy(), __n);
    }
  }
}

template <class _Tp, class _Alloc>
vector<_Tp, _Alloc>& vector<_Tp, _Alloc>::operator = (const vector<_Tp, _Alloc>& __x) {
  typedef typename __type_traits<_Tp>::has_trivial_assignment_operator _TrivialCopy;
  typedef typename __type_traits<_Tp>::has_trivial_copy_constructor _TrivialUCopy;
  if (&__x != this) {
    const size_type __xlen = __x.size();
    if (__xlen > capacity()) {
      size_type __len = __xlen;
      pointer __tmp = _M_allocate_and_copy(__len, const_cast<const_pointer>(__x._M_start) + 0,
                                                  const_cast<const_pointer>(__x._M_finish) + 0);
      _M_clear();
      this->_M_start = __tmp;
      this->_M_end_of_storage._M_data = this->_M_start + __len;
    } else if (size() >= __xlen) {
      pointer __i = ::std::priv:: __copy_ptrs(const_cast<const_pointer>(__x._M_start) + 0,
                                           const_cast<const_pointer>(__x._M_finish) + 0, this->_M_start, _TrivialCopy());
      ::std::_Destroy_Range(__i, this->_M_finish);
    } else {
      ::std::priv:: __copy_ptrs(const_cast<const_pointer>(__x._M_start),
                             const_cast<const_pointer>(__x._M_start) + size(), this->_M_start, _TrivialCopy());
      ::std::priv:: __ucopy_ptrs(const_cast<const_pointer>(__x._M_start) + size(),
                              const_cast<const_pointer>(__x._M_finish) + 0, this->_M_finish, _TrivialUCopy());
    }
    this->_M_finish = this->_M_start + __xlen;
  }
  return *this;
}

template <class _Tp, class _Alloc>
void vector<_Tp, _Alloc>::_M_fill_assign(size_t __n, const _Tp& __val) {
  if (__n > capacity()) {
    vector<_Tp, _Alloc> __tmp(__n, __val, get_allocator());
    __tmp.swap(*this);
  } else if (__n > size()) {
    fill(begin(), end(), __val);
    this->_M_finish = ::std::priv:: __uninitialized_fill_n(this->_M_finish, __n - size(), __val);
  } else
    erase(::std::priv:: __fill_n(begin(), __n, __val), end());
}

template <class _Tp, class _Alloc>
typename vector<_Tp, _Alloc>::iterator
vector<_Tp, _Alloc>::insert(iterator __pos, const _Tp& __x) {
  size_type __n = __pos - begin();
  _M_fill_insert(__pos, 1, __x);
  return begin() + __n;
}
# 236 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_vector.c"
}
# 718 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_vector.h" 2
# 729 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_vector.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_bvector.h" 1
# 39 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_bvector.h"
namespace std {
namespace priv {

struct _Bit_reference {
  unsigned int* _M_p;
  unsigned int _M_mask;
  _Bit_reference(unsigned int* __x, unsigned int __y)
    : _M_p(__x), _M_mask(__y) {}

public:
  _Bit_reference() : _M_p(0), _M_mask(0) {}

  operator bool() const {
    return !(!(*_M_p & _M_mask));
  }
  _Bit_reference& operator = (bool __x) {
    if (__x) *_M_p |= _M_mask;
    else *_M_p &= ~_M_mask;
    return *this;
  }
  _Bit_reference& operator = (const _Bit_reference& __x) {
    return *this = bool(__x);
  }
  bool operator == (const _Bit_reference& __x) const {
    return bool(*this) == bool(__x);
  }
  bool operator < (const _Bit_reference& __x) const {
    return !bool(*this) && bool(__x);
  }

  _Bit_reference& operator |= (bool __x) {
    if (__x)
      *_M_p |= _M_mask;
    return *this;
  }
  _Bit_reference& operator &= (bool __x) {
    if (!__x)
      *_M_p &= ~_M_mask;
    return *this;
  }
  void flip() { *_M_p ^= _M_mask; }
};


}

inline void swap(::std::priv:: _Bit_reference& __x, ::std::priv:: _Bit_reference& __y) {
  bool __tmp = (bool)__x;
  __x = __y;
  __y = __tmp;
}


template<>
struct __type_traits< ::std::priv:: _Bit_reference> {
  typedef __false_type has_trivial_default_constructor;
  typedef __true_type has_trivial_copy_constructor;
  typedef __false_type has_trivial_assignment_operator;
  typedef __true_type has_trivial_destructor;
  typedef __false_type is_POD_type;
};

namespace priv {

struct _Bit_iterator_base {
  typedef ptrdiff_t difference_type;

  unsigned int* _M_p;
  unsigned int _M_offset;

  void _M_bump_up() {
    if (_M_offset++ == (int(8 * sizeof(unsigned int))) - 1) {
      _M_offset = 0;
      ++_M_p;
    }
  }

  void _M_bump_down() {
    if (_M_offset-- == 0) {
      _M_offset = (int(8 * sizeof(unsigned int))) - 1;
      --_M_p;
    }
  }

  _Bit_iterator_base() : _M_p(0), _M_offset(0) {}
  _Bit_iterator_base(unsigned int* __x, unsigned int __y) : _M_p(__x), _M_offset(__y) {}






  void _M_advance (difference_type __i) {
    difference_type __n = __i + _M_offset;
    _M_p += __n / (int(8 * sizeof(unsigned int)));
    __n = __n % (int(8 * sizeof(unsigned int)));
    if (__n < 0) {
      _M_offset = (unsigned int) __n + (int(8 * sizeof(unsigned int)));
      --_M_p;
    } else
      _M_offset = (unsigned int) __n;
  }

  difference_type _M_subtract(const _Bit_iterator_base& __x) const {
    return (int(8 * sizeof(unsigned int))) * (_M_p - __x._M_p) + _M_offset - __x._M_offset;
  }
};

inline bool operator==(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y) {
  return __y._M_p == __x._M_p && __y._M_offset == __x._M_offset;
}
inline bool operator!=(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y) {
  return __y._M_p != __x._M_p || __y._M_offset != __x._M_offset;
}

inline bool operator<(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y) {
  return __x._M_p < __y._M_p || (__x._M_p == __y._M_p && __x._M_offset < __y._M_offset);
}

inline bool operator>(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y) {
  return operator <(__y , __x);
}
inline bool operator<=(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y) {
  return !(__y < __x);
}
inline bool operator>=(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y) {
  return !(__x < __y);
}

template <class _Ref, class _Ptr>
struct _Bit_iter : public _Bit_iterator_base {
  typedef _Ref reference;
  typedef _Ptr pointer;
  typedef _Bit_iter<_Ref, _Ptr> _Self;
  typedef random_access_iterator_tag iterator_category;
  typedef bool value_type;
  typedef ptrdiff_t difference_type;
  typedef size_t size_type;

  _Bit_iter(unsigned int* __x, unsigned int __y) : _Bit_iterator_base(__x, __y) {}
  _Bit_iter() {}

  _Bit_iter(const _Bit_iter<_Bit_reference, _Bit_reference*>& __x):
    _Bit_iterator_base((const _Bit_iterator_base&)__x) {}




  reference operator*() const {
    return _Bit_reference(_M_p, 1UL << _M_offset);
  }
  _Self& operator++() {
    _M_bump_up();
    return *this;
  }
  _Self operator++(int) {
    _Self __tmp = *this;
    _M_bump_up();
    return __tmp;
  }
  _Self& operator--() {
    _M_bump_down();
    return *this;
  }
  _Self operator--(int) {
    _Self __tmp = *this;
    _M_bump_down();
    return __tmp;
  }
  _Self& operator+=(difference_type __i) {
    _M_advance(__i);
    return *this;
  }
  _Self& operator-=(difference_type __i) {
    *this += -__i;
    return *this;
  }
  _Self operator+(difference_type __i) const {
    _Self __tmp = *this;
    return __tmp += __i;
  }
  _Self operator-(difference_type __i) const {
    _Self __tmp = *this;
    return __tmp -= __i;
  }
  difference_type operator-(const _Self& __x) const {
    return _M_subtract(__x);
  }
  reference operator[](difference_type __i) { return *(*this + __i); }
};

template <class _Ref, class _Ptr>
inline _Bit_iter<_Ref,_Ptr>
operator+(ptrdiff_t __n, const _Bit_iter<_Ref, _Ptr>& __x) {
   return __x + __n;
}

}


template <class _Ref, class _Ptr>
struct __type_traits< ::std::priv:: _Bit_iter<_Ref, _Ptr> > {
  typedef __false_type has_trivial_default_constructor;
  typedef __true_type has_trivial_copy_constructor;
  typedef __true_type has_trivial_assignment_operator;
  typedef __true_type has_trivial_destructor;
  typedef __false_type is_POD_type;
};
# 260 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_bvector.h"
namespace priv {

typedef _Bit_iter<bool, const bool*> _Bit_const_iterator;
typedef _Bit_iter<_Bit_reference, _Bit_reference*> _Bit_iterator;



template <class _Alloc>
class _Bvector_base {
  typedef _Bvector_base<_Alloc> _Self;
public:
 
  typedef _Alloc allocator_type;
  typedef unsigned int __chunk_type;
  typedef typename _Alloc_traits<__chunk_type, _Alloc>::allocator_type __chunk_allocator_type;
  allocator_type get_allocator() const
  { return static_cast<const __chunk_allocator_type&>(_M_end_of_storage); }

  _Bvector_base(const allocator_type& __a)
    : _M_start(), _M_finish(), _M_end_of_storage(__a,
                                                 (__chunk_type*)0)
  {}

  _Bvector_base(__move_source<_Self> src)
    : _M_start(src.get()._M_start), _M_finish(src.get()._M_finish),
      _M_end_of_storage(src.get()._M_end_of_storage) {

    src.get()._M_start._M_p = 0;
  }


  ~_Bvector_base() {
    _M_deallocate();
  }

protected:

  static size_t _M_bits_to_chunks(size_t __n_bits)
  { return (__n_bits + (int(8 * sizeof(unsigned int))) - 1) / (int(8 * sizeof(unsigned int))); }

  __chunk_type* _M_bit_alloc(size_t __n)
  { return _M_end_of_storage.allocate(_M_bits_to_chunks(__n)); }

  void _M_deallocate() {
    if (_M_start._M_p)
      _M_end_of_storage.deallocate(_M_start._M_p,
                                   _M_end_of_storage._M_data - _M_start._M_p);
  }

  _Bit_iterator _M_start;
  _Bit_iterator _M_finish;
  _STLP_alloc_proxy<__chunk_type*, __chunk_type, __chunk_allocator_type> _M_end_of_storage;
};
# 354 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_bvector.h"
}


template <class _Alloc>
class vector<bool, _Alloc> : public ::std::priv:: _Bvector_base<_Alloc >



{
  typedef ::std::priv:: _Bvector_base<_Alloc > _Base;
  typedef vector<bool, _Alloc> _Self;
public:
  typedef bool value_type;
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef ::std::priv:: _Bit_reference reference;
  typedef bool const_reference;
  typedef ::std::priv:: _Bit_reference* pointer;
  typedef const bool* const_pointer;
  typedef random_access_iterator_tag _Iterator_category;

  typedef ::std::priv:: _Bit_iterator iterator;
  typedef ::std::priv:: _Bit_const_iterator const_iterator;

  typedef ::std::reverse_iterator<const_iterator> const_reverse_iterator; typedef ::std::reverse_iterator<iterator> reverse_iterator;


  typedef typename ::std::priv:: _Bvector_base<_Alloc >::allocator_type allocator_type;
  typedef typename ::std::priv:: _Bvector_base<_Alloc >::__chunk_type __chunk_type;





protected:

  void _M_initialize(size_type __n) {
    __chunk_type* __q = this->_M_bit_alloc(__n);
    this->_M_end_of_storage._M_data = __q + _Base::_M_bits_to_chunks(__n);
    this->_M_start = iterator(__q, 0);
    this->_M_finish = this->_M_start + difference_type(__n);
  }
  void _M_insert_aux(iterator __position, bool __x) {
    if (this->_M_finish._M_p != this->_M_end_of_storage._M_data) {
      ::std::priv:: __copy_backward(__position, this->_M_finish, this->_M_finish + 1,
                                 random_access_iterator_tag(), (difference_type*)0 );
      *__position = __x;
      ++this->_M_finish;
    }
    else {
      size_type __len = size() ? 2 * size() : (int(8 * sizeof(unsigned int)));
      __chunk_type* __q = this->_M_bit_alloc(__len);
      iterator __i = ::std::copy(begin(), __position, iterator(__q, 0));
      *__i++ = __x;
      this->_M_finish = ::std::copy(__position, end(), __i);
      this->_M_deallocate();
      this->_M_end_of_storage._M_data = __q + _Base::_M_bits_to_chunks(__len);
      this->_M_start = iterator(__q, 0);
    }
  }


  template <class _InputIterator>
  void _M_initialize_range(_InputIterator __first, _InputIterator __last,
                           const input_iterator_tag &) {
    this->_M_start = iterator();
    this->_M_finish = iterator();
    this->_M_end_of_storage._M_data = 0;
    for ( ; __first != __last; ++__first)
      push_back(*__first);
  }

  template <class _ForwardIterator>
  void _M_initialize_range(_ForwardIterator __first, _ForwardIterator __last,
                           const forward_iterator_tag &) {
    size_type __n = ::std::distance(__first, __last);
    _M_initialize(__n);
    ::std::copy(__first, __last, this->_M_start);
  }

  template <class _InputIterator>
  void _M_insert_range(iterator __pos,
                       _InputIterator __first, _InputIterator __last,
                       const input_iterator_tag &) {
    for ( ; __first != __last; ++__first) {
      __pos = insert(__pos, *__first);
      ++__pos;
    }
  }

  template <class _ForwardIterator>
  void _M_insert_range(iterator __position,
                       _ForwardIterator __first, _ForwardIterator __last,
                       const forward_iterator_tag &) {
    if (__first != __last) {
      size_type __n = ::std::distance(__first, __last);
      if (capacity() - size() >= __n) {
        ::std::priv:: __copy_backward(__position, end(), this->_M_finish + difference_type(__n),
                                   random_access_iterator_tag(), (difference_type*)0 );
        ::std::copy(__first, __last, __position);
        this->_M_finish += difference_type(__n);
      }
      else {
        size_type __len = size() + (max)(size(), __n);
        __chunk_type* __q = this->_M_bit_alloc(__len);
        iterator __i = ::std::copy(begin(), __position, iterator(__q, 0));
        __i = ::std::copy(__first, __last, __i);
        this->_M_finish = ::std::copy(__position, end(), __i);
        this->_M_deallocate();
        this->_M_end_of_storage._M_data = __q + _Base::_M_bits_to_chunks(__len);
        this->_M_start = iterator(__q, 0);
      }
    }
  }



public:
  iterator begin() { return this->_M_start; }
  const_iterator begin() const { return this->_M_start; }
  iterator end() { return this->_M_finish; }
  const_iterator end() const { return this->_M_finish; }

  reverse_iterator rbegin() { return reverse_iterator(end()); }
  const_reverse_iterator rbegin() const {
    return const_reverse_iterator(end());
  }
  reverse_iterator rend() { return reverse_iterator(begin()); }
  const_reverse_iterator rend() const {
    return const_reverse_iterator(begin());
  }

  size_type size() const { return size_type(end() - begin()); }
  size_type max_size() const { return size_type(-1); }
  size_type capacity() const {
    return size_type(const_iterator(this->_M_end_of_storage._M_data, 0) - begin());
  }
  bool empty() const { return begin() == end(); }
  reference operator[](size_type __n)
  { return *(begin() + difference_type(__n)); }
  const_reference operator[](size_type __n) const
  { return *(begin() + difference_type(__n)); }

  void _M_range_check(size_type __n) const {
    if (__n >= this->size())
      __stl_throw_range_error("vector<bool>");
  }

  reference at(size_type __n)
    { _M_range_check(__n); return (*this)[__n]; }
  const_reference at(size_type __n) const
    { _M_range_check(__n); return (*this)[__n]; }

  explicit vector(const allocator_type& __a = allocator_type())
    : ::std::priv:: _Bvector_base<_Alloc >(__a) {}

  vector(size_type __n, bool __val,
            const allocator_type& __a = allocator_type())
    : ::std::priv:: _Bvector_base<_Alloc >(__a) {
    _M_initialize(__n);
    fill(this->_M_start._M_p, (__chunk_type*)(this->_M_end_of_storage._M_data), __val ? ~0 : 0);
  }

  explicit vector(size_type __n)
    : ::std::priv:: _Bvector_base<_Alloc >(allocator_type()) {
    _M_initialize(__n);
    fill(this->_M_start._M_p, (__chunk_type*)(this->_M_end_of_storage._M_data), 0);
  }

  vector(const _Self& __x)
    : ::std::priv:: _Bvector_base<_Alloc >(__x.get_allocator()) {
    _M_initialize(__x.size());
    ::std::copy(__x.begin(), __x.end(), this->_M_start);
  }


  template <class _Integer>
  void _M_initialize_dispatch(_Integer __n, _Integer __x, const __true_type&) {
    _M_initialize(__n);
    fill(this->_M_start._M_p, this->_M_end_of_storage._M_data, __x ? ~0 : 0);
  }

  template <class _InputIterator>
  void _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
                              const __false_type&) {
    _M_initialize_range(__first, __last, typename ::std::iterator_traits< _InputIterator >::iterator_category());
  }
# 550 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_bvector.h"
  template <class _InputIterator>
  vector(_InputIterator __first, _InputIterator __last,
            const allocator_type& __a = allocator_type())
    : ::std::priv:: _Bvector_base<_Alloc >(__a) {
    typedef typename _IsIntegral<_InputIterator>::_Ret _Integral;
    _M_initialize_dispatch(__first, __last, _Integral());
  }
# 575 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_bvector.h"
  vector(__move_source<_Self> src)
    : ::std::priv:: _Bvector_base<_Alloc >(__move_source<_Base>(src.get())) {}


  ~vector() {}

  vector<bool, _Alloc>& operator=(const vector<bool, _Alloc>& __x) {
    if (&__x == this) return *this;
    if (__x.size() > capacity()) {
      this->_M_deallocate();
      _M_initialize(__x.size());
    }
    ::std::copy(__x.begin(), __x.end(), begin());
    this->_M_finish = begin() + difference_type(__x.size());
    return *this;
  }






  void _M_fill_assign(size_t __n, bool __x) {
    if (__n > size()) {
      fill(this->_M_start._M_p, (__chunk_type*)(this->_M_end_of_storage._M_data), __x ? ~0 : 0);
      insert(end(), __n - size(), __x);
    }
    else {
      erase(begin() + __n, end());
      fill(this->_M_start._M_p, (__chunk_type*)(this->_M_end_of_storage._M_data), __x ? ~0 : 0);
    }
  }
  void assign(size_t __n, bool __x) { _M_fill_assign(__n, __x); }


  template <class _InputIterator>
  void assign(_InputIterator __first, _InputIterator __last) {
    typedef typename _IsIntegral<_InputIterator>::_Ret _Integral;
    _M_assign_dispatch(__first, __last, _Integral());
  }

  template <class _Integer>
  void _M_assign_dispatch(_Integer __n, _Integer __val, const __true_type&)
    { _M_fill_assign((size_t) __n, (bool) __val); }

  template <class _InputIter>
  void _M_assign_dispatch(_InputIter __first, _InputIter __last, const __false_type&)
    { _M_assign_aux(__first, __last, typename ::std::iterator_traits< _InputIter >::iterator_category()); }

  template <class _InputIterator>
  void _M_assign_aux(_InputIterator __first, _InputIterator __last,
                     const input_iterator_tag &) {
    iterator __cur = begin();
    for ( ; __first != __last && __cur != end(); ++__cur, ++__first)
      *__cur = *__first;
    if (__first == __last)
      erase(__cur, end());
    else
      insert(end(), __first, __last);
  }

  template <class _ForwardIterator>
  void _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
                     const forward_iterator_tag &) {
    size_type __len = ::std::distance(__first, __last);
    if (__len < size())
      erase(::std::copy(__first, __last, begin()), end());
    else {
      _ForwardIterator __mid = __first;
      ::std::advance(__mid, size());
      ::std::copy(__first, __mid, begin());
      insert(end(), __mid, __last);
    }
  }


  void reserve(size_type __n) {
    if (capacity() < __n) {
      if (max_size() < __n)
        __stl_throw_length_error("vector<bool>");
      __chunk_type* __q = this->_M_bit_alloc(__n);
      ::std::priv:: _Bit_iterator __z(__q, 0);
      this->_M_finish = ::std::copy(begin(), end(), __z);
      this->_M_deallocate();
      this->_M_start = iterator(__q, 0);
      this->_M_end_of_storage._M_data = __q + _Base::_M_bits_to_chunks(__n);
    }
  }

  reference front() { return *begin(); }
  const_reference front() const { return *begin(); }
  reference back() { return *(end() - 1); }
  const_reference back() const { return *(end() - 1); }
  void push_back(bool __x) {
    if (this->_M_finish._M_p != this->_M_end_of_storage._M_data) {
      *(this->_M_finish) = __x;
      ++this->_M_finish;
    }
    else
      _M_insert_aux(end(), __x);
  }
  void swap(vector<bool, _Alloc>& __x) {
    ::std::swap(this->_M_start, __x._M_start);
    ::std::swap(this->_M_finish, __x._M_finish);
    this->_M_end_of_storage.swap(__x._M_end_of_storage);
  }




  iterator insert(iterator __position, bool __x = bool()) {
    difference_type __n = __position - begin();
    if (this->_M_finish._M_p != this->_M_end_of_storage._M_data && __position == end()) {
      *(this->_M_finish) = __x;
      ++this->_M_finish;
    }
    else
      _M_insert_aux(__position, __x);
    return begin() + __n;
  }



  template <class _Integer>
  void _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x,
                          const __true_type&) {
    _M_fill_insert(__pos, (size_type) __n, (bool) __x);
  }

  template <class _InputIterator>
  void _M_insert_dispatch(iterator __pos,
                          _InputIterator __first, _InputIterator __last,
                          const __false_type&) {
    _M_insert_range(__pos, __first, __last, typename ::std::iterator_traits< _InputIterator >::iterator_category());
  }


  template <class _InputIterator>
  void insert(iterator __position,
              _InputIterator __first, _InputIterator __last) {
    typedef typename _IsIntegral<_InputIterator>::_Ret _Integral;
    _M_insert_dispatch(__position, __first, __last, _Integral());
  }
# 763 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_bvector.h"
  void _M_fill_insert(iterator __position, size_type __n, bool __x) {
    if (__n == 0) return;
    if (capacity() - size() >= __n) {
      ::std::priv:: __copy_backward(__position, end(), this->_M_finish + difference_type(__n),
                                 random_access_iterator_tag(), (difference_type*)0 );
      fill(__position, __position + difference_type(__n), __x);
      this->_M_finish += difference_type(__n);
    }
    else {
      size_type __len = size() + (max)(size(), __n);
      __chunk_type* __q = this->_M_bit_alloc(__len);
      iterator __i = ::std::copy(begin(), __position, iterator(__q, 0));
      fill_n(__i, __n, __x);
      this->_M_finish = ::std::copy(__position, end(), __i + difference_type(__n));
      this->_M_deallocate();
      this->_M_end_of_storage._M_data = __q + _Base::_M_bits_to_chunks(__len);
      this->_M_start = iterator(__q, 0);
    }
  }

  void insert(iterator __position, size_type __n, bool __x) {
    _M_fill_insert(__position, __n, __x);
  }

  void pop_back() {
    --this->_M_finish;
  }
  iterator erase(iterator __position) {
    if (__position + 1 != end())
      ::std::copy(__position + 1, end(), __position);
      --this->_M_finish;
    return __position;
  }
  iterator erase(iterator __first, iterator __last) {
    this->_M_finish = ::std::copy(__last, end(), __first);
    return __first;
  }
  void resize(size_type __new_size, bool __x = bool()) {
    if (__new_size < size())
      erase(begin() + difference_type(__new_size), end());
    else
      insert(end(), __new_size - size(), __x);
  }
  void flip() {
    for (__chunk_type* __p = this->_M_start._M_p; __p != this->_M_end_of_storage._M_data; ++__p)
      *__p = ~*__p;
  }

  void clear() { erase(begin(), end()); }
};
# 826 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_bvector.h"
}
# 730 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_vector.h" 2







namespace std {



typedef vector<bool, allocator<bool> > bit_vector;




# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_relops_cont.h" 1





template <class _Tp, class _Alloc>
inline bool operator==(const vector<_Tp, _Alloc>& __x,
                                  const vector<_Tp, _Alloc>& __y) {
  return __x.size() == __y.size() &&
         equal(__x.begin(), __x.end(), __y.begin());
}


template <class _Tp, class _Alloc>
inline bool operator<(const vector<_Tp, _Alloc>& __x,
                                 const vector<_Tp, _Alloc>& __y) {
  return lexicographical_compare(__x.begin(), __x.end(),
                                 __y.begin(), __y.end());
}

template <class _Tp, class _Alloc> inline bool operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y) {return !(__x == __y);}template <class _Tp, class _Alloc> inline bool operator>(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y) {return __y < __x;}template <class _Tp, class _Alloc> inline bool operator<=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y) { return !(__y < __x);}template <class _Tp, class _Alloc> inline bool operator>=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y) { return !(__x < __y);}


template <class _Tp, class _Alloc>
inline void swap(vector<_Tp, _Alloc>& __x,
                            vector<_Tp, _Alloc>& __y) {
  __x.swap(__y);
}
# 747 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_vector.h" 2





template <class _Tp, class _Alloc>
struct __move_traits<vector<_Tp, _Alloc> > {
  typedef __true_type implemented;
  typedef typename __move_traits<_Alloc>::complete complete;
};



template <class _Tp, class _Alloc>
struct _DefaultZeroValue<vector<_Tp, _Alloc> >
{ typedef typename __type_traits<_Alloc>::has_trivial_default_constructor _Ret; };




}
# 38 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/vector" 2
# 50 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/vector"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_epilog.h" 1
# 19 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_epilog.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_config_compat_post.h" 1
# 20 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_epilog.h" 2
# 51 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/vector" 2
# 39 "webkey-2.09/service/webkey.cpp" 2
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/map" 1
# 30 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/map"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_prolog.h" 1






# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_cprolog.h" 1
# 8 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_prolog.h" 2
# 31 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/map" 2





# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_map.h" 1
# 34 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_map.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_tree.h" 1
# 73 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_tree.h"
namespace std {

namespace priv {

typedef bool _Rb_tree_Color_type;






struct _Rb_tree_node_base {
  typedef _Rb_tree_Color_type _Color_type;
  typedef _Rb_tree_node_base* _Base_ptr;

  _Color_type _M_color;
  _Base_ptr _M_parent;
  _Base_ptr _M_left;
  _Base_ptr _M_right;

  static _Base_ptr _S_minimum(_Base_ptr __x) {
    while (__x->_M_left != 0) __x = __x->_M_left;
    return __x;
  }

  static _Base_ptr _S_maximum(_Base_ptr __x) {
    while (__x->_M_right != 0) __x = __x->_M_right;
    return __x;
  }
};

template <class _Value>
struct _Rb_tree_node : public _Rb_tree_node_base {
  _Value _M_value_field;
 
};

struct _Rb_tree_base_iterator;

template <class _Dummy>
class _Rb_global {
public:
  typedef _Rb_tree_node_base* _Base_ptr;

  static void _Rebalance(_Base_ptr __x, _Base_ptr& __root);
  static _Base_ptr _Rebalance_for_erase(_Base_ptr __z,
                                                   _Base_ptr& __root,
                                                   _Base_ptr& __leftmost,
                                                   _Base_ptr& __rightmost);


  static _Base_ptr _M_increment (_Base_ptr);
  static _Base_ptr _M_decrement (_Base_ptr);
  static void _Rotate_left (_Base_ptr __x, _Base_ptr& __root);
  static void _Rotate_right(_Base_ptr __x, _Base_ptr& __root);
};





typedef _Rb_global<bool> _Rb_global_inst;

struct _Rb_tree_base_iterator {
  typedef _Rb_tree_node_base* _Base_ptr;
  typedef bidirectional_iterator_tag iterator_category;
  typedef ptrdiff_t difference_type;
  _Base_ptr _M_node;
  _Rb_tree_base_iterator() : _M_node(0) {}
  _Rb_tree_base_iterator(_Base_ptr __x) : _M_node(__x) {}
};

template <class _Value, class _Traits>
struct _Rb_tree_iterator : public _Rb_tree_base_iterator {
  typedef _Value value_type;
  typedef typename _Traits::reference reference;
  typedef typename _Traits::pointer pointer;
  typedef _Rb_tree_iterator<_Value, _Traits> _Self;
  typedef _Rb_tree_node_base* _Base_ptr;
  typedef _Rb_tree_node<_Value>* _Link_type;

  typedef typename _Traits::_NonConstTraits _NonConstTraits;
  typedef _Rb_tree_iterator<_Value, _NonConstTraits> iterator;
  typedef typename _Traits::_ConstTraits _ConstTraits;
  typedef _Rb_tree_iterator<_Value, _ConstTraits> const_iterator;

  _Rb_tree_iterator() {}




  explicit

  _Rb_tree_iterator(_Base_ptr __x) : _Rb_tree_base_iterator(__x) {}

  _Rb_tree_iterator(const iterator& __it) : _Rb_tree_base_iterator(__it._M_node) {}

  reference operator*() const {
    return static_cast<_Link_type>(_M_node)->_M_value_field;
  }

  pointer operator->() const { return &(operator*()); }

  _Self& operator++() {
    _M_node = _Rb_global_inst::_M_increment(_M_node);
    return *this;
  }
  _Self operator++(int) {
    _Self __tmp = *this;
    ++(*this);
    return __tmp;
  }

  _Self& operator--() {
    _M_node = _Rb_global_inst::_M_decrement(_M_node);
    return *this;
  }
  _Self operator--(int) {
    _Self __tmp = *this;
    --(*this);
    return __tmp;
  }

  bool operator == (const_iterator __rhs) const {
    return _M_node == __rhs._M_node;
  }
  bool operator != (const_iterator __rhs) const {
    return _M_node != __rhs._M_node;
  }
};


}
template <class _Value, class _Traits>
struct __type_traits< ::std::priv:: _Rb_tree_iterator<_Value, _Traits> > {
  typedef __false_type has_trivial_default_constructor;
  typedef __true_type has_trivial_copy_constructor;
  typedef __true_type has_trivial_assignment_operator;
  typedef __true_type has_trivial_destructor;
  typedef __false_type is_POD_type;
};
namespace priv {
# 231 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_tree.h"
template <class _Tp, class _Alloc>
class _Rb_tree_base {
public:
  typedef _Rb_tree_node_base _Node_base;
  typedef _Rb_tree_node<_Tp> _Node;
 
  typedef _Alloc allocator_type;
private:
  typedef _Rb_tree_base<_Tp, _Alloc> _Self;
  typedef typename _Alloc_traits<_Node, _Alloc>::allocator_type _M_node_allocator_type;
  typedef _STLP_alloc_proxy<_Node_base, _Node, _M_node_allocator_type> _AllocProxy;

public:
  allocator_type get_allocator() const {
    return _M_header;
  }

protected:
  _Rb_tree_base(const allocator_type& __a) :
    _M_header(__a, _Node_base() ) {
    _M_empty_initialize();
  }


  _Rb_tree_base(__move_source<_Self> src) :
    _M_header(__move_source<_AllocProxy>(src.get()._M_header)) {
    _M_rebind(&src.get()._M_header._M_data);
    src.get()._M_empty_initialize();
  }


  void _M_empty_initialize() {
    _M_header._M_data._M_color = false;

    _M_header._M_data._M_parent = 0;
    _M_header._M_data._M_left = &_M_header._M_data;
    _M_header._M_data._M_right = &_M_header._M_data;
  }

  void _M_rebind(_Node_base *__static_node) {
    if (_M_header._M_data._M_parent != 0) {
      _M_header._M_data._M_parent->_M_parent = &_M_header._M_data;
    }
    if (_M_header._M_data._M_right == __static_node) {
      _M_header._M_data._M_right = &_M_header._M_data;
    }
    if (_M_header._M_data._M_left == __static_node) {
      _M_header._M_data._M_left = &_M_header._M_data;
    }
  }

  _AllocProxy _M_header;
};





template <class _Key, class _Compare,
          class _Value, class _KeyOfValue, class _Traits,
          class _Alloc = allocator<_Value> >
class _Rb_tree : public _Rb_tree_base<_Value, _Alloc> {
  typedef _Rb_tree_base<_Value, _Alloc> _Base;
  typedef _Rb_tree<_Key, _Compare, _Value, _KeyOfValue, _Traits, _Alloc> _Self;
protected:
  typedef _Rb_tree_node_base * _Base_ptr;
  typedef _Rb_tree_node<_Value> _Node;
  typedef _Node* _Link_type;
  typedef _Rb_tree_Color_type _Color_type;
public:
  typedef _Key key_type;
  typedef _Value value_type;
  typedef typename _Traits::pointer pointer;
  typedef const value_type* const_pointer;
  typedef typename _Traits::reference reference;
  typedef const value_type& const_reference;
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef bidirectional_iterator_tag _Iterator_category;
  typedef typename _Base::allocator_type allocator_type;

protected:

 
  _Base_ptr _M_create_node(const value_type& __x) {
    _Link_type __tmp = this->_M_header.allocate(1);
    {
      _Copy_Construct(&__tmp->_M_value_field, __x);
    }
   
    _S_left(__tmp) = 0;
    _S_right(__tmp) = 0;
    return __tmp;
  }

  _Base_ptr _M_clone_node(_Base_ptr __x) {
    _Base_ptr __tmp = _M_create_node(_S_value(__x));
    _S_color(__tmp) = _S_color(__x);
    return __tmp;
  }

  size_type _M_node_count;
  _Compare _M_key_compare;

  _Base_ptr _M_root() const
  { return this->_M_header._M_data._M_parent; }
  _Base_ptr _M_leftmost() const
  { return this->_M_header._M_data._M_left; }
  _Base_ptr _M_rightmost() const
  { return this->_M_header._M_data._M_right; }

  _Base_ptr& _M_root()
  { return this->_M_header._M_data._M_parent; }
  _Base_ptr& _M_leftmost()
  { return this->_M_header._M_data._M_left; }
  _Base_ptr& _M_rightmost()
  { return this->_M_header._M_data._M_right; }

  static _Base_ptr& _S_left(_Base_ptr __x)
  { return __x->_M_left; }
  static _Base_ptr& _S_right(_Base_ptr __x)
  { return __x->_M_right; }
  static _Base_ptr& _S_parent(_Base_ptr __x)
  { return __x->_M_parent; }
  static value_type& _S_value(_Base_ptr __x)
  { return static_cast<_Link_type>(__x)->_M_value_field; }
  static const _Key& _S_key(_Base_ptr __x)
  { return _KeyOfValue()(_S_value(__x));}
  static _Color_type& _S_color(_Base_ptr __x)
  { return (_Color_type&)(__x->_M_color); }

  static _Base_ptr _S_minimum(_Base_ptr __x)
  { return _Rb_tree_node_base::_S_minimum(__x); }

  static _Base_ptr _S_maximum(_Base_ptr __x)
  { return _Rb_tree_node_base::_S_maximum(__x); }

public:
  typedef typename _Traits::_NonConstTraits _NonConstTraits;
  typedef typename _Traits::_ConstTraits _ConstTraits;
  typedef _Rb_tree_iterator<value_type, _NonConstTraits> iterator;
  typedef _Rb_tree_iterator<value_type, _ConstTraits> const_iterator;
  typedef ::std::reverse_iterator<const_iterator> const_reverse_iterator; typedef ::std::reverse_iterator<iterator> reverse_iterator;

private:
  iterator _M_insert(_Base_ptr __parent, const value_type& __val, _Base_ptr __on_left = 0, _Base_ptr __on_right = 0);
  _Base_ptr _M_copy(_Base_ptr __x, _Base_ptr __p);
  void _M_erase(_Base_ptr __x);

public:

  _Rb_tree()
    : _Rb_tree_base<_Value, _Alloc>(allocator_type()), _M_node_count(0), _M_key_compare(_Compare())
    {}

  _Rb_tree(const _Compare& __comp)
    : _Rb_tree_base<_Value, _Alloc>(allocator_type()), _M_node_count(0), _M_key_compare(__comp)
    {}

  _Rb_tree(const _Compare& __comp, const allocator_type& __a)
    : _Rb_tree_base<_Value, _Alloc>(__a), _M_node_count(0), _M_key_compare(__comp)
    {}

  _Rb_tree(const _Self& __x)
    : _Rb_tree_base<_Value, _Alloc>(__x.get_allocator()),
      _M_node_count(0), _M_key_compare(__x._M_key_compare) {
    if (__x._M_root() != 0) {
      _S_color(&this->_M_header._M_data) = false;
      _M_root() = _M_copy(__x._M_root(), &this->_M_header._M_data);
      _M_leftmost() = _S_minimum(_M_root());
      _M_rightmost() = _S_maximum(_M_root());
    }
    _M_node_count = __x._M_node_count;
  }


  _Rb_tree(__move_source<_Self> src)
    : _Rb_tree_base<_Value, _Alloc>(__move_source<_Base>(src.get())),
      _M_node_count(src.get()._M_node_count),
      _M_key_compare(_AsMoveSource(src.get()._M_key_compare))
  { src.get()._M_node_count = 0; }


  ~_Rb_tree() { clear(); }
  _Self& operator=(const _Self& __x);

public:

  _Compare key_comp() const { return _M_key_compare; }

  iterator begin() { return iterator(_M_leftmost()); }
  const_iterator begin() const { return const_iterator(_M_leftmost()); }
  iterator end() { return iterator(&this->_M_header._M_data); }
  const_iterator end() const { return const_iterator(const_cast<_Base_ptr>(&this->_M_header._M_data)); }

  reverse_iterator rbegin() { return reverse_iterator(end()); }
  const_reverse_iterator rbegin() const
  { return const_reverse_iterator(end()); }
  reverse_iterator rend() { return reverse_iterator(begin()); }
  const_reverse_iterator rend() const
  { return const_reverse_iterator(begin()); }
  bool empty() const { return _M_node_count == 0; }
  size_type size() const { return _M_node_count; }
  size_type max_size() const { return size_type(-1); }

  void swap(_Self& __t) {
    if (__t.empty()) {
      if (this->empty()) return;
      __t._M_header.swap(this->_M_header);
      __t._M_rebind(&this->_M_header._M_data);
      this->_M_empty_initialize();
    }
    else if (this->empty()) {
      __t.swap(*this);
      return;
    }
    else {
      this->_M_header.swap(__t._M_header);
      this->_M_rebind(&__t._M_header._M_data);
      __t._M_rebind(&this->_M_header._M_data);
    }
    ::std::swap(_M_node_count, __t._M_node_count);
    ::std::swap(_M_key_compare, __t._M_key_compare);
  }

public:

  pair<iterator,bool> insert_unique(const value_type& __x);
  iterator insert_equal(const value_type& __x);

  iterator insert_unique(iterator __pos, const value_type& __x);
  iterator insert_equal(iterator __pos, const value_type& __x);


  template<class _II> void insert_equal(_II __first, _II __last) {
    for ( ; __first != __last; ++__first)
      insert_equal(*__first);
  }
  template<class _II> void insert_unique(_II __first, _II __last) {
    for ( ; __first != __last; ++__first)
      insert_unique(*__first);
  }
# 492 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_tree.h"
  void erase(iterator __pos) {
    _Base_ptr __x = _Rb_global_inst::_Rebalance_for_erase(__pos._M_node,
                                                          this->_M_header._M_data._M_parent,
                                                          this->_M_header._M_data._M_left,
                                                          this->_M_header._M_data._M_right);
    ::std::_Destroy(&_S_value(__x));
    this->_M_header.deallocate(static_cast<_Link_type>(__x), 1);
    --_M_node_count;
  }

  size_type erase(const key_type& __x) {
    pair<iterator,iterator> __p = equal_range(__x);
    size_type __n = ::std::distance(__p.first, __p.second);
    erase(__p.first, __p.second);
    return __n;
  }

  size_type erase_unique(const key_type& __x) {
    iterator __i = find(__x);
    if (__i._M_node != &this->_M_header._M_data) {
      erase(__i);
      return 1;
    }
    return 0;
  }

  void erase(iterator __first, iterator __last) {
    if (__first._M_node == this->_M_header._M_data._M_left &&
        __last._M_node == &this->_M_header._M_data)
      clear();
    else
      while (__first != __last) erase(__first++);
  }

  void erase(const key_type* __first, const key_type* __last) {
    while (__first != __last) erase(*__first++);
  }

  void clear() {
    if (_M_node_count != 0) {
      _M_erase(_M_root());
      _M_leftmost() = &this->_M_header._M_data;
      _M_root() = 0;
      _M_rightmost() = &this->_M_header._M_data;
      _M_node_count = 0;
    }
  }

public:

  template <class _KT>
  iterator find(const _KT& __k) { return iterator(_M_find(__k)); }
  template <class _KT>
  const_iterator find(const _KT& __k) const { return const_iterator(_M_find(__k)); }
private:
  template <class _KT>
  _Base_ptr _M_find(const _KT& __k) const {
    _Base_ptr __y = const_cast<_Base_ptr>(&this->_M_header._M_data);
    _Base_ptr __x = _M_root();

    while (__x != 0)
      if (!_M_key_compare(_S_key(__x), __k))
        __y = __x, __x = _S_left(__x);
      else
        __x = _S_right(__x);

    if (__y != &this->_M_header._M_data) {
      if (_M_key_compare(__k, _S_key(__y))) {
        __y = const_cast<_Base_ptr>(&this->_M_header._M_data);
      }
    }
    return __y;
  }

  template <class _KT>
  _Base_ptr _M_lower_bound(const _KT& __k) const {
    _Base_ptr __y = const_cast<_Base_ptr>(&this->_M_header._M_data);
    _Base_ptr __x = _M_root();

    while (__x != 0)
      if (!_M_key_compare(_S_key(__x), __k))
        __y = __x, __x = _S_left(__x);
      else
        __x = _S_right(__x);

    return __y;
  }

  template <class _KT>
  _Base_ptr _M_upper_bound(const _KT& __k) const {
    _Base_ptr __y = const_cast<_Base_ptr>(&this->_M_header._M_data);
    _Base_ptr __x = _M_root();

    while (__x != 0)
      if (_M_key_compare(__k, _S_key(__x)))
        __y = __x, __x = _S_left(__x);
      else
        __x = _S_right(__x);

    return __y;
  }

public:
  template <class _KT>
  size_type count(const _KT& __x) const {
    pair<const_iterator, const_iterator> __p = equal_range(__x);
    return ::std::distance(__p.first, __p.second);
  }
  template <class _KT>
  iterator lower_bound(const _KT& __x) { return iterator(_M_lower_bound(__x)); }
  template <class _KT>
  const_iterator lower_bound(const _KT& __x) const { return const_iterator(_M_lower_bound(__x)); }
  template <class _KT>
  iterator upper_bound(const _KT& __x) { return iterator(_M_upper_bound(__x)); }
  template <class _KT>
  const_iterator upper_bound(const _KT& __x) const { return const_iterator(_M_upper_bound(__x)); }
  template <class _KT>
  pair<iterator,iterator> equal_range(const _KT& __x)
  { return pair<iterator, iterator>(lower_bound(__x), upper_bound(__x)); }
  template <class _KT>
  pair<const_iterator, const_iterator> equal_range(const _KT& __x) const
  { return pair<const_iterator, const_iterator>(lower_bound(__x), upper_bound(__x)); }
  template <class _KT>
  pair<iterator,iterator> equal_range_unique(const _KT& __x) {
    pair<iterator, iterator> __p;
    __p.second = lower_bound(__x);
    if (__p.second._M_node != &this->_M_header._M_data &&
        !_M_key_compare(__x, _S_key(__p.second._M_node))) {
      __p.first = __p.second++;
    }
    else {
      __p.first = __p.second;
    }
    return __p;
  }
  template <class _KT>
  pair<const_iterator, const_iterator> equal_range_unique(const _KT& __x) const {
    pair<const_iterator, const_iterator> __p;
    __p.second = lower_bound(__x);
    if (__p.second._M_node != &this->_M_header._M_data &&
        !_M_key_compare(__x, _S_key(__p.second._M_node))) {
      __p.first = __p.second++;
    }
    else {
      __p.first = __p.second;
    }
    return __p;
  }






};





}

}


# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_tree.c" 1
# 53 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_tree.c"
namespace std {

namespace priv {



template <class _Dummy> void
_Rb_global<_Dummy>::_Rotate_left(_Rb_tree_node_base* __x,
                                 _Rb_tree_node_base*& __root) {
  _Rb_tree_node_base* __y = __x->_M_right;
  __x->_M_right = __y->_M_left;
  if (__y->_M_left != 0)
    __y->_M_left->_M_parent = __x;
  __y->_M_parent = __x->_M_parent;

  if (__x == __root)
    __root = __y;
  else if (__x == __x->_M_parent->_M_left)
    __x->_M_parent->_M_left = __y;
  else
    __x->_M_parent->_M_right = __y;
  __y->_M_left = __x;
  __x->_M_parent = __y;
}

template <class _Dummy> void
_Rb_global<_Dummy>::_Rotate_right(_Rb_tree_node_base* __x,
                                  _Rb_tree_node_base*& __root) {
  _Rb_tree_node_base* __y = __x->_M_left;
  __x->_M_left = __y->_M_right;
  if (__y->_M_right != 0)
    __y->_M_right->_M_parent = __x;
  __y->_M_parent = __x->_M_parent;

  if (__x == __root)
    __root = __y;
  else if (__x == __x->_M_parent->_M_right)
    __x->_M_parent->_M_right = __y;
  else
    __x->_M_parent->_M_left = __y;
  __y->_M_right = __x;
  __x->_M_parent = __y;
}

template <class _Dummy> void
_Rb_global<_Dummy>::_Rebalance(_Rb_tree_node_base* __x,
                               _Rb_tree_node_base*& __root) {
  __x->_M_color = false;
  while (__x != __root && __x->_M_parent->_M_color == false) {
    if (__x->_M_parent == __x->_M_parent->_M_parent->_M_left) {
      _Rb_tree_node_base* __y = __x->_M_parent->_M_parent->_M_right;
      if (__y && __y->_M_color == false) {
        __x->_M_parent->_M_color = true;
        __y->_M_color = true;
        __x->_M_parent->_M_parent->_M_color = false;
        __x = __x->_M_parent->_M_parent;
      }
      else {
        if (__x == __x->_M_parent->_M_right) {
          __x = __x->_M_parent;
          _Rotate_left(__x, __root);
        }
        __x->_M_parent->_M_color = true;
        __x->_M_parent->_M_parent->_M_color = false;
        _Rotate_right(__x->_M_parent->_M_parent, __root);
      }
    }
    else {
      _Rb_tree_node_base* __y = __x->_M_parent->_M_parent->_M_left;
      if (__y && __y->_M_color == false) {
        __x->_M_parent->_M_color = true;
        __y->_M_color = true;
        __x->_M_parent->_M_parent->_M_color = false;
        __x = __x->_M_parent->_M_parent;
      }
      else {
        if (__x == __x->_M_parent->_M_left) {
          __x = __x->_M_parent;
          _Rotate_right(__x, __root);
        }
        __x->_M_parent->_M_color = true;
        __x->_M_parent->_M_parent->_M_color = false;
        _Rotate_left(__x->_M_parent->_M_parent, __root);
      }
    }
  }
  __root->_M_color = true;
}

template <class _Dummy> _Rb_tree_node_base*
_Rb_global<_Dummy>::_Rebalance_for_erase(_Rb_tree_node_base* __z,
                                         _Rb_tree_node_base*& __root,
                                         _Rb_tree_node_base*& __leftmost,
                                         _Rb_tree_node_base*& __rightmost) {
  _Rb_tree_node_base* __y = __z;
  _Rb_tree_node_base* __x;
  _Rb_tree_node_base* __x_parent;

  if (__y->_M_left == 0)
    __x = __y->_M_right;
  else {
    if (__y->_M_right == 0)
      __x = __y->_M_left;
    else {
      __y = _Rb_tree_node_base::_S_minimum(__y->_M_right);
      __x = __y->_M_right;
    }
  }

  if (__y != __z) {
    __z->_M_left->_M_parent = __y;
    __y->_M_left = __z->_M_left;
    if (__y != __z->_M_right) {
      __x_parent = __y->_M_parent;
      if (__x) __x->_M_parent = __y->_M_parent;
      __y->_M_parent->_M_left = __x;
      __y->_M_right = __z->_M_right;
      __z->_M_right->_M_parent = __y;
    }
    else
      __x_parent = __y;
    if (__root == __z)
      __root = __y;
    else if (__z->_M_parent->_M_left == __z)
      __z->_M_parent->_M_left = __y;
    else
      __z->_M_parent->_M_right = __y;
    __y->_M_parent = __z->_M_parent;
    ::std::swap(__y->_M_color, __z->_M_color);
    __y = __z;

  }
  else {
    __x_parent = __y->_M_parent;
    if (__x) __x->_M_parent = __y->_M_parent;
    if (__root == __z)
      __root = __x;
    else {
      if (__z->_M_parent->_M_left == __z)
        __z->_M_parent->_M_left = __x;
      else
        __z->_M_parent->_M_right = __x;
    }

    if (__leftmost == __z) {
      if (__z->_M_right == 0)
        __leftmost = __z->_M_parent;

      else
        __leftmost = _Rb_tree_node_base::_S_minimum(__x);
    }
    if (__rightmost == __z) {
      if (__z->_M_left == 0)
        __rightmost = __z->_M_parent;

      else
        __rightmost = _Rb_tree_node_base::_S_maximum(__x);
    }
  }

  if (__y->_M_color != false) {
    while (__x != __root && (__x == 0 || __x->_M_color == true))
      if (__x == __x_parent->_M_left) {
        _Rb_tree_node_base* __w = __x_parent->_M_right;
        if (__w->_M_color == false) {
          __w->_M_color = true;
          __x_parent->_M_color = false;
          _Rotate_left(__x_parent, __root);
          __w = __x_parent->_M_right;
        }
        if ((__w->_M_left == 0 ||
             __w->_M_left->_M_color == true) && (__w->_M_right == 0 ||
             __w->_M_right->_M_color == true)) {
          __w->_M_color = false;
          __x = __x_parent;
          __x_parent = __x_parent->_M_parent;
        } else {
          if (__w->_M_right == 0 ||
              __w->_M_right->_M_color == true) {
            if (__w->_M_left) __w->_M_left->_M_color = true;
            __w->_M_color = false;
            _Rotate_right(__w, __root);
            __w = __x_parent->_M_right;
          }
          __w->_M_color = __x_parent->_M_color;
          __x_parent->_M_color = true;
          if (__w->_M_right) __w->_M_right->_M_color = true;
          _Rotate_left(__x_parent, __root);
          break;
        }
      } else {
        _Rb_tree_node_base* __w = __x_parent->_M_left;
        if (__w->_M_color == false) {
          __w->_M_color = true;
          __x_parent->_M_color = false;
          _Rotate_right(__x_parent, __root);
          __w = __x_parent->_M_left;
        }
        if ((__w->_M_right == 0 ||
             __w->_M_right->_M_color == true) && (__w->_M_left == 0 ||
             __w->_M_left->_M_color == true)) {
          __w->_M_color = false;
          __x = __x_parent;
          __x_parent = __x_parent->_M_parent;
        } else {
          if (__w->_M_left == 0 ||
              __w->_M_left->_M_color == true) {
            if (__w->_M_right) __w->_M_right->_M_color = true;
            __w->_M_color = false;
            _Rotate_left(__w, __root);
            __w = __x_parent->_M_left;
          }
          __w->_M_color = __x_parent->_M_color;
          __x_parent->_M_color = true;
          if (__w->_M_left) __w->_M_left->_M_color = true;
          _Rotate_right(__x_parent, __root);
          break;
        }
      }
    if (__x) __x->_M_color = true;
  }
  return __y;
}

template <class _Dummy> _Rb_tree_node_base*
_Rb_global<_Dummy>::_M_decrement(_Rb_tree_node_base* _M_node) {
  if (_M_node->_M_color == false && _M_node->_M_parent->_M_parent == _M_node)
    _M_node = _M_node->_M_right;
  else if (_M_node->_M_left != 0) {
    _M_node = _Rb_tree_node_base::_S_maximum(_M_node->_M_left);
  }
  else {
    _Base_ptr __y = _M_node->_M_parent;
    while (_M_node == __y->_M_left) {
      _M_node = __y;
      __y = __y->_M_parent;
    }
    _M_node = __y;
  }
  return _M_node;
}

template <class _Dummy> _Rb_tree_node_base*
_Rb_global<_Dummy>::_M_increment(_Rb_tree_node_base* _M_node) {
  if (_M_node->_M_right != 0) {
    _M_node = _Rb_tree_node_base::_S_minimum(_M_node->_M_right);
  }
  else {
    _Base_ptr __y = _M_node->_M_parent;
    while (_M_node == __y->_M_right) {
      _M_node = __y;
      __y = __y->_M_parent;
    }



    if (_M_node->_M_right != __y)
      _M_node = __y;
  }
  return _M_node;
}




template <class _Key, class _Compare,
          class _Value, class _KeyOfValue, class _Traits, class _Alloc>
_Rb_tree<_Key,_Compare,_Value,_KeyOfValue,_Traits,_Alloc>&
_Rb_tree<_Key,_Compare,_Value,_KeyOfValue,_Traits,_Alloc> ::operator=(
  const _Rb_tree<_Key,_Compare,_Value,_KeyOfValue,_Traits,_Alloc>& __x) {
  if (this != &__x) {

    clear();
    _M_node_count = 0;
    _M_key_compare = __x._M_key_compare;
    if (__x._M_root() == 0) {
      _M_root() = 0;
      _M_leftmost() = &this->_M_header._M_data;
      _M_rightmost() = &this->_M_header._M_data;
    }
    else {
      _M_root() = _M_copy(__x._M_root(), &this->_M_header._M_data);
      _M_leftmost() = _S_minimum(_M_root());
      _M_rightmost() = _S_maximum(_M_root());
      _M_node_count = __x._M_node_count;
    }
  }
  return *this;
}





template <class _Key, class _Compare,
          class _Value, class _KeyOfValue, class _Traits, class _Alloc>
typename _Rb_tree<_Key, _Compare, _Value, _KeyOfValue, _Traits, _Alloc>::iterator
_Rb_tree<_Key,_Compare,_Value,_KeyOfValue,_Traits,_Alloc> ::_M_insert(_Rb_tree_node_base * __parent,
                                                                      const _Value& __val,
                                                                      _Rb_tree_node_base * __on_left,
                                                                      _Rb_tree_node_base * __on_right) {


  _Base_ptr __new_node;

  if ( __parent == &this->_M_header._M_data ) {
    __new_node = _M_create_node(__val);
    _S_left(__parent) = __new_node;
    _M_root() = __new_node;
    _M_rightmost() = __new_node;
  }
  else if ( __on_right == 0 &&
           ( __on_left != 0 ||
             _M_key_compare( _KeyOfValue()(__val), _S_key(__parent) ) ) ) {
    __new_node = _M_create_node(__val);
    _S_left(__parent) = __new_node;
    if (__parent == _M_leftmost())
      _M_leftmost() = __new_node;
  }
  else {
    __new_node = _M_create_node(__val);
    _S_right(__parent) = __new_node;
    if (__parent == _M_rightmost())
      _M_rightmost() = __new_node;
  }
  _S_parent(__new_node) = __parent;
  _Rb_global_inst::_Rebalance(__new_node, this->_M_header._M_data._M_parent);
  ++_M_node_count;
  return iterator(__new_node);
}

template <class _Key, class _Compare,
          class _Value, class _KeyOfValue, class _Traits, class _Alloc>
typename _Rb_tree<_Key, _Compare, _Value, _KeyOfValue, _Traits, _Alloc>::iterator
_Rb_tree<_Key,_Compare,_Value,_KeyOfValue,_Traits,_Alloc> ::insert_equal(const _Value& __val) {
  _Base_ptr __y = &this->_M_header._M_data;
  _Base_ptr __x = _M_root();
  while (__x != 0) {
    __y = __x;
    if (_M_key_compare(_KeyOfValue()(__val), _S_key(__x))) {
      __x = _S_left(__x);
    }
    else
      __x = _S_right(__x);
  }
  return _M_insert(__y, __val, __x);
}


template <class _Key, class _Compare,
          class _Value, class _KeyOfValue, class _Traits, class _Alloc>
pair<typename _Rb_tree<_Key, _Compare, _Value, _KeyOfValue, _Traits, _Alloc>::iterator, bool>
_Rb_tree<_Key,_Compare,_Value,_KeyOfValue,_Traits,_Alloc> ::insert_unique(const _Value& __val) {
  _Base_ptr __y = &this->_M_header._M_data;
  _Base_ptr __x = _M_root();
  bool __comp = true;
  while (__x != 0) {
    __y = __x;
    __comp = _M_key_compare(_KeyOfValue()(__val), _S_key(__x));
    __x = __comp ? _S_left(__x) : _S_right(__x);
  }
  iterator __j = iterator(__y);
  if (__comp) {
    if (__j == begin())
      return pair<iterator,bool>(_M_insert(__y, __val, __y), true);
    else
      --__j;
  }
  if (_M_key_compare(_S_key(__j._M_node), _KeyOfValue()(__val))) {
    return pair<iterator,bool>(_M_insert(__y, __val, __x), true);
  }
  return pair<iterator,bool>(__j, false);
}



template <class _Key, class _Compare,
          class _Value, class _KeyOfValue, class _Traits, class _Alloc>
typename _Rb_tree<_Key, _Compare, _Value, _KeyOfValue, _Traits, _Alloc>::iterator
_Rb_tree<_Key,_Compare,_Value,_KeyOfValue,_Traits,_Alloc> ::insert_unique(iterator __position,
                                                                          const _Value& __val) {
  if (__position._M_node == this->_M_header._M_data._M_left) {


    if (empty())
      return insert_unique(__val).first;

    if (_M_key_compare(_KeyOfValue()(__val), _S_key(__position._M_node))) {
      return _M_insert(__position._M_node, __val, __position._M_node);
    }

    else {
      bool __comp_pos_v = _M_key_compare( _S_key(__position._M_node), _KeyOfValue()(__val) );

      if (__comp_pos_v == false)
        return __position;




      iterator __after = __position;
      ++__after;



      if (__after._M_node == &this->_M_header._M_data)



        return _M_insert(__position._M_node, __val, 0, __position._M_node);





      if (_M_key_compare( _KeyOfValue()(__val), _S_key(__after._M_node) )) {
        if (_S_right(__position._M_node) == 0)
          return _M_insert(__position._M_node, __val, 0, __position._M_node);
        else
          return _M_insert(__after._M_node, __val, __after._M_node);
      }
      else {
        return insert_unique(__val).first;
      }
    }
  }
  else if (__position._M_node == &this->_M_header._M_data) {
    if (_M_key_compare(_S_key(_M_rightmost()), _KeyOfValue()(__val))) {


        return _M_insert(_M_rightmost(), __val, 0, __position._M_node);
    }
    else
      return insert_unique(__val).first;
  }
  else {
    iterator __before = __position;
    --__before;

    bool __comp_v_pos = _M_key_compare(_KeyOfValue()(__val), _S_key(__position._M_node));

    if (__comp_v_pos
        && _M_key_compare( _S_key(__before._M_node), _KeyOfValue()(__val) )) {

      if (_S_right(__before._M_node) == 0)
        return _M_insert(__before._M_node, __val, 0, __before._M_node);
      else
        return _M_insert(__position._M_node, __val, __position._M_node);

    }
    else {

      iterator __after = __position;
      ++__after;

      bool __comp_pos_v = !__comp_v_pos;




      if (!__comp_v_pos) {
        __comp_pos_v = _M_key_compare(_S_key(__position._M_node), _KeyOfValue()(__val));
      }

      if ( (!__comp_v_pos)
          && __comp_pos_v
          && (__after._M_node == &this->_M_header._M_data ||
              _M_key_compare( _KeyOfValue()(__val), _S_key(__after._M_node) ))) {
        if (_S_right(__position._M_node) == 0)
          return _M_insert(__position._M_node, __val, 0, __position._M_node);
        else
          return _M_insert(__after._M_node, __val, __after._M_node);
      } else {

        if (__comp_v_pos == __comp_pos_v)
          return __position;
        else
          return insert_unique(__val).first;
      }
    }
  }
}

template <class _Key, class _Compare,
          class _Value, class _KeyOfValue, class _Traits, class _Alloc>
typename _Rb_tree<_Key, _Compare, _Value, _KeyOfValue, _Traits, _Alloc>::iterator
_Rb_tree<_Key,_Compare,_Value,_KeyOfValue,_Traits,_Alloc> ::insert_equal(iterator __position,
                                                                         const _Value& __val) {
  if (__position._M_node == this->_M_header._M_data._M_left) {


    if (size() <= 0)
        return insert_equal(__val);

    if (!_M_key_compare(_S_key(__position._M_node), _KeyOfValue()(__val)))
      return _M_insert(__position._M_node, __val, __position._M_node);
    else {

      if (__position._M_node->_M_left == __position._M_node)

        return _M_insert(__position._M_node, __val);




      iterator __after = __position;
      ++__after;





      if ( __after._M_node == &this->_M_header._M_data ||
           !_M_key_compare( _S_key(__after._M_node), _KeyOfValue()(__val) ) ) {
        if (_S_right(__position._M_node) == 0)
          return _M_insert(__position._M_node, __val, 0, __position._M_node);
        else
          return _M_insert(__after._M_node, __val, __after._M_node);
      }
      else {
        return insert_equal(__val);
      }
    }
  }
  else if (__position._M_node == &this->_M_header._M_data) {
    if (!_M_key_compare(_KeyOfValue()(__val), _S_key(_M_rightmost())))
      return _M_insert(_M_rightmost(), __val, 0, __position._M_node);
    else {
      return insert_equal(__val);
    }
  }
  else {
    iterator __before = __position;
    --__before;





    bool __comp_pos_v = _M_key_compare(_S_key(__position._M_node), _KeyOfValue()(__val));
    if (!__comp_pos_v &&
        !_M_key_compare(_KeyOfValue()(__val), _S_key(__before._M_node))) {
      if (_S_right(__before._M_node) == 0)
        return _M_insert(__before._M_node, __val, 0, __before._M_node);
      else
        return _M_insert(__position._M_node, __val, __position._M_node);
    }
    else {


      iterator __after = __position;
      ++__after;

      if (__comp_pos_v &&
          ( __after._M_node == &this->_M_header._M_data ||
            !_M_key_compare( _S_key(__after._M_node), _KeyOfValue()(__val) ) ) ) {
        if (_S_right(__position._M_node) == 0)
          return _M_insert(__position._M_node, __val, 0, __position._M_node);
        else
          return _M_insert(__after._M_node, __val, __after._M_node);
      }
      else {
        return insert_equal(__val);
      }
    }
  }
}

template <class _Key, class _Compare,
          class _Value, class _KeyOfValue, class _Traits, class _Alloc>
_Rb_tree_node_base*
_Rb_tree<_Key,_Compare,_Value,_KeyOfValue,_Traits,_Alloc> ::_M_copy(_Rb_tree_node_base* __x,
                                                                    _Rb_tree_node_base* __p) {

  _Base_ptr __top = _M_clone_node(__x);
  _S_parent(__top) = __p;

  {
    if (_S_right(__x))
      _S_right(__top) = _M_copy(_S_right(__x), __top);
    __p = __top;
    __x = _S_left(__x);

    while (__x != 0) {
      _Base_ptr __y = _M_clone_node(__x);
      _S_left(__p) = __y;
      _S_parent(__y) = __p;
      if (_S_right(__x))
        _S_right(__y) = _M_copy(_S_right(__x), __y);
      __p = __y;
      __x = _S_left(__x);
    }
  }
 

  return __top;
}


template <class _Key, class _Compare,
          class _Value, class _KeyOfValue, class _Traits, class _Alloc>
void
_Rb_tree<_Key,_Compare,_Value,_KeyOfValue,_Traits,_Alloc>::_M_erase(_Rb_tree_node_base *__x) {

  while (__x != 0) {
    _M_erase(_S_right(__x));
    _Base_ptr __y = _S_left(__x);
    ::std::_Destroy(&_S_value(__x));
    this->_M_header.deallocate(static_cast<_Link_type>(__x),1);
    __x = __y;
  }
}
# 718 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_tree.c"
}
}
# 658 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_tree.h" 2






namespace std {



# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_relops_cont.h" 1





template <class _Key, class _Compare, class _Value, class _KeyOfValue, class _Traits, class _Alloc>
inline bool operator==(const ::std::priv:: _Rb_tree<_Key,_Compare,_Value,_KeyOfValue,_Traits,_Alloc>& __x,
                                  const ::std::priv:: _Rb_tree<_Key,_Compare,_Value,_KeyOfValue,_Traits,_Alloc>& __y) {
  return __x.size() == __y.size() &&
         equal(__x.begin(), __x.end(), __y.begin());
}


template <class _Key, class _Compare, class _Value, class _KeyOfValue, class _Traits, class _Alloc>
inline bool operator<(const ::std::priv:: _Rb_tree<_Key,_Compare,_Value,_KeyOfValue,_Traits,_Alloc>& __x,
                                 const ::std::priv:: _Rb_tree<_Key,_Compare,_Value,_KeyOfValue,_Traits,_Alloc>& __y) {
  return lexicographical_compare(__x.begin(), __x.end(),
                                 __y.begin(), __y.end());
}

template <class _Key, class _Compare, class _Value, class _KeyOfValue, class _Traits, class _Alloc> inline bool operator!=(const ::std::priv:: _Rb_tree<_Key,_Compare,_Value,_KeyOfValue,_Traits,_Alloc>& __x, const ::std::priv:: _Rb_tree<_Key,_Compare,_Value,_KeyOfValue,_Traits,_Alloc>& __y) {return !(__x == __y);}template <class _Key, class _Compare, class _Value, class _KeyOfValue, class _Traits, class _Alloc> inline bool operator>(const ::std::priv:: _Rb_tree<_Key,_Compare,_Value,_KeyOfValue,_Traits,_Alloc>& __x, const ::std::priv:: _Rb_tree<_Key,_Compare,_Value,_KeyOfValue,_Traits,_Alloc>& __y) {return __y < __x;}template <class _Key, class _Compare, class _Value, class _KeyOfValue, class _Traits, class _Alloc> inline bool operator<=(const ::std::priv:: _Rb_tree<_Key,_Compare,_Value,_KeyOfValue,_Traits,_Alloc>& __x, const ::std::priv:: _Rb_tree<_Key,_Compare,_Value,_KeyOfValue,_Traits,_Alloc>& __y) { return !(__y < __x);}template <class _Key, class _Compare, class _Value, class _KeyOfValue, class _Traits, class _Alloc> inline bool operator>=(const ::std::priv:: _Rb_tree<_Key,_Compare,_Value,_KeyOfValue,_Traits,_Alloc>& __x, const ::std::priv:: _Rb_tree<_Key,_Compare,_Value,_KeyOfValue,_Traits,_Alloc>& __y) { return !(__x < __y);}


template <class _Key, class _Compare, class _Value, class _KeyOfValue, class _Traits, class _Alloc>
inline void swap(::std::priv:: _Rb_tree<_Key,_Compare,_Value,_KeyOfValue,_Traits,_Alloc>& __x,
                            ::std::priv:: _Rb_tree<_Key,_Compare,_Value,_KeyOfValue,_Traits,_Alloc>& __y) {
  __x.swap(__y);
}
# 669 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_tree.h" 2




template <class _Key, class _Compare, class _Value, class _KeyOfValue, class _Traits, class _Alloc>
struct __move_traits< ::std::priv:: _Rb_tree<_Key, _Compare, _Value, _KeyOfValue, _Traits, _Alloc> >
  : ::std::priv:: __move_traits_help2<_Compare, _Alloc> {};


}
# 35 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_map.h" 2


namespace std {


namespace priv { template <class _Tp> struct _MapTraitsT; template <class _Tp> struct _ConstMapTraitsT : public ::std::_Const_traits<_Tp> { typedef _ConstMapTraitsT<_Tp> _ConstTraits; typedef _MapTraitsT<_Tp> _NonConstTraits; }; template <class _Tp> struct _MapTraitsT : public ::std::_Nonconst_traits<_Tp> { typedef _ConstMapTraitsT<_Tp> _ConstTraits; typedef _MapTraitsT<_Tp> _NonConstTraits; }; }

template <class _Key, class _Tp, class _Compare = less<_Key>,
          class _Alloc = allocator< pair < const _Key, _Tp > > >
class map



{
  typedef map<_Key, _Tp, _Compare, _Alloc> _Self;
public:



  typedef _Key key_type;
  typedef _Tp data_type;
  typedef _Tp mapped_type;
  typedef pair<const _Key, _Tp> value_type;
  typedef _Compare key_compare;

  class value_compare
    : public binary_function<value_type, value_type, bool> {
  friend class map<_Key,_Tp,_Compare,_Alloc>;
  protected :

    _Compare comp;
    value_compare(_Compare __c) : comp(__c) {}
  public:
    bool operator()(const value_type& __x, const value_type& __y) const
    { return comp(__x.first, __y.first); }
  };

protected:
  typedef ::std::priv:: _MapTraitsT<value_type> _MapTraits;

public:

  typedef ::std::priv:: _Rb_tree<key_type, key_compare,
                              value_type, ::std::priv:: _Select1st< value_type >,
                              _MapTraits, _Alloc> _Rep_type;

  typedef typename _Rep_type::pointer pointer;
  typedef typename _Rep_type::const_pointer const_pointer;
  typedef typename _Rep_type::reference reference;
  typedef typename _Rep_type::const_reference const_reference;
  typedef typename _Rep_type::iterator iterator;
  typedef typename _Rep_type::const_iterator const_iterator;
  typedef typename _Rep_type::reverse_iterator reverse_iterator;
  typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
  typedef typename _Rep_type::size_type size_type;
  typedef typename _Rep_type::difference_type difference_type;
  typedef typename _Rep_type::allocator_type allocator_type;

private:
  _Rep_type _M_t;
 

public:

  map() : _M_t(_Compare(), allocator_type()) {}

  explicit map(const _Compare& __comp,
               const allocator_type& __a = allocator_type())





    : _M_t(__comp, __a) {}


  template <class _InputIterator>
  map(_InputIterator __first, _InputIterator __last)
    : _M_t(_Compare(), allocator_type())
    { _M_t.insert_unique(__first, __last); }

  template <class _InputIterator>
  map(_InputIterator __first, _InputIterator __last, const _Compare& __comp,
      const allocator_type& __a = allocator_type())
    : _M_t(__comp, __a) { _M_t.insert_unique(__first, __last); }
# 146 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_map.h"
  map(const _Self& __x) : _M_t(__x._M_t) {}


  map(__move_source<_Self> src)
    : _M_t(__move_source<_Rep_type>(src.get()._M_t)) {}


  _Self& operator=(const _Self& __x) {
    _M_t = __x._M_t;
    return *this;
  }


  key_compare key_comp() const { return _M_t.key_comp(); }
  value_compare value_comp() const { return value_compare(_M_t.key_comp()); }
  allocator_type get_allocator() const { return _M_t.get_allocator(); }

  iterator begin() { return _M_t.begin(); }
  const_iterator begin() const { return _M_t.begin(); }
  iterator end() { return _M_t.end(); }
  const_iterator end() const { return _M_t.end(); }
  reverse_iterator rbegin() { return _M_t.rbegin(); }
  const_reverse_iterator rbegin() const { return _M_t.rbegin(); }
  reverse_iterator rend() { return _M_t.rend(); }
  const_reverse_iterator rend() const { return _M_t.rend(); }
  bool empty() const { return _M_t.empty(); }
  size_type size() const { return _M_t.size(); }
  size_type max_size() const { return _M_t.max_size(); }
  template <class _KT>
  _Tp& operator[](const _KT& __k) {
    iterator __i = lower_bound(__k);

    if (__i == end() || key_comp()(__k, (*__i).first))
      __i = insert(__i, value_type(__k, _Tp()));
    return (*__i).second;
  }
  void swap(_Self& __x) { _M_t.swap(__x._M_t); }





  pair<iterator,bool> insert(const value_type& __x)
  { return _M_t.insert_unique(__x); }
  iterator insert(iterator __pos, const value_type& __x)
  { return _M_t.insert_unique(__pos, __x); }

  template <class _InputIterator>
  void insert(_InputIterator __first, _InputIterator __last)
  { _M_t.insert_unique(__first, __last); }







  void erase(iterator __pos) { _M_t.erase(__pos); }
  size_type erase(const key_type& __x) { return _M_t.erase_unique(__x); }
  void erase(iterator __first, iterator __last) { _M_t.erase(__first, __last); }
  void clear() { _M_t.clear(); }


  template <class _KT>
  iterator find(const _KT& __x) { return _M_t.find(__x); }
  template <class _KT>
  const_iterator find(const _KT& __x) const { return _M_t.find(__x); }
  template <class _KT>
  size_type count(const _KT& __x) const { return _M_t.find(__x) == _M_t.end() ? 0 : 1; }
  template <class _KT>
  iterator lower_bound(const _KT& __x) { return _M_t.lower_bound(__x); }
  template <class _KT>
  const_iterator lower_bound(const _KT& __x) const { return _M_t.lower_bound(__x); }
  template <class _KT>
  iterator upper_bound(const _KT& __x) { return _M_t.upper_bound(__x); }
  template <class _KT>
  const_iterator upper_bound(const _KT& __x) const { return _M_t.upper_bound(__x); }

  template <class _KT>
  pair<iterator,iterator> equal_range(const _KT& __x)
  { return _M_t.equal_range_unique(__x); }
  template <class _KT>
  pair<const_iterator,const_iterator> equal_range(const _KT& __x) const
  { return _M_t.equal_range_unique(__x); }
};


namespace priv { template <class _Tp> struct _MultimapTraitsT; template <class _Tp> struct _ConstMultimapTraitsT : public ::std::_Const_traits<_Tp> { typedef _ConstMultimapTraitsT<_Tp> _ConstTraits; typedef _MultimapTraitsT<_Tp> _NonConstTraits; }; template <class _Tp> struct _MultimapTraitsT : public ::std::_Nonconst_traits<_Tp> { typedef _ConstMultimapTraitsT<_Tp> _ConstTraits; typedef _MultimapTraitsT<_Tp> _NonConstTraits; }; }

template <class _Key, class _Tp, class _Compare = less<_Key>,
          class _Alloc = allocator< pair < const _Key, _Tp > > >
class multimap



{
  typedef multimap<_Key, _Tp, _Compare, _Alloc> _Self;
public:



  typedef _Key key_type;
  typedef _Tp data_type;
  typedef _Tp mapped_type;
  typedef pair<const _Key, _Tp> value_type;
  typedef _Compare key_compare;

  class value_compare : public binary_function<value_type, value_type, bool> {
    friend class multimap<_Key,_Tp,_Compare,_Alloc>;
  protected:

    _Compare comp;
    value_compare(_Compare __c) : comp(__c) {}
  public:
    bool operator()(const value_type& __x, const value_type& __y) const
    { return comp(__x.first, __y.first); }
  };

protected:

  typedef ::std::priv:: _MultimapTraitsT<value_type> _MultimapTraits;

public:

  typedef ::std::priv:: _Rb_tree<key_type, key_compare,
                              value_type, ::std::priv:: _Select1st< value_type >,
                              _MultimapTraits, _Alloc> _Rep_type;

  typedef typename _Rep_type::pointer pointer;
  typedef typename _Rep_type::const_pointer const_pointer;
  typedef typename _Rep_type::reference reference;
  typedef typename _Rep_type::const_reference const_reference;
  typedef typename _Rep_type::iterator iterator;
  typedef typename _Rep_type::const_iterator const_iterator;
  typedef typename _Rep_type::reverse_iterator reverse_iterator;
  typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
  typedef typename _Rep_type::size_type size_type;
  typedef typename _Rep_type::difference_type difference_type;
  typedef typename _Rep_type::allocator_type allocator_type;

private:
  _Rep_type _M_t;
 

public:

  multimap() : _M_t(_Compare(), allocator_type()) { }
  explicit multimap(const _Compare& __comp,
                    const allocator_type& __a = allocator_type())
    : _M_t(__comp, __a) { }


  template <class _InputIterator>
  multimap(_InputIterator __first, _InputIterator __last)
    : _M_t(_Compare(), allocator_type())
    { _M_t.insert_equal(__first, __last); }






  template <class _InputIterator>
  multimap(_InputIterator __first, _InputIterator __last,
           const _Compare& __comp,
           const allocator_type& __a = allocator_type())
    : _M_t(__comp, __a) { _M_t.insert_equal(__first, __last); }
# 331 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_map.h"
  multimap(const _Self& __x) : _M_t(__x._M_t) {}


  multimap(__move_source<_Self> src)
    : _M_t(__move_source<_Rep_type>(src.get()._M_t)) {}


  _Self& operator=(const _Self& __x) {
    _M_t = __x._M_t;
    return *this;
  }



  key_compare key_comp() const { return _M_t.key_comp(); }
  value_compare value_comp() const { return value_compare(_M_t.key_comp()); }
  allocator_type get_allocator() const { return _M_t.get_allocator(); }

  iterator begin() { return _M_t.begin(); }
  const_iterator begin() const { return _M_t.begin(); }
  iterator end() { return _M_t.end(); }
  const_iterator end() const { return _M_t.end(); }
  reverse_iterator rbegin() { return _M_t.rbegin(); }
  const_reverse_iterator rbegin() const { return _M_t.rbegin(); }
  reverse_iterator rend() { return _M_t.rend(); }
  const_reverse_iterator rend() const { return _M_t.rend(); }
  bool empty() const { return _M_t.empty(); }
  size_type size() const { return _M_t.size(); }
  size_type max_size() const { return _M_t.max_size(); }
  void swap(_Self& __x) { _M_t.swap(__x._M_t); }





  iterator insert(const value_type& __x) { return _M_t.insert_equal(__x); }
  iterator insert(iterator __pos, const value_type& __x) { return _M_t.insert_equal(__pos, __x); }

  template <class _InputIterator>
  void insert(_InputIterator __first, _InputIterator __last)
  { _M_t.insert_equal(__first, __last); }






  void erase(iterator __pos) { _M_t.erase(__pos); }
  size_type erase(const key_type& __x) { return _M_t.erase(__x); }
  void erase(iterator __first, iterator __last) { _M_t.erase(__first, __last); }
  void clear() { _M_t.clear(); }



  template <class _KT>
  iterator find(const _KT& __x) { return _M_t.find(__x); }
  template <class _KT>
  const_iterator find(const _KT& __x) const { return _M_t.find(__x); }
  template <class _KT>
  size_type count(const _KT& __x) const { return _M_t.count(__x); }
  template <class _KT>
  iterator lower_bound(const _KT& __x) { return _M_t.lower_bound(__x); }
  template <class _KT>
  const_iterator lower_bound(const _KT& __x) const { return _M_t.lower_bound(__x); }
  template <class _KT>
  iterator upper_bound(const _KT& __x) { return _M_t.upper_bound(__x); }
  template <class _KT>
  const_iterator upper_bound(const _KT& __x) const { return _M_t.upper_bound(__x); }
  template <class _KT>
  pair<iterator,iterator> equal_range(const _KT& __x)
  { return _M_t.equal_range(__x); }
  template <class _KT>
  pair<const_iterator,const_iterator> equal_range(const _KT& __x) const
  { return _M_t.equal_range(__x); }
};



# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_relops_cont.h" 1





template <class _Key, class _Tp, class _Compare, class _Alloc>
inline bool operator==(const map<_Key,_Tp,_Compare,_Alloc>& __x,
                                  const map<_Key,_Tp,_Compare,_Alloc>& __y) {
  return __x.size() == __y.size() &&
         equal(__x.begin(), __x.end(), __y.begin());
}


template <class _Key, class _Tp, class _Compare, class _Alloc>
inline bool operator<(const map<_Key,_Tp,_Compare,_Alloc>& __x,
                                 const map<_Key,_Tp,_Compare,_Alloc>& __y) {
  return lexicographical_compare(__x.begin(), __x.end(),
                                 __y.begin(), __y.end());
}

template <class _Key, class _Tp, class _Compare, class _Alloc> inline bool operator!=(const map<_Key,_Tp,_Compare,_Alloc>& __x, const map<_Key,_Tp,_Compare,_Alloc>& __y) {return !(__x == __y);}template <class _Key, class _Tp, class _Compare, class _Alloc> inline bool operator>(const map<_Key,_Tp,_Compare,_Alloc>& __x, const map<_Key,_Tp,_Compare,_Alloc>& __y) {return __y < __x;}template <class _Key, class _Tp, class _Compare, class _Alloc> inline bool operator<=(const map<_Key,_Tp,_Compare,_Alloc>& __x, const map<_Key,_Tp,_Compare,_Alloc>& __y) { return !(__y < __x);}template <class _Key, class _Tp, class _Compare, class _Alloc> inline bool operator>=(const map<_Key,_Tp,_Compare,_Alloc>& __x, const map<_Key,_Tp,_Compare,_Alloc>& __y) { return !(__x < __y);}


template <class _Key, class _Tp, class _Compare, class _Alloc>
inline void swap(map<_Key,_Tp,_Compare,_Alloc>& __x,
                            map<_Key,_Tp,_Compare,_Alloc>& __y) {
  __x.swap(__y);
}
# 410 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_map.h" 2


# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_relops_cont.h" 1





template <class _Key, class _Tp, class _Compare, class _Alloc>
inline bool operator==(const multimap<_Key,_Tp,_Compare,_Alloc>& __x,
                                  const multimap<_Key,_Tp,_Compare,_Alloc>& __y) {
  return __x.size() == __y.size() &&
         equal(__x.begin(), __x.end(), __y.begin());
}


template <class _Key, class _Tp, class _Compare, class _Alloc>
inline bool operator<(const multimap<_Key,_Tp,_Compare,_Alloc>& __x,
                                 const multimap<_Key,_Tp,_Compare,_Alloc>& __y) {
  return lexicographical_compare(__x.begin(), __x.end(),
                                 __y.begin(), __y.end());
}

template <class _Key, class _Tp, class _Compare, class _Alloc> inline bool operator!=(const multimap<_Key,_Tp,_Compare,_Alloc>& __x, const multimap<_Key,_Tp,_Compare,_Alloc>& __y) {return !(__x == __y);}template <class _Key, class _Tp, class _Compare, class _Alloc> inline bool operator>(const multimap<_Key,_Tp,_Compare,_Alloc>& __x, const multimap<_Key,_Tp,_Compare,_Alloc>& __y) {return __y < __x;}template <class _Key, class _Tp, class _Compare, class _Alloc> inline bool operator<=(const multimap<_Key,_Tp,_Compare,_Alloc>& __x, const multimap<_Key,_Tp,_Compare,_Alloc>& __y) { return !(__y < __x);}template <class _Key, class _Tp, class _Compare, class _Alloc> inline bool operator>=(const multimap<_Key,_Tp,_Compare,_Alloc>& __x, const multimap<_Key,_Tp,_Compare,_Alloc>& __y) { return !(__x < __y);}


template <class _Key, class _Tp, class _Compare, class _Alloc>
inline void swap(multimap<_Key,_Tp,_Compare,_Alloc>& __x,
                            multimap<_Key,_Tp,_Compare,_Alloc>& __y) {
  __x.swap(__y);
}
# 413 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_map.h" 2




template <class _Key, class _Tp, class _Compare, class _Alloc>
struct __move_traits<map<_Key,_Tp,_Compare,_Alloc> > :
  ::std::priv:: __move_traits_aux<typename map<_Key,_Tp,_Compare,_Alloc>::_Rep_type>
{};

template <class _Key, class _Tp, class _Compare, class _Alloc>
struct __move_traits<multimap<_Key,_Tp,_Compare,_Alloc> > :
  ::std::priv:: __move_traits_aux<typename multimap<_Key,_Tp,_Compare,_Alloc>::_Rep_type>
{};


}
# 37 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/map" 2
# 49 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/map"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_epilog.h" 1
# 19 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_epilog.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_config_compat_post.h" 1
# 20 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_epilog.h" 2
# 50 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/map" 2
# 40 "webkey-2.09/service/webkey.cpp" 2
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/algorithm" 1
# 30 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/algorithm"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_prolog.h" 1






# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_cprolog.h" 1
# 8 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_prolog.h" 2
# 31 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/algorithm" 2
# 41 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/algorithm"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_algo.h" 1
# 38 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_algo.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_heap.h" 1
# 33 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_heap.h"
namespace std {



template <class _RandomAccessIterator>
void
push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last);


template <class _RandomAccessIterator, class _Compare>
void
push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
          _Compare __comp);

template <class _RandomAccessIterator, class _Distance, class _Tp>
void
__adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
              _Distance __len, _Tp __val);

template <class _RandomAccessIterator, class _Tp, class _Distance>
inline void
__pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
           _RandomAccessIterator __result, _Tp __val, _Distance*)
{
  *__result = *__first;
  __adjust_heap(__first, _Distance(0), _Distance(__last - __first), __val);
}

template <class _RandomAccessIterator>
void pop_heap(_RandomAccessIterator __first,
        _RandomAccessIterator __last);

template <class _RandomAccessIterator, class _Distance,
          class _Tp, class _Compare>
void
__adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
              _Distance __len, _Tp __val, _Compare __comp);

template <class _RandomAccessIterator, class _Tp, class _Compare,
          class _Distance>
inline void
__pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
           _RandomAccessIterator __result, _Tp __val, _Compare __comp,
           _Distance*)
{
  *__result = *__first;
  __adjust_heap(__first, _Distance(0), _Distance(__last - __first),
                __val, __comp);
}

template <class _RandomAccessIterator, class _Compare>
void
pop_heap(_RandomAccessIterator __first,
         _RandomAccessIterator __last, _Compare __comp);

template <class _RandomAccessIterator>
void
make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last);

template <class _RandomAccessIterator, class _Compare>
void
make_heap(_RandomAccessIterator __first,
          _RandomAccessIterator __last, _Compare __comp);

template <class _RandomAccessIterator>
inline
void sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
  while (__last - __first > 1)
    pop_heap(__first, __last--);
}

template <class _RandomAccessIterator, class _Compare>
inline
void
sort_heap(_RandomAccessIterator __first,
          _RandomAccessIterator __last, _Compare __comp)
{
  while (__last - __first > 1)
    pop_heap(__first, __last--, __comp);
}

}


# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_heap.c" 1
# 37 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_heap.c"
namespace std {

template <class _RandomAccessIterator, class _Distance, class _Tp>
inline
void
__push_heap(_RandomAccessIterator __first,
            _Distance __holeIndex, _Distance __topIndex, _Tp __val)
{
  _Distance __parent = (__holeIndex - 1) / 2;
  while (__holeIndex > __topIndex && *(__first + __parent) < __val) {
    *(__first + __holeIndex) = *(__first + __parent);
    __holeIndex = __parent;
    __parent = (__holeIndex - 1) / 2;
  }
  *(__first + __holeIndex) = __val;
}

template <class _RandomAccessIterator, class _Distance, class _Tp>
inline void
__push_heap_aux(_RandomAccessIterator __first,
                _RandomAccessIterator __last, _Distance*, _Tp*)
{
  __push_heap(__first, _Distance((__last - __first) - 1), _Distance(0),
              _Tp(*(__last - 1)));
}

template <class _RandomAccessIterator>
void
push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
  __push_heap_aux(__first, __last,
                  (typename ::std::iterator_traits< _RandomAccessIterator >::difference_type*)0, (typename ::std::iterator_traits< _RandomAccessIterator >::value_type*)0);
}


template <class _RandomAccessIterator, class _Distance, class _Tp,
          class _Compare>
inline
void
__push_heap(_RandomAccessIterator __first, _Distance __holeIndex,
            _Distance __topIndex, _Tp __val, _Compare __comp)
{
  _Distance __parent = (__holeIndex - 1) / 2;
  while (__holeIndex > __topIndex && __comp(*(__first + __parent), __val)) {
   
    *(__first + __holeIndex) = *(__first + __parent);
    __holeIndex = __parent;
    __parent = (__holeIndex - 1) / 2;
  }
  *(__first + __holeIndex) = __val;
}

template <class _RandomAccessIterator, class _Compare,
          class _Distance, class _Tp>
inline void
__push_heap_aux(_RandomAccessIterator __first,
                _RandomAccessIterator __last, _Compare __comp,
                _Distance*, _Tp*)
{
  __push_heap(__first, _Distance((__last - __first) - 1), _Distance(0),
              _Tp(*(__last - 1)), __comp);
}

template <class _RandomAccessIterator, class _Compare>
void
push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
          _Compare __comp)
{
  __push_heap_aux(__first, __last, __comp,
                  (typename ::std::iterator_traits< _RandomAccessIterator >::difference_type*)0, (typename ::std::iterator_traits< _RandomAccessIterator >::value_type*)0);
}

template <class _RandomAccessIterator, class _Distance, class _Tp>
void
__adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
              _Distance __len, _Tp __val) {
  _Distance __topIndex = __holeIndex;
  _Distance __secondChild = 2 * __holeIndex + 2;
  while (__secondChild < __len) {
    if (*(__first + __secondChild) < *(__first + (__secondChild - 1)))
      __secondChild--;
    *(__first + __holeIndex) = *(__first + __secondChild);
    __holeIndex = __secondChild;
    __secondChild = 2 * (__secondChild + 1);
  }
  if (__secondChild == __len) {
    *(__first + __holeIndex) = *(__first + (__secondChild - 1));
    __holeIndex = __secondChild - 1;
  }
  __push_heap(__first, __holeIndex, __topIndex, __val);
}


template <class _RandomAccessIterator, class _Tp>
inline void
__pop_heap_aux(_RandomAccessIterator __first, _RandomAccessIterator __last, _Tp*) {
  __pop_heap(__first, __last - 1, __last - 1,
             _Tp(*(__last - 1)), (typename ::std::iterator_traits< _RandomAccessIterator >::difference_type*)0);
}

template <class _RandomAccessIterator>
void pop_heap(_RandomAccessIterator __first,
        _RandomAccessIterator __last) {
  __pop_heap_aux(__first, __last, (typename ::std::iterator_traits< _RandomAccessIterator >::value_type*)0);
}

template <class _RandomAccessIterator, class _Distance,
          class _Tp, class _Compare>
void
__adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
              _Distance __len, _Tp __val, _Compare __comp)
{
  _Distance __topIndex = __holeIndex;
  _Distance __secondChild = 2 * __holeIndex + 2;
  while (__secondChild < __len) {
    if (__comp(*(__first + __secondChild), *(__first + (__secondChild - 1)))) {
     

      __secondChild--;
    }
    *(__first + __holeIndex) = *(__first + __secondChild);
    __holeIndex = __secondChild;
    __secondChild = 2 * (__secondChild + 1);
  }
  if (__secondChild == __len) {
    *(__first + __holeIndex) = *(__first + (__secondChild - 1));
    __holeIndex = __secondChild - 1;
  }
  __push_heap(__first, __holeIndex, __topIndex, __val, __comp);
}


template <class _RandomAccessIterator, class _Tp, class _Compare>
inline void
__pop_heap_aux(_RandomAccessIterator __first,
               _RandomAccessIterator __last, _Tp*, _Compare __comp)
{
  __pop_heap(__first, __last - 1, __last - 1, _Tp(*(__last - 1)), __comp,
             (typename ::std::iterator_traits< _RandomAccessIterator >::difference_type*)0);
}


template <class _RandomAccessIterator, class _Compare>
void
pop_heap(_RandomAccessIterator __first,
         _RandomAccessIterator __last, _Compare __comp)
{
    __pop_heap_aux(__first, __last, (typename ::std::iterator_traits< _RandomAccessIterator >::value_type*)0, __comp);
}

template <class _RandomAccessIterator, class _Tp, class _Distance>
inline
void
__make_heap(_RandomAccessIterator __first,
            _RandomAccessIterator __last, _Tp*, _Distance*)
{
  if (__last - __first < 2) return;
  _Distance __len = __last - __first;
  _Distance __parent = (__len - 2)/2;

  for (;;) {
    __adjust_heap(__first, __parent, __len, _Tp(*(__first + __parent)));
    if (__parent == 0) return;
    __parent--;
  }
}

template <class _RandomAccessIterator>
void
make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
{
  __make_heap(__first, __last,
              (typename ::std::iterator_traits< _RandomAccessIterator >::value_type*)0, (typename ::std::iterator_traits< _RandomAccessIterator >::difference_type*)0);
}

template <class _RandomAccessIterator, class _Compare,
          class _Tp, class _Distance>
inline
void
__make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
            _Compare __comp, _Tp*, _Distance*)
{
  if (__last - __first < 2) return;
  _Distance __len = __last - __first;
  _Distance __parent = (__len - 2)/2;

  for (;;) {
    __adjust_heap(__first, __parent, __len, _Tp(*(__first + __parent)),
                  __comp);
    if (__parent == 0) return;
    __parent--;
  }
}

template <class _RandomAccessIterator, class _Compare>
void
make_heap(_RandomAccessIterator __first,
          _RandomAccessIterator __last, _Compare __comp)
{
  __make_heap(__first, __last, __comp,
              (typename ::std::iterator_traits< _RandomAccessIterator >::value_type*)0, (typename ::std::iterator_traits< _RandomAccessIterator >::difference_type*)0);
}

}
# 119 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_heap.h" 2
# 39 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_algo.h" 2
# 54 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_algo.h"
namespace std {


template <class _InputIter, class _Function>
inline _Function
for_each(_InputIter __first, _InputIter __last, _Function __f) {
  for ( ; __first != __last; ++__first)
    __f(*__first);
  return __f;
}


template <class _InputIter, class _Predicate>
inline typename iterator_traits<_InputIter>::difference_type
count_if(_InputIter __first, _InputIter __last, _Predicate __pred) {
 
  typename iterator_traits<_InputIter>::difference_type __n = 0;
  for ( ; __first != __last; ++__first) {
    if (__pred(*__first))
      ++__n;
  }
  return __n;
}



template <class _ForwardIter, class _BinaryPredicate>
inline _ForwardIter
adjacent_find(_ForwardIter __first, _ForwardIter __last,
              _BinaryPredicate __binary_pred) {
 
  if (__first == __last)
    return __last;
  _ForwardIter __next = __first;
  while(++__next != __last) {
    if (__binary_pred(*__first, *__next))
      return __first;
    __first = __next;
  }
  return __last;
}

template <class _ForwardIter>
inline _ForwardIter
adjacent_find(_ForwardIter __first, _ForwardIter __last) {
  return adjacent_find(__first, __last,
                       ::std::priv:: __equal_to((typename ::std::iterator_traits< _ForwardIter >::value_type*)0));
}


template <class _InputIter, class _Tp, class _Size>
inline void
count(_InputIter __first, _InputIter __last, const _Tp& __val, _Size& __n) {
 
    for ( ; __first != __last; ++__first)
      if (*__first == __val)
        ++__n;
}

template <class _InputIter, class _Predicate, class _Size>
inline void
count_if(_InputIter __first, _InputIter __last, _Predicate __pred, _Size& __n) {
 
  for ( ; __first != __last; ++__first)
    if (__pred(*__first))
      ++__n;
}


template <class _ForwardIter1, class _ForwardIter2>
_ForwardIter1 search(_ForwardIter1 __first1, _ForwardIter1 __last1,
                     _ForwardIter2 __first2, _ForwardIter2 __last2);


template <class _ForwardIter, class _Integer, class _Tp>
_ForwardIter search_n(_ForwardIter __first, _ForwardIter __last,
                      _Integer __count, const _Tp& __val);
template <class _ForwardIter, class _Integer, class _Tp, class _BinaryPred>
_ForwardIter search_n(_ForwardIter __first, _ForwardIter __last,
                      _Integer __count, const _Tp& __val, _BinaryPred __binary_pred);

template <class _InputIter, class _ForwardIter>
inline _InputIter find_first_of(_InputIter __first1, _InputIter __last1,
                                _ForwardIter __first2, _ForwardIter __last2) {
 
 
  return ::std::priv:: __find_first_of(__first1, __last1, __first2, __last2);
}

template <class _InputIter, class _ForwardIter, class _BinaryPredicate>
inline _InputIter
find_first_of(_InputIter __first1, _InputIter __last1,
              _ForwardIter __first2, _ForwardIter __last2, _BinaryPredicate __comp) {
 
 
  return ::std::priv:: __find_first_of(__first1, __last1, __first2, __last2, __comp);
}

template <class _ForwardIter1, class _ForwardIter2>
_ForwardIter1
find_end(_ForwardIter1 __first1, _ForwardIter1 __last1,
         _ForwardIter2 __first2, _ForwardIter2 __last2);


template <class _ForwardIter1, class _ForwardIter2>
inline _ForwardIter2
swap_ranges(_ForwardIter1 __first1, _ForwardIter1 __last1, _ForwardIter2 __first2) {
 
  for ( ; __first1 != __last1; ++__first1, ++__first2)
    iter_swap(__first1, __first2);
  return __first2;
}


template <class _InputIter, class _OutputIter, class _UnaryOperation>
inline _OutputIter
transform(_InputIter __first, _InputIter __last, _OutputIter __result, _UnaryOperation __opr) {
 
  for ( ; __first != __last; ++__first, ++__result)
    *__result = __opr(*__first);
  return __result;
}
template <class _InputIter1, class _InputIter2, class _OutputIter, class _BinaryOperation>
inline _OutputIter
transform(_InputIter1 __first1, _InputIter1 __last1,
          _InputIter2 __first2, _OutputIter __result,_BinaryOperation __binary_op) {
 
  for ( ; __first1 != __last1; ++__first1, ++__first2, ++__result)
    *__result = __binary_op(*__first1, *__first2);
  return __result;
}



template <class _ForwardIter, class _Predicate, class _Tp>
inline void
replace_if(_ForwardIter __first, _ForwardIter __last, _Predicate __pred, const _Tp& __new_value) {
 
  for ( ; __first != __last; ++__first)
    if (__pred(*__first))
      *__first = __new_value;
}

template <class _InputIter, class _OutputIter, class _Tp>
inline _OutputIter
replace_copy(_InputIter __first, _InputIter __last,_OutputIter __result,
             const _Tp& __old_value, const _Tp& __new_value) {
 
  for ( ; __first != __last; ++__first, ++__result)
    *__result = *__first == __old_value ? __new_value : *__first;
  return __result;
}

template <class _Iterator, class _OutputIter, class _Predicate, class _Tp>
inline _OutputIter
replace_copy_if(_Iterator __first, _Iterator __last,
                _OutputIter __result,
                _Predicate __pred, const _Tp& __new_value) {
 
  for ( ; __first != __last; ++__first, ++__result)
    *__result = __pred(*__first) ? __new_value : *__first;
  return __result;
}



template <class _ForwardIter, class _Generator>
inline void
generate(_ForwardIter __first, _ForwardIter __last, _Generator __gen) {
 
  for ( ; __first != __last; ++__first)
    *__first = __gen();
}

template <class _OutputIter, class _Size, class _Generator>
inline void
generate_n(_OutputIter __first, _Size __n, _Generator __gen) {
  for ( ; __n > 0; --__n, ++__first)
    *__first = __gen();
}



template <class _InputIter, class _OutputIter, class _Tp>
inline _OutputIter
remove_copy(_InputIter __first, _InputIter __last,_OutputIter __result, const _Tp& __val) {
 
  for ( ; __first != __last; ++__first) {
    if (!(*__first == __val)) {
      *__result = *__first;
      ++__result;
    }
  }
  return __result;
}

template <class _InputIter, class _OutputIter, class _Predicate>
inline _OutputIter
remove_copy_if(_InputIter __first, _InputIter __last, _OutputIter __result, _Predicate __pred) {
 
  for ( ; __first != __last; ++__first) {
    if (!__pred(*__first)) {
      *__result = *__first;
      ++__result;
    }
  }
  return __result;
}

template <class _ForwardIter, class _Tp>
inline _ForwardIter
remove(_ForwardIter __first, _ForwardIter __last, const _Tp& __val) {
 
  __first = find(__first, __last, __val);
  if (__first == __last)
    return __first;
  else {
    _ForwardIter __next = __first;
    return remove_copy(++__next, __last, __first, __val);
  }
}

template <class _ForwardIter, class _Predicate>
inline _ForwardIter
remove_if(_ForwardIter __first, _ForwardIter __last, _Predicate __pred) {
 
  __first = find_if(__first, __last, __pred);
  if ( __first == __last )
    return __first;
  else {
    _ForwardIter __next = __first;
    return remove_copy_if(++__next, __last, __first, __pred);
  }
}


template <class _InputIter, class _OutputIter>
_OutputIter unique_copy(_InputIter __first, _InputIter __last, _OutputIter __result);

template <class _InputIter, class _OutputIter, class _BinaryPredicate>
_OutputIter unique_copy(_InputIter __first, _InputIter __last,_OutputIter __result,
                        _BinaryPredicate __binary_pred);

template <class _ForwardIter>
inline _ForwardIter unique(_ForwardIter __first, _ForwardIter __last) {
  __first = adjacent_find(__first, __last);
  return unique_copy(__first, __last, __first);
}

template <class _ForwardIter, class _BinaryPredicate>
inline _ForwardIter unique(_ForwardIter __first, _ForwardIter __last,
                           _BinaryPredicate __binary_pred) {
  __first = adjacent_find(__first, __last, __binary_pred);
  return unique_copy(__first, __last, __first, __binary_pred);
}



namespace priv {

template <class _BidirectionalIter>
inline void
__reverse(_BidirectionalIter __first, _BidirectionalIter __last, const bidirectional_iterator_tag &) {
  for (; __first != __last && __first != --__last; ++__first)
    ::std::iter_swap(__first,__last);
}

template <class _RandomAccessIter>
inline void
__reverse(_RandomAccessIter __first, _RandomAccessIter __last, const random_access_iterator_tag &) {
  for (; __first < __last; ++__first)
    ::std::iter_swap(__first, --__last);
}

}

template <class _BidirectionalIter>
inline void
reverse(_BidirectionalIter __first, _BidirectionalIter __last) {
 
  ::std::priv:: __reverse(__first, __last, typename ::std::iterator_traits< _BidirectionalIter >::iterator_category());
}

template <class _BidirectionalIter, class _OutputIter>
inline
_OutputIter reverse_copy(_BidirectionalIter __first,
                         _BidirectionalIter __last,
                         _OutputIter __result) {
 
  while (__first != __last) {
    --__last;
    *__result = *__last;
    ++__result;
  }
  return __result;
}

template <class _ForwardIter>
void rotate(_ForwardIter __first, _ForwardIter __middle, _ForwardIter __last);

template <class _ForwardIter, class _OutputIter>
inline _OutputIter rotate_copy(_ForwardIter __first, _ForwardIter __middle,
                               _ForwardIter __last, _OutputIter __result) {
  return ::std::copy(__first, __middle, copy(__middle, __last, __result));
}



template <class _RandomAccessIter>
void random_shuffle(_RandomAccessIter __first, _RandomAccessIter __last);

template <class _RandomAccessIter, class _RandomNumberGenerator>
void random_shuffle(_RandomAccessIter __first, _RandomAccessIter __last,
                    _RandomNumberGenerator& __rand);




template <class _ForwardIter, class _OutputIter, class _Distance>
_OutputIter random_sample_n(_ForwardIter __first, _ForwardIter __last,
                            _OutputIter __out_ite, const _Distance __n);

template <class _ForwardIter, class _OutputIter, class _Distance,
          class _RandomNumberGenerator>
_OutputIter random_sample_n(_ForwardIter __first, _ForwardIter __last,
                            _OutputIter __out_ite, const _Distance __n,
                            _RandomNumberGenerator& __rand);

template <class _InputIter, class _RandomAccessIter>
_RandomAccessIter
random_sample(_InputIter __first, _InputIter __last,
              _RandomAccessIter __out_first, _RandomAccessIter __out_last);

template <class _InputIter, class _RandomAccessIter,
          class _RandomNumberGenerator>
_RandomAccessIter
random_sample(_InputIter __first, _InputIter __last,
              _RandomAccessIter __out_first, _RandomAccessIter __out_last,
              _RandomNumberGenerator& __rand);





template <class _ForwardIter, class _Predicate>
_ForwardIter partition(_ForwardIter __first, _ForwardIter __last, _Predicate __pred);

template <class _ForwardIter, class _Predicate>
_ForwardIter
stable_partition(_ForwardIter __first, _ForwardIter __last, _Predicate __pred);


namespace priv {

template <class _Size>
inline _Size __lg(_Size __n) {
  _Size __k;
  for (__k = 0; __n != 1; __n >>= 1) ++__k;
  return __k;
}

}

template <class _RandomAccessIter>
void sort(_RandomAccessIter __first, _RandomAccessIter __last);
template <class _RandomAccessIter, class _Compare>
void sort(_RandomAccessIter __first, _RandomAccessIter __last, _Compare __comp);


template <class _RandomAccessIter>
void stable_sort(_RandomAccessIter __first,
                 _RandomAccessIter __last);

template <class _RandomAccessIter, class _Compare>
void stable_sort(_RandomAccessIter __first,
                 _RandomAccessIter __last, _Compare __comp);



template <class _RandomAccessIter>
void partial_sort(_RandomAccessIter __first, _RandomAccessIter __middle,
                  _RandomAccessIter __last);

template <class _RandomAccessIter, class _Compare>
void partial_sort(_RandomAccessIter __first,_RandomAccessIter __middle,
                  _RandomAccessIter __last, _Compare __comp);

template <class _InputIter, class _RandomAccessIter>
_RandomAccessIter
partial_sort_copy(_InputIter __first, _InputIter __last,
                  _RandomAccessIter __result_first, _RandomAccessIter __result_last);

template <class _InputIter, class _RandomAccessIter, class _Compare>
_RandomAccessIter
partial_sort_copy(_InputIter __first, _InputIter __last,
                  _RandomAccessIter __result_first,
                  _RandomAccessIter __result_last, _Compare __comp);


template <class _RandomAccessIter>
void nth_element(_RandomAccessIter __first, _RandomAccessIter __nth,
                 _RandomAccessIter __last);

template <class _RandomAccessIter, class _Compare>
void nth_element(_RandomAccessIter __first, _RandomAccessIter __nth,
                 _RandomAccessIter __last, _Compare __comp);


namespace priv {

template <class _T1, class _T2>
struct __less_2 {
  bool operator() (const _T1& __x, const _T2& __y) const { return __x < __y ; }
};

template <class _T1, class _T2>
__less_2<_T1,_T2> __less2(_T1*, _T2* ) { return __less_2<_T1, _T2>(); }






}


template <class _ForwardIter, class _Tp>
inline _ForwardIter lower_bound(_ForwardIter __first, _ForwardIter __last,
                                   const _Tp& __val) {
 
  return ::std::priv:: __lower_bound(__first, __last, __val,
                                  ::std::priv:: __less2((typename ::std::iterator_traits< _ForwardIter >::value_type*)0, (_Tp*)0),
                                  ::std::priv:: __less2((_Tp*)0, (typename ::std::iterator_traits< _ForwardIter >::value_type*)0),
                                  (typename ::std::iterator_traits< _ForwardIter >::difference_type*)0);
}

template <class _ForwardIter, class _Tp, class _Compare>
inline _ForwardIter lower_bound(_ForwardIter __first, _ForwardIter __last,
                                const _Tp& __val, _Compare __comp) {
 
  return ::std::priv:: __lower_bound(__first, __last, __val, __comp, __comp,
                                  (typename ::std::iterator_traits< _ForwardIter >::difference_type*)0);
}

namespace priv {

template <class _ForwardIter, class _Tp, class _Compare1, class _Compare2, class _Distance>
_ForwardIter __upper_bound(_ForwardIter __first, _ForwardIter __last, const _Tp& __val,
                           _Compare1 __comp1, _Compare2 __comp2, _Distance*);

}

template <class _ForwardIter, class _Tp>
inline _ForwardIter upper_bound(_ForwardIter __first, _ForwardIter __last,
                                const _Tp& __val) {
 
  return ::std::priv:: __upper_bound(__first, __last, __val,
                                  ::std::priv:: __less2((typename ::std::iterator_traits< _ForwardIter >::value_type*)0, (_Tp*)0),
                                  ::std::priv:: __less2((_Tp*)0, (typename ::std::iterator_traits< _ForwardIter >::value_type*)0),
                                  (typename ::std::iterator_traits< _ForwardIter >::difference_type*)0);
}

template <class _ForwardIter, class _Tp, class _Compare>
inline _ForwardIter upper_bound(_ForwardIter __first, _ForwardIter __last,
                                const _Tp& __val, _Compare __comp) {
 
  return ::std::priv:: __upper_bound(__first, __last, __val, __comp, __comp,
                                  (typename ::std::iterator_traits< _ForwardIter >::difference_type*)0);
}

namespace priv {

template <class _ForwardIter, class _Tp, class _Compare1, class _Compare2, class _Distance>
pair<_ForwardIter, _ForwardIter>
__equal_range(_ForwardIter __first, _ForwardIter __last, const _Tp& __val,
              _Compare1 __comp1, _Compare2 __comp2, _Distance*);

}

template <class _ForwardIter, class _Tp>
inline pair<_ForwardIter, _ForwardIter>
equal_range(_ForwardIter __first, _ForwardIter __last, const _Tp& __val) {
 
  return ::std::priv:: __equal_range(__first, __last, __val,
                                  ::std::priv:: __less2((typename ::std::iterator_traits< _ForwardIter >::value_type*)0, (_Tp*)0),
                                  ::std::priv:: __less2((_Tp*)0, (typename ::std::iterator_traits< _ForwardIter >::value_type*)0),
                                  (typename ::std::iterator_traits< _ForwardIter >::difference_type*)0);
}

template <class _ForwardIter, class _Tp, class _Compare>
inline pair<_ForwardIter, _ForwardIter>
equal_range(_ForwardIter __first, _ForwardIter __last, const _Tp& __val,
            _Compare __comp) {
 
  return ::std::priv:: __equal_range(__first, __last, __val, __comp, __comp,
                                  (typename ::std::iterator_traits< _ForwardIter >::difference_type*)0);
}

template <class _ForwardIter, class _Tp>
inline bool binary_search(_ForwardIter __first, _ForwardIter __last,
                   const _Tp& __val) {
 
  _ForwardIter __i = ::std::priv:: __lower_bound(__first, __last, __val,
                                              ::std::priv:: __less2((typename ::std::iterator_traits< _ForwardIter >::value_type*)0, (_Tp*)0),
                                              ::std::priv:: __less2((_Tp*)0, (typename ::std::iterator_traits< _ForwardIter >::value_type*)0),
                                              (typename ::std::iterator_traits< _ForwardIter >::difference_type*)0);
  return __i != __last && !(__val < *__i);
}

template <class _ForwardIter, class _Tp, class _Compare>
inline bool binary_search(_ForwardIter __first, _ForwardIter __last,
                          const _Tp& __val,
                          _Compare __comp) {
 
  _ForwardIter __i = ::std::priv:: __lower_bound(__first, __last, __val, __comp, __comp,
                                              (typename ::std::iterator_traits< _ForwardIter >::difference_type*)0);
  return __i != __last && !__comp(__val, *__i);
}



template <class _InputIter1, class _InputIter2, class _OutputIter>
_OutputIter merge(_InputIter1 __first1, _InputIter1 __last1,
                  _InputIter2 __first2, _InputIter2 __last2,
                  _OutputIter __result);

template <class _InputIter1, class _InputIter2, class _OutputIter,
          class _Compare>
_OutputIter merge(_InputIter1 __first1, _InputIter1 __last1,
                  _InputIter2 __first2, _InputIter2 __last2,
                  _OutputIter __result, _Compare __comp);





template <class _BidirectionalIter>
void inplace_merge(_BidirectionalIter __first,
                   _BidirectionalIter __middle,
                   _BidirectionalIter __last) ;

template <class _BidirectionalIter, class _Compare>
void inplace_merge(_BidirectionalIter __first,
                   _BidirectionalIter __middle,
                   _BidirectionalIter __last, _Compare __comp);






template <class _InputIter1, class _InputIter2>
bool includes(_InputIter1 __first1, _InputIter1 __last1,
              _InputIter2 __first2, _InputIter2 __last2);

template <class _InputIter1, class _InputIter2, class _Compare>
bool includes(_InputIter1 __first1, _InputIter1 __last1,
              _InputIter2 __first2, _InputIter2 __last2, _Compare __comp);

template <class _InputIter1, class _InputIter2, class _OutputIter>
_OutputIter set_union(_InputIter1 __first1, _InputIter1 __last1,
                      _InputIter2 __first2, _InputIter2 __last2,
                      _OutputIter __result);

template <class _InputIter1, class _InputIter2, class _OutputIter,
          class _Compare>
_OutputIter set_union(_InputIter1 __first1, _InputIter1 __last1,
                      _InputIter2 __first2, _InputIter2 __last2,
                      _OutputIter __result, _Compare __comp);

template <class _InputIter1, class _InputIter2, class _OutputIter>
_OutputIter set_intersection(_InputIter1 __first1, _InputIter1 __last1,
                             _InputIter2 __first2, _InputIter2 __last2,
                             _OutputIter __result);

template <class _InputIter1, class _InputIter2, class _OutputIter,
          class _Compare>
_OutputIter set_intersection(_InputIter1 __first1, _InputIter1 __last1,
                             _InputIter2 __first2, _InputIter2 __last2,
                             _OutputIter __result, _Compare __comp);



template <class _InputIter1, class _InputIter2, class _OutputIter>
_OutputIter set_difference(_InputIter1 __first1, _InputIter1 __last1,
                           _InputIter2 __first2, _InputIter2 __last2,
                           _OutputIter __result);

template <class _InputIter1, class _InputIter2, class _OutputIter,
          class _Compare>
_OutputIter set_difference(_InputIter1 __first1, _InputIter1 __last1,
                           _InputIter2 __first2, _InputIter2 __last2,
                           _OutputIter __result, _Compare __comp);

template <class _InputIter1, class _InputIter2, class _OutputIter>
_OutputIter
set_symmetric_difference(_InputIter1 __first1, _InputIter1 __last1,
                         _InputIter2 __first2, _InputIter2 __last2,
                         _OutputIter __result);


template <class _InputIter1, class _InputIter2, class _OutputIter,
          class _Compare>
_OutputIter
set_symmetric_difference(_InputIter1 __first1, _InputIter1 __last1,
                         _InputIter2 __first2, _InputIter2 __last2,
                         _OutputIter __result,
                         _Compare __comp);





template <class _ForwardIter>
_ForwardIter max_element(_ForwardIter __first, _ForwardIter __last);
template <class _ForwardIter, class _Compare>
_ForwardIter max_element(_ForwardIter __first, _ForwardIter __last,
                            _Compare __comp);

template <class _ForwardIter>
_ForwardIter min_element(_ForwardIter __first, _ForwardIter __last);

template <class _ForwardIter, class _Compare>
_ForwardIter min_element(_ForwardIter __first, _ForwardIter __last,
                            _Compare __comp);




template <class _BidirectionalIter>
bool next_permutation(_BidirectionalIter __first, _BidirectionalIter __last);

template <class _BidirectionalIter, class _Compare>
bool next_permutation(_BidirectionalIter __first, _BidirectionalIter __last,
                      _Compare __comp);


template <class _BidirectionalIter>
bool prev_permutation(_BidirectionalIter __first, _BidirectionalIter __last);


template <class _BidirectionalIter, class _Compare>
bool prev_permutation(_BidirectionalIter __first, _BidirectionalIter __last,
                      _Compare __comp);






template <class _RandomAccessIter>
bool is_heap(_RandomAccessIter __first, _RandomAccessIter __last);

template <class _RandomAccessIter, class _StrictWeakOrdering>
bool is_heap(_RandomAccessIter __first, _RandomAccessIter __last,
             _StrictWeakOrdering __comp);




namespace priv {

template <class _ForwardIter, class _StrictWeakOrdering>
bool __is_sorted(_ForwardIter __first, _ForwardIter __last,
                 _StrictWeakOrdering __comp);

}
template <class _ForwardIter>
inline bool is_sorted(_ForwardIter __first, _ForwardIter __last) {
  return ::std::priv:: __is_sorted(__first, __last,
                                ::std::priv:: __less((typename ::std::iterator_traits< _ForwardIter >::value_type*)0));
}

template <class _ForwardIter, class _StrictWeakOrdering>
inline bool is_sorted(_ForwardIter __first, _ForwardIter __last,
                      _StrictWeakOrdering __comp) {
  return ::std::priv:: __is_sorted(__first, __last, __comp);
}


}


# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_algo.c" 1
# 34 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_algo.c"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_tempbuf.h" 1
# 45 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_tempbuf.h"
namespace std {

template <class _Tp>
pair<_Tp*, ptrdiff_t>
__get_temporary_buffer(ptrdiff_t __len, _Tp*);



template <class _Tp>
inline pair<_Tp*, ptrdiff_t> get_temporary_buffer(ptrdiff_t __len) {
  return __get_temporary_buffer(__len, (_Tp*) 0);
}







template <class _Tp>
inline pair<_Tp*, ptrdiff_t>
get_temporary_buffer(ptrdiff_t __len, _Tp*) {
  return __get_temporary_buffer(__len, (_Tp*) 0);
}



template <class _Tp>
inline void return_temporary_buffer(_Tp* __p) {

  free((char*)__p);
}

template <class _ForwardIterator, class _Tp>
class _Temporary_buffer {
private:
  ptrdiff_t _M_original_len;
  ptrdiff_t _M_len;
  _Tp* _M_buffer;

  void _M_allocate_buffer() {
    _M_original_len = _M_len;
    _M_buffer = 0;

    if (_M_len > (ptrdiff_t)(0x7fffffff / sizeof(_Tp)))
      _M_len = 0x7fffffff / sizeof(_Tp);

    while (_M_len > 0) {
      _M_buffer = (_Tp*) malloc(_M_len * sizeof(_Tp));
      if (_M_buffer)
        break;
      _M_len /= 2;
    }
  }

  void _M_initialize_buffer(const _Tp&, const __true_type&) {}
  void _M_initialize_buffer(const _Tp& val, const __false_type&) {
    uninitialized_fill_n(_M_buffer, _M_len, val);
  }

public:
  ptrdiff_t size() const { return _M_len; }
  ptrdiff_t requested_size() const { return _M_original_len; }
  _Tp* begin() { return _M_buffer; }
  _Tp* end() { return _M_buffer + _M_len; }

  _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last) {




    typedef typename __type_traits<_Tp>::has_trivial_default_constructor _Trivial;

    {
      _M_len = ::std::distance(__first, __last);
      _M_allocate_buffer();
      if (_M_len > 0)
        _M_initialize_buffer(*__first, _Trivial());
    }
   
  }

  ~_Temporary_buffer() {
    ::std::_Destroy_Range(_M_buffer, _M_buffer + _M_len);
    free(_M_buffer);
  }

private:

  _Temporary_buffer(const _Temporary_buffer<_ForwardIterator, _Tp>&) {}
  void operator=(const _Temporary_buffer<_ForwardIterator, _Tp>&) {}
};





template <class _ForwardIterator,
          class _Tp

                    = typename iterator_traits<_ForwardIterator>::value_type

         >
struct temporary_buffer : public _Temporary_buffer<_ForwardIterator, _Tp>
{
  temporary_buffer(_ForwardIterator __first, _ForwardIterator __last)
    : _Temporary_buffer<_ForwardIterator, _Tp>(__first, __last) {}
  ~temporary_buffer() {}
};



}


# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_tempbuf.c" 1
# 33 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_tempbuf.c"
namespace std {

template <class _Tp>
pair<_Tp*, ptrdiff_t>
__get_temporary_buffer(ptrdiff_t __len, _Tp*)
{
  if (__len > ptrdiff_t(0x7fffffff / sizeof(_Tp)))
    __len = 0x7fffffff / sizeof(_Tp);

  while (__len > 0) {
    _Tp* __tmp = (_Tp*) malloc((size_t)__len * sizeof(_Tp));
    if (__tmp != 0)
      return pair<_Tp*, ptrdiff_t>(__tmp, __len);
    __len /= 2;
  }

  return pair<_Tp*, ptrdiff_t>((_Tp*)0, 0);
}
}
# 161 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_tempbuf.h" 2
# 35 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_algo.c" 2


namespace std {

namespace priv {

template <class _BidirectionalIter, class _Distance, class _Compare>
void __merge_without_buffer(_BidirectionalIter __first,
                            _BidirectionalIter __middle,
                            _BidirectionalIter __last,
                            _Distance __len1, _Distance __len2,
                            _Compare __comp);


template <class _BidirectionalIter1, class _BidirectionalIter2,
          class _BidirectionalIter3, class _Compare>
_BidirectionalIter3 __merge_backward(_BidirectionalIter1 __first1,
                                     _BidirectionalIter1 __last1,
                                     _BidirectionalIter2 __first2,
                                     _BidirectionalIter2 __last2,
                                     _BidirectionalIter3 __result,
                                     _Compare __comp);

template <class _Tp>

inline

const _Tp& __median(const _Tp& __a, const _Tp& __b, const _Tp& __c) {
  if (__a < __b)
    if (__b < __c)
      return __b;
    else if (__a < __c)
      return __c;
    else
      return __a;
  else if (__a < __c)
    return __a;
  else if (__b < __c)
    return __c;
  else
    return __b;
}

template <class _Tp, class _Compare>

inline

const _Tp&
__median(const _Tp& __a, const _Tp& __b, const _Tp& __c, _Compare __comp) {
  if (__comp(__a, __b)) {
   
    if (__comp(__b, __c)) {
     
      return __b;
    }
    else if (__comp(__a, __c)) {
     
      return __c;
    }
    else
      return __a;
  }
  else if (__comp(__a, __c)) {
   
    return __a;
  }
  else if (__comp(__b, __c)) {
   
    return __c;
  }
  else
    return __b;
}

}

template <class _ForwardIter1, class _ForwardIter2>
_ForwardIter1 search(_ForwardIter1 __first1, _ForwardIter1 __last1,
                     _ForwardIter2 __first2, _ForwardIter2 __last2) {
 
 

  if (__first1 == __last1 || __first2 == __last2)
    return __first1;


  _ForwardIter2 __p1(__first2);

  if ( ++__p1 == __last2 )
    return find(__first1, __last1, *__first2);



  for ( ; ; ) {
    __first1 = find(__first1, __last1, *__first2);
    if (__first1 == __last1)
      return __last1;

    _ForwardIter2 __p = __p1;
    _ForwardIter1 __current = __first1;
    if (++__current == __last1)
      return __last1;

    while (*__current == *__p) {
      if (++__p == __last2)
        return __first1;
      if (++__current == __last1)
        return __last1;
    }

    ++__first1;
  }
  return __first1;
}

namespace priv {

template <class _RandomAccessIter, class _Integer, class _Tp,
          class _BinaryPred, class _Distance>
_RandomAccessIter __search_n(_RandomAccessIter __first, _RandomAccessIter __last,
                             _Integer __count, const _Tp& __val, _BinaryPred __pred,
                             _Distance*, const random_access_iterator_tag &)
{
  _Distance __tailSize = __last - __first;
  const _Distance __pattSize = __count;
  const _Distance __skipOffset = __pattSize - 1;
  _RandomAccessIter __backTrack;
  _Distance __remainder, __prevRemainder;

  for ( _RandomAccessIter __lookAhead = __first + __skipOffset; __tailSize >= __pattSize; __lookAhead += __pattSize ) {

    __tailSize -= __pattSize;

    while ( !__pred(*__lookAhead, __val) ) {
      if (__tailSize < __pattSize)
        return __last;

      __lookAhead += __pattSize;
      __tailSize -= __pattSize;
    }

    if ( __skipOffset == 0 ) {
      return (__lookAhead - __skipOffset);
    }

    __remainder = __skipOffset;

    for (__backTrack = __lookAhead; __pred(*--__backTrack, __val); ) {
      if (--__remainder == 0)
        return (__lookAhead - __skipOffset);
    }

    if (__remainder > __tailSize)
      return __last;

    __lookAhead += __remainder;
    __tailSize -= __remainder;

    while ( __pred(*__lookAhead, __val) ) {
      __prevRemainder = __remainder;
      __backTrack = __lookAhead;

      do {
        if (--__remainder == 0)
          return (__lookAhead - __skipOffset);
      } while (__pred(*--__backTrack, __val));


      __remainder += __pattSize - __prevRemainder;

      if (__remainder > __tailSize)
        return __last;

      __lookAhead += __remainder;
      __tailSize -= __remainder;
    }


  }

  return __last;
}

template <class _ForwardIter, class _Integer, class _Tp,
          class _Distance, class _BinaryPred>
_ForwardIter __search_n(_ForwardIter __first, _ForwardIter __last,
                        _Integer __count, const _Tp& __val, _BinaryPred __pred,
                        _Distance*, const forward_iterator_tag &) {
  for (; (__first != __last) && !__pred(*__first, __val); ++__first) {}
  while (__first != __last) {
    _Integer __n = __count - 1;
    _ForwardIter __i = __first;
    ++__i;
    while (__i != __last && __n != 0 && __pred(*__i, __val)) {
      ++__i;
      --__n;
    }
    if (__n == 0)
      return __first;
    else if (__i != __last)
      for (__first = ++__i; (__first != __last) && !__pred(*__first, __val); ++__first) {}
    else
      break;
  }
  return __last;
}

}


template <class _ForwardIter, class _Integer, class _Tp>
_ForwardIter search_n(_ForwardIter __first, _ForwardIter __last,
                      _Integer __count, const _Tp& __val) {
 
  if (__count <= 0)
    return __first;
  if (__count == 1)

    return find(__first, __last, __val);
  return ::std::priv:: __search_n(__first, __last, __count, __val, equal_to<_Tp>(),
                               (typename ::std::iterator_traits< _ForwardIter >::difference_type*)0,
                               typename ::std::iterator_traits< _ForwardIter >::iterator_category());
}

template <class _ForwardIter, class _Integer, class _Tp, class _BinaryPred>
_ForwardIter search_n(_ForwardIter __first, _ForwardIter __last,
                      _Integer __count, const _Tp& __val,
                      _BinaryPred __binary_pred) {
 
  if (__count <= 0)
    return __first;
  return ::std::priv:: __search_n(__first, __last, __count, __val, __binary_pred,
                               (typename ::std::iterator_traits< _ForwardIter >::difference_type*)0,
                               typename ::std::iterator_traits< _ForwardIter >::iterator_category());
}

template <class _ForwardIter1, class _ForwardIter2>
_ForwardIter1
find_end(_ForwardIter1 __first1, _ForwardIter1 __last1,
         _ForwardIter2 __first2, _ForwardIter2 __last2) {
 
 
  return ::std::priv:: __find_end(__first1, __last1, __first2, __last2,

                               typename ::std::iterator_traits< _ForwardIter1 >::iterator_category(),
                               typename ::std::iterator_traits< _ForwardIter2 >::iterator_category(),




                               ::std::priv:: __equal_to((typename ::std::iterator_traits< _ForwardIter1 >::value_type*)0)
    );
}


namespace priv {

template <class _InputIterator, class _OutputIterator, class _BinaryPredicate,
          class _Tp>
inline _OutputIterator
__unique_copy(_InputIterator __first, _InputIterator __last,
              _OutputIterator __result,
              _BinaryPredicate __binary_pred, _Tp*) {
  _Tp __val = *__first;
  *__result = __val;
  while (++__first != __last)
    if (!__binary_pred(__val, *__first)) {
      __val = *__first;
      *++__result = __val;
    }
  return ++__result;
}

template <class _InputIter, class _OutputIter, class _BinaryPredicate>
inline _OutputIter
__unique_copy(_InputIter __first, _InputIter __last,_OutputIter __result,
              _BinaryPredicate __binary_pred, const output_iterator_tag &) {
  return ::std::priv:: __unique_copy(__first, __last, __result, __binary_pred,
                                  (typename ::std::iterator_traits< _InputIter >::value_type*)0);
}

template <class _InputIter, class _ForwardIter, class _BinaryPredicate>
inline _ForwardIter
__unique_copy(_InputIter __first, _InputIter __last, _ForwardIter __result,
              _BinaryPredicate __binary_pred, const forward_iterator_tag &) {
  *__result = *__first;
  while (++__first != __last)
    if (!__binary_pred(*__result, *__first)) *++__result = *__first;
  return ++__result;
}
# 344 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_algo.c"
}

template <class _InputIter, class _OutputIter>
_OutputIter
unique_copy(_InputIter __first, _InputIter __last, _OutputIter __result) {
 
  if (__first == __last) return __result;
  return ::std::priv:: __unique_copy(__first, __last, __result,
                                  ::std::priv:: __equal_to((typename ::std::iterator_traits< _InputIter >::value_type*)0),
                                  typename ::std::iterator_traits< _OutputIter >::iterator_category());
}

template <class _InputIter, class _OutputIter, class _BinaryPredicate>
_OutputIter
unique_copy(_InputIter __first, _InputIter __last,_OutputIter __result,
            _BinaryPredicate __binary_pred) {
 
  if (__first == __last) return __result;
  return ::std::priv:: __unique_copy(__first, __last, __result, __binary_pred,
                                  typename ::std::iterator_traits< _OutputIter >::iterator_category());
}


namespace priv {

template <class _ForwardIter, class _Distance>
_ForwardIter __rotate_aux(_ForwardIter __first,
                          _ForwardIter __middle,
                          _ForwardIter __last,
                          _Distance*,
                          const forward_iterator_tag &) {
  if (__first == __middle)
    return __last;
  if (__last == __middle)
    return __first;

  _ForwardIter __first2 = __middle;
  do {
    ::std::swap(*__first++, *__first2++);
    if (__first == __middle)
      __middle = __first2;
  } while (__first2 != __last);

  _ForwardIter __new_middle = __first;

  __first2 = __middle;

  while (__first2 != __last) {
    ::std::swap (*__first++, *__first2++);
    if (__first == __middle)
      __middle = __first2;
    else if (__first2 == __last)
      __first2 = __middle;
  }

  return __new_middle;
}

template <class _BidirectionalIter, class _Distance>
_BidirectionalIter __rotate_aux(_BidirectionalIter __first,
                                _BidirectionalIter __middle,
                                _BidirectionalIter __last,
                                _Distance*,
                                const bidirectional_iterator_tag &) {
  if (__first == __middle)
    return __last;
  if (__last == __middle)
    return __first;

  ::std::priv:: __reverse(__first, __middle, bidirectional_iterator_tag());
  ::std::priv:: __reverse(__middle, __last, bidirectional_iterator_tag());

  while (__first != __middle && __middle != __last)
    ::std::swap(*__first++, *--__last);

  if (__first == __middle) {
    ::std::priv:: __reverse(__middle, __last, bidirectional_iterator_tag());
    return __last;
  }
  else {
    ::std::priv:: __reverse(__first, __middle, bidirectional_iterator_tag());
    return __first;
  }
}


template <class _EuclideanRingElement>
inline
_EuclideanRingElement __gcd(_EuclideanRingElement __m,
                            _EuclideanRingElement __n) {
  while (__n != 0) {
    _EuclideanRingElement __t = __m % __n;
    __m = __n;
    __n = __t;
  }
  return __m;
}

template <class _RandomAccessIter, class _Distance, class _Tp>
_RandomAccessIter __rotate_aux(_RandomAccessIter __first,
                               _RandomAccessIter __middle,
                               _RandomAccessIter __last,
                               _Distance *, _Tp *) {

  _Distance __n = __last - __first;
  _Distance __k = __middle - __first;
  _Distance __l = __n - __k;
  _RandomAccessIter __result = __first + (__last - __middle);

  if (__k == 0)
    return __last;

  if (__k == __l) {
    ::std::swap_ranges(__first, __middle, __middle);
    return __result;
  }

  _Distance __d = ::std::priv:: __gcd(__n, __k);

  for (_Distance __i = 0; __i < __d; __i++) {
    _Tp __tmp = *__first;
    _RandomAccessIter __p = __first;

    if (__k < __l) {
      for (_Distance __j = 0; __j < __l/__d; __j++) {
        if (__p > __first + __l) {
          *__p = *(__p - __l);
          __p -= __l;
        }

        *__p = *(__p + __k);
        __p += __k;
      }
    }

    else {
      for (_Distance __j = 0; __j < __k/__d - 1; __j ++) {
        if (__p < __last - __k) {
          *__p = *(__p + __k);
          __p += __k;
        }

        *__p = * (__p - __l);
        __p -= __l;
      }
    }

    *__p = __tmp;
    ++__first;
  }

  return __result;
}

template <class _RandomAccessIter, class _Distance>
inline _RandomAccessIter
__rotate_aux(_RandomAccessIter __first, _RandomAccessIter __middle, _RandomAccessIter __last,
             _Distance * __dis, const random_access_iterator_tag &) {
  return ::std::priv:: __rotate_aux(__first, __middle, __last,
                                 __dis, (typename ::std::iterator_traits< _RandomAccessIter >::value_type*)0);
}

template <class _ForwardIter>
_ForwardIter
__rotate(_ForwardIter __first, _ForwardIter __middle, _ForwardIter __last) {
 
 
  return __rotate_aux(__first, __middle, __last,
                      (typename ::std::iterator_traits< _ForwardIter >::difference_type*)0,
                      typename ::std::iterator_traits< _ForwardIter >::iterator_category());
}

}

template <class _ForwardIter>
void rotate(_ForwardIter __first, _ForwardIter __middle, _ForwardIter __last) {
  ::std::priv:: __rotate(__first, __middle, __last);
}




namespace priv {

template <class _Distance>
inline _Distance __random_number(_Distance __n) {

  return rand() % __n;



}

}

template <class _RandomAccessIter>
void random_shuffle(_RandomAccessIter __first,
                    _RandomAccessIter __last) {
 
  if (__first == __last) return;
  for (_RandomAccessIter __i = __first + 1; __i != __last; ++__i)
    iter_swap(__i, __first + ::std::priv:: __random_number((__i - __first) + 1));
}

template <class _RandomAccessIter, class _RandomNumberGenerator>
void random_shuffle(_RandomAccessIter __first, _RandomAccessIter __last,
                    _RandomNumberGenerator &__rand) {
 
  if (__first == __last) return;
  for (_RandomAccessIter __i = __first + 1; __i != __last; ++__i)
    iter_swap(__i, __first + __rand((__i - __first) + 1));
}



template <class _ForwardIter, class _OutputIter, class _Distance>
_OutputIter random_sample_n(_ForwardIter __first, _ForwardIter __last,
                            _OutputIter __out_ite, const _Distance __n) {
 
  _Distance __remaining = ::std::distance(__first, __last);
  _Distance __m = (min) (__n, __remaining);

  while (__m > 0) {
    if (::std::priv:: __random_number(__remaining) < __m) {
      *__out_ite = *__first;
      ++__out_ite;
      --__m;
    }

    --__remaining;
    ++__first;
  }
  return __out_ite;
}


template <class _ForwardIter, class _OutputIter, class _Distance,
          class _RandomNumberGenerator>
_OutputIter random_sample_n(_ForwardIter __first, _ForwardIter __last,
                            _OutputIter __out_ite, const _Distance __n,
                            _RandomNumberGenerator& __rand) {
 
  _Distance __remaining = ::std::distance(__first, __last);
  _Distance __m = (min) (__n, __remaining);

  while (__m > 0) {
    if (__rand(__remaining) < __m) {
      *__out_ite = *__first;
      ++__out_ite;
      --__m;
    }

    --__remaining;
    ++__first;
  }
  return __out_ite;
}

namespace priv {

template <class _InputIter, class _RandomAccessIter, class _Distance>
_RandomAccessIter __random_sample(_InputIter __first, _InputIter __last,
                                  _RandomAccessIter __out_ite,
                                  const _Distance __n) {
  _Distance __m = 0;
  _Distance __t = __n;
  for ( ; __first != __last && __m < __n; ++__m, ++__first)
    __out_ite[__m] = *__first;

  while (__first != __last) {
    ++__t;
    _Distance __M = __random_number(__t);
    if (__M < __n)
      __out_ite[__M] = *__first;
    ++__first;
  }

  return __out_ite + __m;
}

template <class _InputIter, class _RandomAccessIter,
          class _RandomNumberGenerator, class _Distance>
_RandomAccessIter __random_sample(_InputIter __first, _InputIter __last,
                                  _RandomAccessIter __out_ite,
                                  _RandomNumberGenerator& __rand,
                                  const _Distance __n) {
  _Distance __m = 0;
  _Distance __t = __n;
  for ( ; __first != __last && __m < __n; ++__m, ++__first)
    __out_ite[__m] = *__first;

  while (__first != __last) {
    ++__t;
    _Distance __M = __rand(__t);
    if (__M < __n)
      __out_ite[__M] = *__first;
    ++__first;
  }

  return __out_ite + __m;
}

}

template <class _InputIter, class _RandomAccessIter>
_RandomAccessIter
random_sample(_InputIter __first, _InputIter __last,
              _RandomAccessIter __out_first, _RandomAccessIter __out_last) {
 
 
  return ::std::priv:: __random_sample(__first, __last,
                                    __out_first, __out_last - __out_first);
}

template <class _InputIter, class _RandomAccessIter, class _RandomNumberGenerator>
_RandomAccessIter
random_sample(_InputIter __first, _InputIter __last,
              _RandomAccessIter __out_first, _RandomAccessIter __out_last,
              _RandomNumberGenerator& __rand) {
 
 
  return ::std::priv:: __random_sample(__first, __last,
                                    __out_first, __rand,
                                    __out_last - __out_first);
}




namespace priv {

template <class _ForwardIter, class _Predicate>
inline _ForwardIter __partition(_ForwardIter __first,
                                           _ForwardIter __last,
                                           _Predicate __pred,
                                           const forward_iterator_tag &) {
  if (__first == __last) return __first;

  while (__pred(*__first))
    if (++__first == __last) return __first;

  _ForwardIter __next = __first;

  while (++__next != __last) {
    if (__pred(*__next)) {
      ::std::swap(*__first, *__next);
      ++__first;
    }
  }
  return __first;
}

template <class _BidirectionalIter, class _Predicate>
inline _BidirectionalIter __partition(_BidirectionalIter __first,
                                                 _BidirectionalIter __last,
                                                 _Predicate __pred,
                                                 const bidirectional_iterator_tag &) {
  for (;;) {
    for (;;) {
      if (__first == __last)
        return __first;
      else if (__pred(*__first))
        ++__first;
      else
        break;
    }
    --__last;
    for (;;) {
      if (__first == __last)
        return __first;
      else if (!__pred(*__last))
        --__last;
      else
        break;
    }
    iter_swap(__first, __last);
    ++__first;
  }
}
# 735 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_algo.c"
}

template <class _ForwardIter, class _Predicate>
_ForwardIter partition(_ForwardIter __first, _ForwardIter __last, _Predicate __pred) {
 
  return ::std::priv:: __partition(__first, __last, __pred, typename ::std::iterator_traits< _ForwardIter >::iterator_category());
}







namespace priv {

template <class _ForwardIter, class _Predicate, class _Distance>
_ForwardIter __inplace_stable_partition(_ForwardIter __first,
                                        _ForwardIter __last,
                                        _Predicate __pred, _Distance __len,
                                        bool __pred_of_first, bool __pred_of_before_last) {
  if (__len == 1)
    return (__pred_of_first && (__pred_of_before_last || __pred(*__first))) ? __last : __first;
  _ForwardIter __middle = __first;
  _Distance __half_len = __len / 2;
  ::std::advance(__middle, __half_len);
  return ::std::priv:: __rotate(::std::priv:: __inplace_stable_partition(__first, __middle, __pred, __half_len, __pred_of_first, false),
                             __middle,
                             ::std::priv:: __inplace_stable_partition(__middle, __last, __pred, __len - __half_len, true, __pred_of_before_last));
}

template <class _ForwardIter, class _Pointer, class _Predicate,
          class _Distance>
_ForwardIter __stable_partition_adaptive(_ForwardIter __first,
                                         _ForwardIter __last,
                                         _Predicate __pred, _Distance __len,
                                         _Pointer __buffer, _Distance __buffer_size,
                                         bool __pred_of_first, bool __pred_of_before_last) {
  if (__len <= __buffer_size) {
    _ForwardIter __result1 = __first;
    _Pointer __result2 = __buffer;
    if ((__first != __last) && (!__pred_of_first || __pred(*__first))) {
      *__result2 = *__first;
      ++__result2; ++__first; --__len;
    }
    for (; __first != __last ; ++__first, --__len) {
      if (((__len == 1) && (__pred_of_before_last || __pred(*__first))) ||
          ((__len != 1) && __pred(*__first))){
        *__result1 = *__first;
        ++__result1;
      }
      else {
        *__result2 = *__first;
        ++__result2;
      }
    }
    ::std::copy(__buffer, __result2, __result1);
    return __result1;
  }
  else {
    _ForwardIter __middle = __first;
    _Distance __half_len = __len / 2;
    ::std::advance(__middle, __half_len);
    return ::std::priv:: __rotate(::std::priv:: __stable_partition_adaptive(__first, __middle, __pred,
                                                                      __half_len, __buffer, __buffer_size,
                                                                      __pred_of_first, false),
                               __middle,
                               ::std::priv:: __stable_partition_adaptive(__middle, __last, __pred,
                                                                      __len - __half_len, __buffer, __buffer_size,
                                                                      true, __pred_of_before_last));
  }
}

template <class _ForwardIter, class _Predicate, class _Tp, class _Distance>
inline _ForwardIter
__stable_partition_aux_aux(_ForwardIter __first, _ForwardIter __last,
                           _Predicate __pred, _Tp*, _Distance*, bool __pred_of_before_last) {
  _Temporary_buffer<_ForwardIter, _Tp> __buf(__first, __last);
 
  return (__buf.size() > 0) ?
    __stable_partition_adaptive(__first, __last, __pred,
                                _Distance(__buf.requested_size()),
                                __buf.begin(), __buf.size(),
                                false, __pred_of_before_last) :
    __inplace_stable_partition(__first, __last, __pred,
                               _Distance(__buf.requested_size()),
                               false, __pred_of_before_last);
 
}

template <class _ForwardIter, class _Predicate>
_ForwardIter
__stable_partition_aux(_ForwardIter __first, _ForwardIter __last, _Predicate __pred,
                       const forward_iterator_tag &) {
  return __stable_partition_aux_aux(__first, __last, __pred,
                                    (typename ::std::iterator_traits< _ForwardIter >::value_type*)0,
                                    (typename ::std::iterator_traits< _ForwardIter >::difference_type*)0, false);
}

template <class _BidirectIter, class _Predicate>
_BidirectIter
__stable_partition_aux(_BidirectIter __first, _BidirectIter __last, _Predicate __pred,
                       const bidirectional_iterator_tag &) {
  for (--__last;;) {
    if (__first == __last)
      return __first;
    else if (!__pred(*__last))
      --__last;
    else
      break;
  }
  ++__last;

  return __stable_partition_aux_aux(__first, __last, __pred,
                                    (typename ::std::iterator_traits< _BidirectIter >::value_type*)0,
                                    (typename ::std::iterator_traits< _BidirectIter >::difference_type*)0, true);
}
# 862 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_algo.c"
}

template <class _ForwardIter, class _Predicate>
_ForwardIter
stable_partition(_ForwardIter __first, _ForwardIter __last, _Predicate __pred) {
 
  for (;;) {
    if (__first == __last)
      return __first;
    else if (__pred(*__first))
      ++__first;
    else
      break;
  }
  return ::std::priv:: __stable_partition_aux(__first, __last, __pred,
                                           typename ::std::iterator_traits< _ForwardIter >::iterator_category());
}

namespace priv {

template <class _RandomAccessIter, class _Tp, class _Compare>
_RandomAccessIter __unguarded_partition(_RandomAccessIter __first,
                                        _RandomAccessIter __last,
                                        _Tp __pivot, _Compare __comp) {
  for (;;) {
    while (__comp(*__first, __pivot)) {
     
      ++__first;
    }
    --__last;
    while (__comp(__pivot, *__last)) {
     
      --__last;
    }
    if (!(__first < __last))
      return __first;
    iter_swap(__first, __last);
    ++__first;
  }
}




template <class _RandomAccessIter, class _Tp, class _Compare>
void __unguarded_linear_insert(_RandomAccessIter __last, _Tp __val,
                               _Compare __comp) {
  _RandomAccessIter __next = __last;
  --__next;
  while (__comp(__val, *__next)) {
   
    *__last = *__next;
    __last = __next;
    --__next;
  }
  *__last = __val;
}

template <class _RandomAccessIter, class _Tp, class _Compare>
inline void __linear_insert(_RandomAccessIter __first,
                            _RandomAccessIter __last, _Tp __val, _Compare __comp) {


  if (__comp(__val, *__first)) {
   
    copy_backward(__first, __last, __last + 1);
    *__first = __val;
  }
  else
    __unguarded_linear_insert(__last, __val, __comp);
}

template <class _RandomAccessIter, class _Tp, class _Compare>
void __insertion_sort(_RandomAccessIter __first,
                      _RandomAccessIter __last,
                      _Tp *, _Compare __comp) {
  if (__first == __last) return;
  for (_RandomAccessIter __i = __first + 1; __i != __last; ++__i)
    __linear_insert<_RandomAccessIter, _Tp, _Compare>(__first, __i, *__i, __comp);
}

template <class _RandomAccessIter, class _Tp, class _Compare>
void __unguarded_insertion_sort_aux(_RandomAccessIter __first,
                                    _RandomAccessIter __last,
                                    _Tp*, _Compare __comp) {
  for (_RandomAccessIter __i = __first; __i != __last; ++__i)
    __unguarded_linear_insert<_RandomAccessIter, _Tp, _Compare>(__i, *__i, __comp);
}

template <class _RandomAccessIter, class _Compare>
inline void __unguarded_insertion_sort(_RandomAccessIter __first,
                                       _RandomAccessIter __last,
                                       _Compare __comp) {
  __unguarded_insertion_sort_aux(__first, __last, (typename ::std::iterator_traits< _RandomAccessIter >::value_type*)0, __comp);
}

template <class _RandomAccessIter, class _Compare>
void __final_insertion_sort(_RandomAccessIter __first,
                            _RandomAccessIter __last, _Compare __comp) {
  if (__last - __first > 16) {
    __insertion_sort(__first, __first + 16, (typename ::std::iterator_traits< _RandomAccessIter >::value_type*)0, __comp);
    __unguarded_insertion_sort(__first + 16, __last, __comp);
  }
  else
    __insertion_sort(__first, __last, (typename ::std::iterator_traits< _RandomAccessIter >::value_type*)0, __comp);
}

template <class _RandomAccessIter, class _Tp, class _Size, class _Compare>
void __introsort_loop(_RandomAccessIter __first,
                      _RandomAccessIter __last, _Tp*,
                      _Size __depth_limit, _Compare __comp) {
  while (__last - __first > 16) {
    if (__depth_limit == 0) {
      partial_sort(__first, __last, __last, __comp);
      return;
    }
    --__depth_limit;
    _RandomAccessIter __cut =
      __unguarded_partition(__first, __last,
                            _Tp(__median(*__first,
                                         *(__first + (__last - __first)/2),
                                         *(__last - 1), __comp)),
       __comp);
    __introsort_loop(__cut, __last, (_Tp*) 0, __depth_limit, __comp);
    __last = __cut;
  }
}

}

template <class _RandomAccessIter>
void sort(_RandomAccessIter __first, _RandomAccessIter __last) {
 
  if (__first != __last) {
    ::std::priv:: __introsort_loop(__first, __last,
                                (typename ::std::iterator_traits< _RandomAccessIter >::value_type*)0,
                                ::std::priv:: __lg(__last - __first) * 2,
                                ::std::priv:: __less((typename ::std::iterator_traits< _RandomAccessIter >::value_type*)0));
    ::std::priv:: __final_insertion_sort(__first, __last,
                                      ::std::priv:: __less((typename ::std::iterator_traits< _RandomAccessIter >::value_type*)0));
  }
}

template <class _RandomAccessIter, class _Compare>
void sort(_RandomAccessIter __first, _RandomAccessIter __last, _Compare __comp) {
 
  if (__first != __last) {
    ::std::priv:: __introsort_loop(__first, __last,
                                (typename ::std::iterator_traits< _RandomAccessIter >::value_type*)0,
                                ::std::priv:: __lg(__last - __first) * 2, __comp);
    ::std::priv:: __final_insertion_sort(__first, __last, __comp);
  }
}


namespace priv {

template <class _RandomAccessIter, class _Compare>
void __inplace_stable_sort(_RandomAccessIter __first,
                           _RandomAccessIter __last, _Compare __comp) {
  if (__last - __first < 15) {
    __insertion_sort(__first, __last, (typename ::std::iterator_traits< _RandomAccessIter >::value_type*)0, __comp);
    return;
  }
  _RandomAccessIter __middle = __first + (__last - __first) / 2;
  __inplace_stable_sort(__first, __middle, __comp);
  __inplace_stable_sort(__middle, __last, __comp);
  __merge_without_buffer(__first, __middle, __last,
                         __middle - __first,
                         __last - __middle,
                         __comp);
}

template <class _RandomAccessIter1, class _RandomAccessIter2,
          class _Distance, class _Compare>
void __merge_sort_loop(_RandomAccessIter1 __first,
                       _RandomAccessIter1 __last,
                       _RandomAccessIter2 __result, _Distance __step_size,
                       _Compare __comp) {
  _Distance __two_step = 2 * __step_size;

  while (__last - __first >= __two_step) {
    __result = merge(__first, __first + __step_size,
                     __first + __step_size, __first + __two_step,
                     __result,
                     __comp);
    __first += __two_step;
  }
  __step_size = (min) (_Distance(__last - __first), __step_size);

  merge(__first, __first + __step_size,
        __first + __step_size, __last,
        __result,
        __comp);
}

const int __stl_chunk_size = 7;

template <class _RandomAccessIter, class _Distance, class _Compare>
void __chunk_insertion_sort(_RandomAccessIter __first,
                            _RandomAccessIter __last,
                            _Distance __chunk_size, _Compare __comp) {
  while (__last - __first >= __chunk_size) {
    __insertion_sort(__first, __first + __chunk_size,
                     (typename ::std::iterator_traits< _RandomAccessIter >::value_type*)0, __comp);
    __first += __chunk_size;
  }
  __insertion_sort(__first, __last, (typename ::std::iterator_traits< _RandomAccessIter >::value_type*)0, __comp);
}

template <class _RandomAccessIter, class _Pointer, class _Distance,
          class _Compare>
void __merge_sort_with_buffer(_RandomAccessIter __first,
                              _RandomAccessIter __last, _Pointer __buffer,
                              _Distance*, _Compare __comp) {
  _Distance __len = __last - __first;
  _Pointer __buffer_last = __buffer + __len;

  _Distance __step_size = __stl_chunk_size;
  __chunk_insertion_sort(__first, __last, __step_size, __comp);

  while (__step_size < __len) {
    __merge_sort_loop(__first, __last, __buffer, __step_size, __comp);
    __step_size *= 2;
    __merge_sort_loop(__buffer, __buffer_last, __first, __step_size, __comp);
    __step_size *= 2;
  }
}

template <class _BidirectionalIter1, class _BidirectionalIter2,
          class _Distance>
_BidirectionalIter1 __rotate_adaptive(_BidirectionalIter1 __first,
                                      _BidirectionalIter1 __middle,
                                      _BidirectionalIter1 __last,
                                      _Distance __len1, _Distance __len2,
                                      _BidirectionalIter2 __buffer,
                                      _Distance __buffer_size) {
  if (__len1 > __len2 && __len2 <= __buffer_size) {
    _BidirectionalIter2 __buffer_end = ::std::copy(__middle, __last, __buffer);
    ::std::copy_backward(__first, __middle, __last);
    return ::std::copy(__buffer, __buffer_end, __first);
  }
  else if (__len1 <= __buffer_size) {
    _BidirectionalIter2 __buffer_end = ::std::copy(__first, __middle, __buffer);
    ::std::copy(__middle, __last, __first);
    return ::std::copy_backward(__buffer, __buffer_end, __last);
  }
  else
    return ::std::priv:: __rotate(__first, __middle, __last);
}

template <class _BidirectionalIter, class _Distance, class _Pointer,
          class _Compare>
void __merge_adaptive(_BidirectionalIter __first,
                      _BidirectionalIter __middle,
                      _BidirectionalIter __last,
                      _Distance __len1, _Distance __len2,
                      _Pointer __buffer, _Distance __buffer_size,
                      _Compare __comp) {
  if (__len1 <= __len2 && __len1 <= __buffer_size) {
    _Pointer __buffer_end = ::std::copy(__first, __middle, __buffer);
    ::std::merge(__buffer, __buffer_end, __middle, __last, __first, __comp);
  }
  else if (__len2 <= __buffer_size) {
    _Pointer __buffer_end = ::std::copy(__middle, __last, __buffer);
    ::std::priv:: __merge_backward(__first, __middle, __buffer, __buffer_end, __last,
                                __comp);
  }
  else {
    _BidirectionalIter __first_cut = __first;
    _BidirectionalIter __second_cut = __middle;
    _Distance __len11 = 0;
    _Distance __len22 = 0;
    if (__len1 > __len2) {
      __len11 = __len1 / 2;
      ::std::advance(__first_cut, __len11);
      __second_cut = ::std::lower_bound(__middle, __last, *__first_cut, __comp);
      __len22 += ::std::distance(__middle, __second_cut);
    }
    else {
      __len22 = __len2 / 2;
      ::std::advance(__second_cut, __len22);
      __first_cut = ::std::upper_bound(__first, __middle, *__second_cut, __comp);
      __len11 += ::std::distance(__first, __first_cut);
    }
    _BidirectionalIter __new_middle =
      __rotate_adaptive(__first_cut, __middle, __second_cut, __len1 - __len11,
                        __len22, __buffer, __buffer_size);
    __merge_adaptive(__first, __first_cut, __new_middle, __len11,
                     __len22, __buffer, __buffer_size, __comp);
    __merge_adaptive(__new_middle, __second_cut, __last, __len1 - __len11,
                     __len2 - __len22, __buffer, __buffer_size, __comp);
  }
}

template <class _RandomAccessIter, class _Pointer, class _Distance,
          class _Compare>
void __stable_sort_adaptive(_RandomAccessIter __first,
                            _RandomAccessIter __last, _Pointer __buffer,
                            _Distance __buffer_size, _Compare __comp) {
  _Distance __len = (__last - __first + 1) / 2;
  _RandomAccessIter __middle = __first + __len;
  if (__len > __buffer_size) {
    __stable_sort_adaptive(__first, __middle, __buffer, __buffer_size,
                           __comp);
    __stable_sort_adaptive(__middle, __last, __buffer, __buffer_size,
                           __comp);
  }
  else {
    __merge_sort_with_buffer(__first, __middle, __buffer, (_Distance*)0,
                               __comp);
    __merge_sort_with_buffer(__middle, __last, __buffer, (_Distance*)0,
                               __comp);
  }
  __merge_adaptive(__first, __middle, __last, _Distance(__middle - __first),
                   _Distance(__last - __middle), __buffer, __buffer_size,
                   __comp);
}

template <class _RandomAccessIter, class _Tp, class _Distance, class _Compare>
void __stable_sort_aux(_RandomAccessIter __first,
                       _RandomAccessIter __last, _Tp*, _Distance*,
                       _Compare __comp) {
  _Temporary_buffer<_RandomAccessIter, _Tp> buf(__first, __last);
  if (buf.begin() == 0)
    __inplace_stable_sort(__first, __last, __comp);
  else
    __stable_sort_adaptive(__first, __last, buf.begin(),
                           _Distance(buf.size()),
                           __comp);
}

}

template <class _RandomAccessIter>
void stable_sort(_RandomAccessIter __first,
                 _RandomAccessIter __last) {
 
  ::std::priv:: __stable_sort_aux(__first, __last,
                               (typename ::std::iterator_traits< _RandomAccessIter >::value_type*)0,
                               (typename ::std::iterator_traits< _RandomAccessIter >::difference_type*)0,
                               ::std::priv:: __less((typename ::std::iterator_traits< _RandomAccessIter >::value_type*)0));
}

template <class _RandomAccessIter, class _Compare>
void stable_sort(_RandomAccessIter __first,
                 _RandomAccessIter __last, _Compare __comp) {
 
  ::std::priv:: __stable_sort_aux(__first, __last,
                               (typename ::std::iterator_traits< _RandomAccessIter >::value_type*)0,
                               (typename ::std::iterator_traits< _RandomAccessIter >::difference_type*)0,
                               __comp);
}


namespace priv {

template <class _RandomAccessIter, class _Tp, class _Compare>
void __partial_sort(_RandomAccessIter __first, _RandomAccessIter __middle,
                    _RandomAccessIter __last, _Tp*, _Compare __comp) {
  make_heap(__first, __middle, __comp);
  for (_RandomAccessIter __i = __middle; __i < __last; ++__i) {
    if (__comp(*__i, *__first)) {
     
      __pop_heap(__first, __middle, __i, _Tp(*__i), __comp,
                 (typename ::std::iterator_traits< _RandomAccessIter >::difference_type*)0);
    }
  }
  sort_heap(__first, __middle, __comp);
}

}

template <class _RandomAccessIter>
void partial_sort(_RandomAccessIter __first,_RandomAccessIter __middle,
                  _RandomAccessIter __last) {
 
 
  ::std::priv:: __partial_sort(__first, __middle, __last, (typename ::std::iterator_traits< _RandomAccessIter >::value_type*)0,
                            ::std::priv:: __less((typename ::std::iterator_traits< _RandomAccessIter >::value_type*)0));
}

template <class _RandomAccessIter, class _Compare>
void partial_sort(_RandomAccessIter __first,_RandomAccessIter __middle,
                  _RandomAccessIter __last, _Compare __comp) {
 
 
  ::std::priv:: __partial_sort(__first, __middle, __last, (typename ::std::iterator_traits< _RandomAccessIter >::value_type*)0, __comp);
}

namespace priv {

template <class _InputIter, class _RandomAccessIter, class _Compare,
          class _Distance, class _Tp>
_RandomAccessIter __partial_sort_copy(_InputIter __first,
                                      _InputIter __last,
                                      _RandomAccessIter __result_first,
                                      _RandomAccessIter __result_last,
                                      _Compare __comp, _Distance*, _Tp*) {
  if (__result_first == __result_last) return __result_last;
  _RandomAccessIter __result_real_last = __result_first;
  while(__first != __last && __result_real_last != __result_last) {
    *__result_real_last = *__first;
    ++__result_real_last;
    ++__first;
  }
  make_heap(__result_first, __result_real_last, __comp);
  while (__first != __last) {
    if (__comp(*__first, *__result_first)) {
     
      __adjust_heap(__result_first, _Distance(0),
                    _Distance(__result_real_last - __result_first),
                    _Tp(*__first),
                    __comp);
    }
    ++__first;
  }
  sort_heap(__result_first, __result_real_last, __comp);
  return __result_real_last;
}

}

template <class _InputIter, class _RandomAccessIter>
_RandomAccessIter
partial_sort_copy(_InputIter __first, _InputIter __last,
                  _RandomAccessIter __result_first, _RandomAccessIter __result_last) {
 
 
  return ::std::priv:: __partial_sort_copy(__first, __last, __result_first, __result_last,
                                        ::std::priv:: __less((typename ::std::iterator_traits< _InputIter >::value_type*)0),
                                        (typename ::std::iterator_traits< _RandomAccessIter >::difference_type*)0,
                                        (typename ::std::iterator_traits< _InputIter >::value_type*)0);
}

template <class _InputIter, class _RandomAccessIter, class _Compare>
_RandomAccessIter
partial_sort_copy(_InputIter __first, _InputIter __last,
                  _RandomAccessIter __result_first,
                  _RandomAccessIter __result_last, _Compare __comp) {
 
 
  return ::std::priv:: __partial_sort_copy(__first, __last, __result_first, __result_last,
                                        __comp,
                                        (typename ::std::iterator_traits< _RandomAccessIter >::difference_type*)0,
                                        (typename ::std::iterator_traits< _InputIter >::value_type*)0);
}


namespace priv {

template <class _RandomAccessIter, class _Tp, class _Compare>
void __nth_element(_RandomAccessIter __first, _RandomAccessIter __nth,
                   _RandomAccessIter __last, _Tp*, _Compare __comp) {
  while (__last - __first > 3) {
    _RandomAccessIter __cut =
      __unguarded_partition(__first, __last,
                            _Tp(__median(*__first,
                                         *(__first + (__last - __first)/2),
                                         *(__last - 1),
                                         __comp)),
                            __comp);
    if (__cut <= __nth)
      __first = __cut;
    else
      __last = __cut;
  }
  __insertion_sort(__first, __last, (typename ::std::iterator_traits< _RandomAccessIter >::value_type*)0, __comp);
}

}

template <class _RandomAccessIter>
void nth_element(_RandomAccessIter __first, _RandomAccessIter __nth,
                 _RandomAccessIter __last) {
 
 
  ::std::priv:: __nth_element(__first, __nth, __last, (typename ::std::iterator_traits< _RandomAccessIter >::value_type*)0,
                           ::std::priv:: __less((typename ::std::iterator_traits< _RandomAccessIter >::value_type*)0));
}

template <class _RandomAccessIter, class _Compare>
void nth_element(_RandomAccessIter __first, _RandomAccessIter __nth,
                 _RandomAccessIter __last, _Compare __comp) {
 
 
  ::std::priv:: __nth_element(__first, __nth, __last, (typename ::std::iterator_traits< _RandomAccessIter >::value_type*)0, __comp);
}


namespace priv {

template <class _ForwardIter, class _Tp,
          class _Compare1, class _Compare2, class _Distance>
_ForwardIter __upper_bound(_ForwardIter __first, _ForwardIter __last, const _Tp& __val,
                           _Compare1 __comp1, _Compare2 __comp2, _Distance*) {
  _Distance __len = ::std::distance(__first, __last);
  _Distance __half;

  while (__len > 0) {
    __half = __len >> 1;
    _ForwardIter __middle = __first;
    ::std::advance(__middle, __half);
    if (__comp2(__val, *__middle)) {
     
      __len = __half;
    }
    else {
      __first = __middle;
      ++__first;
      __len = __len - __half - 1;
    }
  }
  return __first;
}

template <class _ForwardIter, class _Tp,
          class _Compare1, class _Compare2, class _Distance>
pair<_ForwardIter, _ForwardIter>
__equal_range(_ForwardIter __first, _ForwardIter __last, const _Tp& __val,
              _Compare1 __comp1, _Compare2 __comp2, _Distance* __dist) {
  _Distance __len = ::std::distance(__first, __last);
  _Distance __half;

  while (__len > 0) {
    __half = __len >> 1;
    _ForwardIter __middle = __first;
    ::std::advance(__middle, __half);
    if (__comp1(*__middle, __val)) {
     
      __first = __middle;
      ++__first;
      __len = __len - __half - 1;
    }
    else if (__comp2(__val, *__middle)) {
     
      __len = __half;
    }
    else {
      _ForwardIter __left = ::std::priv:: __lower_bound(__first, __middle, __val, __comp1, __comp2, __dist);


      if (__comp1(*__left, __val)) {
       
        return pair<_ForwardIter, _ForwardIter>(__left, __left);
      }
      ::std::advance(__first, __len);
      _ForwardIter __right = ::std::priv:: __upper_bound(++__middle, __first, __val, __comp1, __comp2, __dist);
      return pair<_ForwardIter, _ForwardIter>(__left, __right);
    }
  }
  return pair<_ForwardIter, _ForwardIter>(__first, __first);
}

}

template <class _InputIter1, class _InputIter2, class _OutputIter>
_OutputIter merge(_InputIter1 __first1, _InputIter1 __last1,
                  _InputIter2 __first2, _InputIter2 __last2,
                  _OutputIter __result) {
 
 
  while (__first1 != __last1 && __first2 != __last2) {
    if (*__first2 < *__first1) {
      *__result = *__first2;
      ++__first2;
    }
    else {
      *__result = *__first1;
      ++__first1;
    }
    ++__result;
  }
  return ::std::copy(__first2, __last2, ::std::copy(__first1, __last1, __result));
}

template <class _InputIter1, class _InputIter2, class _OutputIter,
          class _Compare>
_OutputIter merge(_InputIter1 __first1, _InputIter1 __last1,
                  _InputIter2 __first2, _InputIter2 __last2,
                  _OutputIter __result, _Compare __comp) {
 
 
  while (__first1 != __last1 && __first2 != __last2) {
    if (__comp(*__first2, *__first1)) {
     
      *__result = *__first2;
      ++__first2;
    }
    else {
      *__result = *__first1;
      ++__first1;
    }
    ++__result;
  }
  return ::std::copy(__first2, __last2, ::std::copy(__first1, __last1, __result));
}

namespace priv {

template <class _BidirectionalIter, class _Distance, class _Compare>
void __merge_without_buffer(_BidirectionalIter __first,
                            _BidirectionalIter __middle,
                            _BidirectionalIter __last,
                            _Distance __len1, _Distance __len2,
                            _Compare __comp) {
  if (__len1 == 0 || __len2 == 0)
    return;
  if (__len1 + __len2 == 2) {
    if (__comp(*__middle, *__first)) {
     
      iter_swap(__first, __middle);
    }
    return;
  }
  _BidirectionalIter __first_cut = __first;
  _BidirectionalIter __second_cut = __middle;
  _Distance __len11 = 0;
  _Distance __len22 = 0;
  if (__len1 > __len2) {
    __len11 = __len1 / 2;
    ::std::advance(__first_cut, __len11);
    __second_cut = ::std::lower_bound(__middle, __last, *__first_cut, __comp);
    __len22 += ::std::distance(__middle, __second_cut);
  }
  else {
    __len22 = __len2 / 2;
    ::std::advance(__second_cut, __len22);
    __first_cut = ::std::upper_bound(__first, __middle, *__second_cut, __comp);
    __len11 += ::std::distance(__first, __first_cut);
  }
  _BidirectionalIter __new_middle
    = ::std::priv:: __rotate(__first_cut, __middle, __second_cut);
  __merge_without_buffer(__first, __first_cut, __new_middle, __len11, __len22,
                         __comp);
  __merge_without_buffer(__new_middle, __second_cut, __last, __len1 - __len11,
                         __len2 - __len22, __comp);
}

template <class _BidirectionalIter1, class _BidirectionalIter2,
          class _BidirectionalIter3, class _Compare>
_BidirectionalIter3 __merge_backward(_BidirectionalIter1 __first1,
                                     _BidirectionalIter1 __last1,
                                     _BidirectionalIter2 __first2,
                                     _BidirectionalIter2 __last2,
                                     _BidirectionalIter3 __result,
                                     _Compare __comp) {
  if (__first1 == __last1)
    return copy_backward(__first2, __last2, __result);
  if (__first2 == __last2)
    return copy_backward(__first1, __last1, __result);
  --__last1;
  --__last2;
  for (;;) {
    if (__comp(*__last2, *__last1)) {
     
      *--__result = *__last1;
      if (__first1 == __last1)
        return copy_backward(__first2, ++__last2, __result);
      --__last1;
    }
    else {
      *--__result = *__last2;
      if (__first2 == __last2)
        return copy_backward(__first1, ++__last1, __result);
      --__last2;
    }
  }
}

template <class _BidirectionalIter, class _Tp,
          class _Distance, class _Compare>
inline void __inplace_merge_aux(_BidirectionalIter __first,
                                _BidirectionalIter __middle,
                                _BidirectionalIter __last, _Tp*, _Distance*,
                                _Compare __comp) {
  _Distance __len1 = ::std::distance(__first, __middle);
  _Distance __len2 = ::std::distance(__middle, __last);

  _Temporary_buffer<_BidirectionalIter, _Tp> __buf(__first, __last);
  if (__buf.begin() == 0)
    __merge_without_buffer(__first, __middle, __last, __len1, __len2, __comp);
  else
    __merge_adaptive(__first, __middle, __last, __len1, __len2,
                     __buf.begin(), _Distance(__buf.size()),
                     __comp);
}

}

template <class _BidirectionalIter>
void inplace_merge(_BidirectionalIter __first,
                   _BidirectionalIter __middle,
                   _BidirectionalIter __last) {
 
 
  if (__first == __middle || __middle == __last)
    return;
  ::std::priv:: __inplace_merge_aux(__first, __middle, __last,
                                 (typename ::std::iterator_traits< _BidirectionalIter >::value_type*)0, (typename ::std::iterator_traits< _BidirectionalIter >::difference_type*)0,
                                 ::std::priv:: __less((typename ::std::iterator_traits< _BidirectionalIter >::value_type*)0));
}

template <class _BidirectionalIter, class _Compare>
void inplace_merge(_BidirectionalIter __first,
                   _BidirectionalIter __middle,
                   _BidirectionalIter __last, _Compare __comp) {
 
 
  if (__first == __middle || __middle == __last)
    return;
  ::std::priv:: __inplace_merge_aux(__first, __middle, __last,
                                 (typename ::std::iterator_traits< _BidirectionalIter >::value_type*)0, (typename ::std::iterator_traits< _BidirectionalIter >::difference_type*)0,
                                 __comp);
}

namespace priv {

template <class _InputIter1, class _InputIter2, class _Compare>
bool __includes(_InputIter1 __first1, _InputIter1 __last1,
                _InputIter2 __first2, _InputIter2 __last2, _Compare __comp) {
 
 
  while (__first1 != __last1 && __first2 != __last2)
    if (__comp(*__first2, *__first1)) {
     
      return false;
    }
    else if (__comp(*__first1, *__first2))
      ++__first1;
    else
      ++__first1, ++__first2;

  return __first2 == __last2;
}

}

template <class _InputIter1, class _InputIter2, class _Compare>
bool includes(_InputIter1 __first1, _InputIter1 __last1,
              _InputIter2 __first2, _InputIter2 __last2, _Compare __comp) {
  return ::std::priv:: __includes(__first1, __last1, __first2, __last2, __comp);
}

template <class _InputIter1, class _InputIter2>
bool includes(_InputIter1 __first1, _InputIter1 __last1,
              _InputIter2 __first2, _InputIter2 __last2) {
  return ::std::priv:: __includes(__first1, __last1, __first2, __last2,
                               ::std::priv:: __less((typename ::std::iterator_traits< _InputIter1 >::value_type*)0));
}

namespace priv {

template <class _InputIter1, class _InputIter2, class _OutputIter,
          class _Compare>
_OutputIter __set_union(_InputIter1 __first1, _InputIter1 __last1,
                        _InputIter2 __first2, _InputIter2 __last2,
                        _OutputIter __result, _Compare __comp) {
 
 
  while (__first1 != __last1 && __first2 != __last2) {
    if (__comp(*__first1, *__first2)) {
     
      *__result = *__first1;
      ++__first1;
    }
    else if (__comp(*__first2, *__first1)) {
     
      *__result = *__first2;
      ++__first2;
    }
    else {
      *__result = *__first1;
      ++__first1;
      ++__first2;
    }
    ++__result;
  }
  return ::std::copy(__first2, __last2, ::std::copy(__first1, __last1, __result));
}

}

template <class _InputIter1, class _InputIter2, class _OutputIter>
_OutputIter set_union(_InputIter1 __first1, _InputIter1 __last1,
                      _InputIter2 __first2, _InputIter2 __last2,
                      _OutputIter __result) {
  return ::std::priv:: __set_union(__first1, __last1, __first2, __last2, __result,
                                ::std::priv:: __less((typename ::std::iterator_traits< _InputIter1 >::value_type*)0));
}

template <class _InputIter1, class _InputIter2, class _OutputIter,
          class _Compare>
_OutputIter set_union(_InputIter1 __first1, _InputIter1 __last1,
                      _InputIter2 __first2, _InputIter2 __last2,
                      _OutputIter __result, _Compare __comp) {
  return ::std::priv:: __set_union(__first1, __last1, __first2, __last2, __result, __comp);
}

namespace priv {

template <class _InputIter1, class _InputIter2, class _OutputIter,
          class _Compare>
_OutputIter __set_intersection(_InputIter1 __first1, _InputIter1 __last1,
                               _InputIter2 __first2, _InputIter2 __last2,
                               _OutputIter __result, _Compare __comp) {
 
 
  while (__first1 != __last1 && __first2 != __last2)
    if (__comp(*__first1, *__first2)) {
     
      ++__first1;
    }
    else if (__comp(*__first2, *__first1))
      ++__first2;
    else {
      *__result = *__first1;
      ++__first1;
      ++__first2;
      ++__result;
    }
  return __result;
}

}

template <class _InputIter1, class _InputIter2, class _OutputIter>
_OutputIter set_intersection(_InputIter1 __first1, _InputIter1 __last1,
                             _InputIter2 __first2, _InputIter2 __last2,
                             _OutputIter __result) {
  return ::std::priv:: __set_intersection(__first1, __last1, __first2, __last2, __result,
                                       ::std::priv:: __less((typename ::std::iterator_traits< _InputIter1 >::value_type*)0));
}

template <class _InputIter1, class _InputIter2, class _OutputIter,
          class _Compare>
_OutputIter set_intersection(_InputIter1 __first1, _InputIter1 __last1,
                             _InputIter2 __first2, _InputIter2 __last2,
                             _OutputIter __result, _Compare __comp) {
  return ::std::priv:: __set_intersection(__first1, __last1, __first2, __last2, __result, __comp);
}

namespace priv {

template <class _InputIter1, class _InputIter2, class _OutputIter,
          class _Compare>
_OutputIter __set_difference(_InputIter1 __first1, _InputIter1 __last1,
                             _InputIter2 __first2, _InputIter2 __last2,
                             _OutputIter __result, _Compare __comp) {
 
 
  while (__first1 != __last1 && __first2 != __last2)
    if (__comp(*__first1, *__first2)) {
     
      *__result = *__first1;
      ++__first1;
      ++__result;
    }
    else if (__comp(*__first2, *__first1))
      ++__first2;
    else {
      ++__first1;
      ++__first2;
    }
  return ::std::copy(__first1, __last1, __result);
}

}

template <class _InputIter1, class _InputIter2, class _OutputIter>
_OutputIter set_difference(_InputIter1 __first1, _InputIter1 __last1,
                           _InputIter2 __first2, _InputIter2 __last2,
                           _OutputIter __result) {
  return ::std::priv:: __set_difference(__first1, __last1, __first2, __last2, __result,
                                     ::std::priv:: __less((typename ::std::iterator_traits< _InputIter1 >::value_type*)0));
}

template <class _InputIter1, class _InputIter2, class _OutputIter,
          class _Compare>
_OutputIter set_difference(_InputIter1 __first1, _InputIter1 __last1,
                           _InputIter2 __first2, _InputIter2 __last2,
                           _OutputIter __result, _Compare __comp) {
  return ::std::priv:: __set_difference(__first1, __last1, __first2, __last2, __result, __comp);
}

namespace priv {

template <class _InputIter1, class _InputIter2, class _OutputIter, class _Compare>
_OutputIter
__set_symmetric_difference(_InputIter1 __first1, _InputIter1 __last1,
                           _InputIter2 __first2, _InputIter2 __last2,
                           _OutputIter __result, _Compare __comp) {
 
 
  while (__first1 != __last1 && __first2 != __last2) {
    if (__comp(*__first1, *__first2)) {
     
      *__result = *__first1;
      ++__first1;
      ++__result;
    }
    else if (__comp(*__first2, *__first1)) {
      *__result = *__first2;
      ++__first2;
      ++__result;
    }
    else {
      ++__first1;
      ++__first2;
    }
  }
  return ::std::copy(__first2, __last2, ::std::copy(__first1, __last1, __result));
}

}

template <class _InputIter1, class _InputIter2, class _OutputIter>
_OutputIter
set_symmetric_difference(_InputIter1 __first1, _InputIter1 __last1,
                         _InputIter2 __first2, _InputIter2 __last2,
                         _OutputIter __result) {
  return ::std::priv:: __set_symmetric_difference(__first1, __last1, __first2, __last2, __result,
                                               ::std::priv:: __less((typename ::std::iterator_traits< _InputIter1 >::value_type*)0));
}

template <class _InputIter1, class _InputIter2, class _OutputIter, class _Compare>
_OutputIter
set_symmetric_difference(_InputIter1 __first1, _InputIter1 __last1,
                         _InputIter2 __first2, _InputIter2 __last2,
                         _OutputIter __result,
                         _Compare __comp) {
  return ::std::priv:: __set_symmetric_difference(__first1, __last1, __first2, __last2, __result, __comp);
}




template <class _ForwardIter>
_ForwardIter max_element(_ForwardIter __first, _ForwardIter __last) {
 
  if (__first == __last) return __first;
  _ForwardIter __result = __first;
  while (++__first != __last)
    if (*__result < *__first) {
     
      __result = __first;
    }
  return __result;
}

template <class _ForwardIter, class _Compare>
_ForwardIter max_element(_ForwardIter __first, _ForwardIter __last,
                         _Compare __comp) {
 
  if (__first == __last) return __first;
  _ForwardIter __result = __first;
  while (++__first != __last) {
    if (__comp(*__result, *__first)) {
     
      __result = __first;
    }
  }
  return __result;
}

template <class _ForwardIter>
_ForwardIter min_element(_ForwardIter __first, _ForwardIter __last) {
 
  if (__first == __last) return __first;
  _ForwardIter __result = __first;
  while (++__first != __last)
    if (*__first < *__result) {
     
      __result = __first;
    }
  return __result;
}

template <class _ForwardIter, class _Compare>
_ForwardIter min_element(_ForwardIter __first, _ForwardIter __last,
                         _Compare __comp) {
 
  if (__first == __last) return __first;
  _ForwardIter __result = __first;
  while (++__first != __last) {
    if (__comp(*__first, *__result)) {
     
      __result = __first;
    }
  }
  return __result;
}



namespace priv {

template <class _BidirectionalIter, class _Compare>
bool __next_permutation(_BidirectionalIter __first, _BidirectionalIter __last,
                        _Compare __comp) {
 
  if (__first == __last)
    return false;
  _BidirectionalIter __i = __first;
  ++__i;
  if (__i == __last)
    return false;
  __i = __last;
  --__i;

  for(;;) {
    _BidirectionalIter __ii = __i;
    --__i;
    if (__comp(*__i, *__ii)) {
     
      _BidirectionalIter __j = __last;
      while (!__comp(*__i, *--__j)) {}
      iter_swap(__i, __j);
      reverse(__ii, __last);
      return true;
    }
    if (__i == __first) {
      reverse(__first, __last);
      return false;
    }
  }



}

}

template <class _BidirectionalIter>
bool next_permutation(_BidirectionalIter __first, _BidirectionalIter __last) {
 
  return ::std::priv:: __next_permutation(__first, __last,
                                       ::std::priv:: __less((typename ::std::iterator_traits< _BidirectionalIter >::value_type*)0));
}

template <class _BidirectionalIter, class _Compare>
bool next_permutation(_BidirectionalIter __first, _BidirectionalIter __last,
                      _Compare __comp) {
 
  return ::std::priv:: __next_permutation(__first, __last, __comp);
}

namespace priv {

template <class _BidirectionalIter, class _Compare>
bool __prev_permutation(_BidirectionalIter __first, _BidirectionalIter __last,
                        _Compare __comp) {
  if (__first == __last)
    return false;
  _BidirectionalIter __i = __first;
  ++__i;
  if (__i == __last)
    return false;
  __i = __last;
  --__i;

  for(;;) {
    _BidirectionalIter __ii = __i;
    --__i;
    if (__comp(*__ii, *__i)) {
     
      _BidirectionalIter __j = __last;
      while (!__comp(*--__j, *__i)) {}
      iter_swap(__i, __j);
      reverse(__ii, __last);
      return true;
    }
    if (__i == __first) {
      reverse(__first, __last);
      return false;
    }
  }



}

}

template <class _BidirectionalIter>
bool prev_permutation(_BidirectionalIter __first, _BidirectionalIter __last) {
 
  return ::std::priv:: __prev_permutation(__first, __last,
                                       ::std::priv:: __less((typename ::std::iterator_traits< _BidirectionalIter >::value_type*)0));
}

template <class _BidirectionalIter, class _Compare>
bool prev_permutation(_BidirectionalIter __first, _BidirectionalIter __last,
                      _Compare __comp) {
 
  return ::std::priv:: __prev_permutation(__first, __last, __comp);
}






namespace priv {

template <class _RandomAccessIter, class _Distance, class _StrictWeakOrdering>
bool __is_heap(_RandomAccessIter __first, _StrictWeakOrdering __comp,
               _Distance __n) {
  _Distance __parent = 0;
  for (_Distance __child = 1; __child < __n; ++__child) {
    if (__comp(__first[__parent], __first[__child])) {
     
      return false;
    }
    if ((__child & 1) == 0)
      ++__parent;
  }
  return true;
}

}

template <class _RandomAccessIter>
bool is_heap(_RandomAccessIter __first, _RandomAccessIter __last) {
 
  return ::std::priv:: __is_heap(__first, ::std::priv:: __less((typename ::std::iterator_traits< _RandomAccessIter >::value_type*)0), __last - __first);
}

template <class _RandomAccessIter, class _StrictWeakOrdering>
bool is_heap(_RandomAccessIter __first, _RandomAccessIter __last,
             _StrictWeakOrdering __comp) {
 
  return ::std::priv:: __is_heap(__first, __comp, __last - __first);
}


namespace priv {

template <class _ForwardIter, class _StrictWeakOrdering>
bool __is_sorted(_ForwardIter __first, _ForwardIter __last,
                 _StrictWeakOrdering __comp) {
 
  if (__first == __last)
    return true;

  _ForwardIter __next = __first;
  for (++__next; __next != __last; __first = __next, ++__next) {
    if (__comp(*__next, *__first)) {
     
      return false;
    }
  }

  return true;
}

}


}
# 738 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_algo.h" 2
# 42 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/algorithm" 2
# 54 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/algorithm"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_epilog.h" 1
# 19 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_epilog.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_config_compat_post.h" 1
# 20 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_epilog.h" 2
# 55 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/algorithm" 2
# 41 "webkey-2.09/service/webkey.cpp" 2


# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/netdb.h" 1
# 66 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/netdb.h"
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/socket.h" 1
# 33 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/socket.h"
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/linux/socket.h" 1
# 18 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/linux/socket.h"
struct __kernel_sockaddr_storage {
 unsigned short ss_family;

 char __data[128 - sizeof(unsigned short)];

} __attribute__ ((aligned((__alignof__ (struct sockaddr *)))));



# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/asm/socket.h" 1
# 15 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/asm/socket.h"
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/asm/sockios.h" 1
# 16 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/asm/socket.h" 2
# 28 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/linux/socket.h" 2
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/linux/sockios.h" 1
# 29 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/linux/socket.h" 2
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/linux/uio.h" 1
# 18 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/linux/uio.h"
struct iovec
{
 void *iov_base;
 __kernel_size_t iov_len;
};
# 30 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/linux/socket.h" 2



typedef unsigned short sa_family_t;

struct sockaddr {
 sa_family_t sa_family;
 char sa_data[14];
};

struct linger {
 int l_onoff;
 int l_linger;
};



struct msghdr {
 void * msg_name;
 int msg_namelen;
 struct iovec * msg_iov;
 __kernel_size_t msg_iovlen;
 void * msg_control;
 __kernel_size_t msg_controllen;
 unsigned msg_flags;
};

struct cmsghdr {
 __kernel_size_t cmsg_len;
 int cmsg_level;
 int cmsg_type;
};
# 84 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/linux/socket.h"
static __inline__ struct cmsghdr * __cmsg_nxthdr(void *__ctl, __kernel_size_t __size,
 struct cmsghdr *__cmsg)
{
 struct cmsghdr * __ptr;

 __ptr = (struct cmsghdr*)(((unsigned char *) __cmsg) + ( ((__cmsg->cmsg_len)+sizeof(long)-1) & ~(sizeof(long)-1) ));
 if ((unsigned long)((char*)(__ptr+1) - (char *) __ctl) > __size)
 return (struct cmsghdr *)0;

 return __ptr;
}

static __inline__ struct cmsghdr * cmsg_nxthdr (struct msghdr *__msg, struct cmsghdr *__cmsg)
{
 return __cmsg_nxthdr(__msg->msg_control, __msg->msg_controllen, __cmsg);
}





struct ucred {
 __u32 pid;
 __u32 uid;
 __u32 gid;
};
# 34 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/socket.h" 2

extern "C" {
# 51 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/socket.h"
enum {
    SHUT_RD = 0,

    SHUT_WR,

    SHUT_RDWR

};


typedef int socklen_t;

extern int socket(int, int, int);
extern int bind(int, const struct sockaddr *, int);
extern int connect(int, const struct sockaddr *, socklen_t);
extern int listen(int, int);
extern int accept(int, struct sockaddr *, socklen_t *);
extern int getsockname(int, struct sockaddr *, socklen_t *);
extern int getpeername(int, struct sockaddr *, socklen_t *);
extern int socketpair(int, int, int, int *);
extern int shutdown(int, int);
extern int setsockopt(int, int, int, const void *, socklen_t);
extern int getsockopt(int, int, int, void *, socklen_t *);
extern int sendmsg(int, const struct msghdr *, unsigned int);
extern int recvmsg(int, struct msghdr *, unsigned int);

extern ssize_t send(int, const void *, size_t, unsigned int);
extern ssize_t recv(int, void *, size_t, unsigned int);

extern ssize_t sendto(int, const void *, size_t, int, const struct sockaddr *, socklen_t);
extern ssize_t recvfrom(int, void *, size_t, unsigned int, const struct sockaddr *, socklen_t *);



}
# 67 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/netdb.h" 2
# 84 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/netdb.h"
struct hostent {
 char *h_name;
 char **h_aliases;
 int h_addrtype;
 int h_length;
 char **h_addr_list;

};

struct netent {
 char *n_name;
 char **n_aliases;
 int n_addrtype;
 uint32_t n_net;
};

struct servent {
 char *s_name;
 char **s_aliases;
 int s_port;
 char *s_proto;
};

struct protoent {
 char *p_name;
 char **p_aliases;
 int p_proto;
};

struct addrinfo {
 int ai_flags;
 int ai_family;
 int ai_socktype;
 int ai_protocol;
 socklen_t ai_addrlen;
 char *ai_canonname;
 struct sockaddr *ai_addr;
 struct addrinfo *ai_next;
};
# 198 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/netdb.h"
extern "C" {


int* __get_h_errno(void);

void endservent(void);
struct hostent *gethostbyaddr(const char *, int, int);
struct hostent *gethostbyname(const char *);
int gethostbyname_r(const char *, struct hostent *, char *, size_t, struct hostent **, int *);
struct hostent *gethostbyname2(const char *, int);
struct hostent *gethostent(void);
struct netent *getnetbyaddr(uint32_t, int);
struct netent *getnetbyname(const char *);
struct protoent *getprotobyname(const char *);
struct protoent *getprotobynumber(int);
struct servent *getservbyname(const char *, const char *);
struct servent *getservbyport(int, const char *);
struct servent *getservent(void);
void herror(const char *);
const char *hstrerror(int);
int getaddrinfo(const char *, const char *, const struct addrinfo *, struct addrinfo **);
int getnameinfo(const struct sockaddr *, socklen_t, char *, size_t, char *, size_t, int);
void freeaddrinfo(struct addrinfo *);
const char *gai_strerror(int);
void setservent(int);
# 251 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/netdb.h"
}
# 44 "webkey-2.09/service/webkey.cpp" 2

# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/wait.h" 1
# 33 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/wait.h"
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/resource.h" 1
# 40 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/resource.h"
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/linux/resource.h" 1
# 17 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/linux/resource.h"
struct task_struct;





struct rusage {
 struct timeval ru_utime;
 struct timeval ru_stime;
 long ru_maxrss;
 long ru_ixrss;
 long ru_idrss;
 long ru_isrss;
 long ru_minflt;
 long ru_majflt;
 long ru_nswap;
 long ru_inblock;
 long ru_oublock;
 long ru_msgsnd;
 long ru_msgrcv;
 long ru_nsignals;
 long ru_nvcsw;
 long ru_nivcsw;
};

struct rlimit {
 unsigned long rlim_cur;
 unsigned long rlim_max;
};
# 58 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/linux/resource.h"
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/asm/resource.h" 1
# 15 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/asm/resource.h"
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/asm-generic/resource.h" 1
# 16 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/asm/resource.h" 2
# 59 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/linux/resource.h" 2
# 41 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/resource.h" 2


typedef unsigned long rlim_t;

extern "C" {

extern int getpriority(int, int);
extern int setpriority(int, int, int);
extern int getrlimit(int resource, struct rlimit *rlp);
extern int setrlimit(int resource, const struct rlimit *rlp);
extern int getrusage(int who, struct rusage* r_usage);

}
# 34 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/wait.h" 2
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/linux/wait.h" 1
# 35 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/wait.h" 2

extern "C" {
# 47 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/wait.h"
extern pid_t wait(int *);
extern pid_t waitpid(pid_t, int *, int);
extern pid_t wait3(int *, int, struct rusage *);
extern pid_t wait4(pid_t, int *, int, struct rusage *);

}
# 46 "webkey-2.09/service/webkey.cpp" 2


# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/mman.h" 1
# 33 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/mman.h"
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/asm/mman.h" 1
# 15 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/asm/mman.h"
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/asm-generic/mman.h" 1
# 16 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/asm/mman.h" 2
# 34 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/mman.h" 2
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/asm/page.h" 1
# 35 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/mman.h" 2

extern "C" {
# 47 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/mman.h"
extern void* mmap(void *, size_t, int, int, int, off_t);
extern int munmap(void *, size_t);
extern int msync(const void *, size_t, int);
extern int mprotect(const void *, size_t, int);
extern void* mremap(void *, size_t, size_t, unsigned long);

extern int mlockall(int);
extern int munlockall(void);
extern int mlock(const void *, size_t);
extern int munlock(const void *, size_t);
extern int madvise(const void *, size_t, int);

extern int mlock(const void *addr, size_t len);
extern int munlock(const void *addr, size_t len);

extern int mincore(void* start, size_t length, unsigned char* vec);

}
# 49 "webkey-2.09/service/webkey.cpp" 2
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/netinet/in.h" 1
# 33 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/netinet/in.h"
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/linux/in.h" 1
# 18 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/linux/in.h"
enum {
 IPPROTO_IP = 0,
 IPPROTO_ICMP = 1,
 IPPROTO_IGMP = 2,
 IPPROTO_IPIP = 4,
 IPPROTO_TCP = 6,
 IPPROTO_EGP = 8,
 IPPROTO_PUP = 12,
 IPPROTO_UDP = 17,
 IPPROTO_IDP = 22,
 IPPROTO_DCCP = 33,
 IPPROTO_RSVP = 46,
 IPPROTO_GRE = 47,

 IPPROTO_IPV6 = 41,

 IPPROTO_ESP = 50,
 IPPROTO_AH = 51,
 IPPROTO_PIM = 103,

 IPPROTO_COMP = 108,
 IPPROTO_SCTP = 132,

 IPPROTO_RAW = 255,
 IPPROTO_MAX
};

struct in_addr {
 __u32 s_addr;
};
# 98 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/linux/in.h"
struct ip_mreq
{
 struct in_addr imr_multiaddr;
 struct in_addr imr_interface;
};

struct ip_mreqn
{
 struct in_addr imr_multiaddr;
 struct in_addr imr_address;
 int imr_ifindex;
};

struct ip_mreq_source {
 __u32 imr_multiaddr;
 __u32 imr_interface;
 __u32 imr_sourceaddr;
};

struct ip_msfilter {
 __u32 imsf_multiaddr;
 __u32 imsf_interface;
 __u32 imsf_fmode;
 __u32 imsf_numsrc;
 __u32 imsf_slist[1];
};



struct group_req
{
 __u32 gr_interface;
 struct __kernel_sockaddr_storage gr_group;
};

struct group_source_req
{
 __u32 gsr_interface;
 struct __kernel_sockaddr_storage gsr_group;
 struct __kernel_sockaddr_storage gsr_source;
};

struct group_filter
{
 __u32 gf_interface;
 struct __kernel_sockaddr_storage gf_group;
 __u32 gf_fmode;
 __u32 gf_numsrc;
 struct __kernel_sockaddr_storage gf_slist[1];
};



struct in_pktinfo
{
 int ipi_ifindex;
 struct in_addr ipi_spec_dst;
 struct in_addr ipi_addr;
};


struct sockaddr_in {
 sa_family_t sin_family;
 unsigned short int sin_port;
 struct in_addr sin_addr;

 unsigned char __pad[16 - sizeof(short int) -
 sizeof(unsigned short int) - sizeof(struct in_addr)];
};
# 209 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/linux/in.h"
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/asm/byteorder.h" 1
# 18 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/asm/byteorder.h"
static inline __u32 ___arch__swab32(__u32 x)
{
 __u32 t;







 t = x ^ ((x << 16) | (x >> 16));

 x = (x << 24) | (x >> 8);
 t &= ~0x00FF0000;
 x ^= (t >> 8);

 return x;
}
# 47 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/asm/byteorder.h"
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/linux/byteorder/little_endian.h" 1
# 23 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/linux/byteorder/little_endian.h"
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/linux/byteorder/swab.h" 1
# 24 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/linux/byteorder/little_endian.h" 2
# 66 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/linux/byteorder/little_endian.h"
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/linux/byteorder/generic.h" 1
# 67 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/linux/byteorder/little_endian.h" 2
# 48 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/asm/byteorder.h" 2
# 210 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/linux/in.h" 2
# 34 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/netinet/in.h" 2
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/linux/in6.h" 1
# 17 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/linux/in6.h"
struct in6_addr
{
 union
 {
 __u8 u6_addr8[16];
 __u16 u6_addr16[8];
 __u32 u6_addr32[4];
 } in6_u;



};



struct sockaddr_in6 {
 unsigned short int sin6_family;
 __u16 sin6_port;
 __u32 sin6_flowinfo;
 struct in6_addr sin6_addr;
 __u32 sin6_scope_id;
};

struct ipv6_mreq {

 struct in6_addr ipv6mr_multiaddr;

 int ipv6mr_ifindex;
};



struct in6_flowlabel_req
{
 struct in6_addr flr_dst;
 __u32 flr_label;
 __u8 flr_action;
 __u8 flr_share;
 __u16 flr_flags;
 __u16 flr_expires;
 __u16 flr_linger;
 __u32 __flr_pad;

};
# 35 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/netinet/in.h" 2
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/linux/ipv6.h" 1
# 21 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/linux/ipv6.h"
struct in6_pktinfo {
 struct in6_addr ipi6_addr;
 int ipi6_ifindex;
};

struct ip6_mtuinfo {
 struct sockaddr_in6 ip6m_addr;
 __u32 ip6m_mtu;
};

struct in6_ifreq {
 struct in6_addr ifr6_addr;
 __u32 ifr6_prefixlen;
 int ifr6_ifindex;
};





struct ipv6_rt_hdr {
 __u8 nexthdr;
 __u8 hdrlen;
 __u8 type;
 __u8 segments_left;

};

struct ipv6_opt_hdr {
 __u8 nexthdr;
 __u8 hdrlen;

} __attribute__((packed));




struct rt0_hdr {
 struct ipv6_rt_hdr rt_hdr;
 __u32 reserved;
 struct in6_addr addr[0];


};

struct rt2_hdr {
 struct ipv6_rt_hdr rt_hdr;
 __u32 reserved;
 struct in6_addr addr;


};

struct ipv6_destopt_hao {
 __u8 type;
 __u8 length;
 struct in6_addr addr;
} __attribute__((packed));

struct ipv6hdr {

 __u8 priority:4,
 version:4;






 __u8 flow_lbl[3];

 __be16 payload_len;
 __u8 nexthdr;
 __u8 hop_limit;

 struct in6_addr saddr;
 struct in6_addr daddr;
};

enum {
 DEVCONF_FORWARDING = 0,
 DEVCONF_HOPLIMIT,
 DEVCONF_MTU6,
 DEVCONF_ACCEPT_RA,
 DEVCONF_ACCEPT_REDIRECTS,
 DEVCONF_AUTOCONF,
 DEVCONF_DAD_TRANSMITS,
 DEVCONF_RTR_SOLICITS,
 DEVCONF_RTR_SOLICIT_INTERVAL,
 DEVCONF_RTR_SOLICIT_DELAY,
 DEVCONF_USE_TEMPADDR,
 DEVCONF_TEMP_VALID_LFT,
 DEVCONF_TEMP_PREFERED_LFT,
 DEVCONF_REGEN_MAX_RETRY,
 DEVCONF_MAX_DESYNC_FACTOR,
 DEVCONF_MAX_ADDRESSES,
 DEVCONF_FORCE_MLD_VERSION,
 DEVCONF_ACCEPT_RA_DEFRTR,
 DEVCONF_ACCEPT_RA_PINFO,
 DEVCONF_ACCEPT_RA_RTR_PREF,
 DEVCONF_RTR_PROBE_INTERVAL,
 DEVCONF_ACCEPT_RA_RT_INFO_MAX_PLEN,
 DEVCONF_PROXY_NDP,
 DEVCONF_OPTIMISTIC_DAD,
 DEVCONF_ACCEPT_SOURCE_ROUTE,
 DEVCONF_MC_FORWARDING,
 DEVCONF_DISABLE_IPV6,
 DEVCONF_ACCEPT_DAD,
 DEVCONF_FORCE_TLLAO,
 DEVCONF_MAX
};
# 36 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/netinet/in.h" 2
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/netinet/in6.h" 1
# 37 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/netinet/in.h" 2

extern "C" {





extern int bindresvport (int sd, struct sockaddr_in *sin);

static const struct in6_addr in6addr_any = {{{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}}};
static const struct in6_addr in6addr_loopback = { { { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1 } } };

}
# 50 "webkey-2.09/service/webkey.cpp" 2
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/arpa/inet.h" 1
# 35 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/arpa/inet.h"
extern "C" {

typedef uint32_t in_addr_t;

extern uint32_t inet_addr(const char *);

extern int inet_aton(const char *, struct in_addr *);
extern char* inet_ntoa(struct in_addr);

extern int inet_pton(int, const char *, void *);
extern const char* inet_ntop(int, const void *, char *, size_t);

extern unsigned int inet_nsap_addr(const char *, unsigned char *, int);
extern char* inet_nsap_ntoa(int, const unsigned char *, char *);

}
# 51 "webkey-2.09/service/webkey.cpp" 2


# 1 "webkey-2.09/service/suinput.h" 1
# 24 "webkey-2.09/service/suinput.h"
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/linux/input.h" 1
# 16 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/linux/input.h"
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/ioctl.h" 1
# 32 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/ioctl.h"
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/linux/ioctl.h" 1
# 15 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/linux/ioctl.h"
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/asm/ioctl.h" 1
# 12 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/asm/ioctl.h"
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/asm-generic/ioctl.h" 1
# 36 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/asm-generic/ioctl.h"
extern unsigned int __invalid_size_argument_for_IOC;
# 12 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/asm/ioctl.h" 2
# 16 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/linux/ioctl.h" 2
# 33 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/ioctl.h" 2
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/asm/ioctls.h" 1
# 15 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/asm/ioctls.h"
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/asm/ioctl.h" 1
# 16 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/asm/ioctls.h" 2
# 34 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/ioctl.h" 2
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/asm/termbits.h" 1
# 15 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/asm/termbits.h"
typedef unsigned char cc_t;
typedef unsigned int speed_t;
typedef unsigned int tcflag_t;


struct termios {
 tcflag_t c_iflag;
 tcflag_t c_oflag;
 tcflag_t c_cflag;
 tcflag_t c_lflag;
 cc_t c_line;
 cc_t c_cc[19];
};
# 35 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/ioctl.h" 2
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/ioctl_compat.h" 1
# 45 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/ioctl_compat.h"
struct tchars {
 char t_intrc;
 char t_quitc;
 char t_startc;
 char t_stopc;
 char t_eofc;
 char t_brkc;
};

struct ltchars {
 char t_suspc;
 char t_dsuspc;
 char t_rprntc;
 char t_flushc;
 char t_werasc;
 char t_lnextc;
};






struct sgttyb {
 char sg_ispeed;
 char sg_ospeed;
 char sg_erase;
 char sg_kill;
 short sg_flags;
};
# 36 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/ioctl.h" 2

extern "C" {

extern int ioctl(int, int, ...);

}
# 17 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/linux/input.h" 2



struct input_event {
 struct timeval time;
 __u16 type;
 __u16 code;
 __s32 value;
};



struct input_id {
 __u16 bustype;
 __u16 vendor;
 __u16 product;
 __u16 version;
};

struct input_absinfo {
 __s32 value;
 __s32 minimum;
 __s32 maximum;
 __s32 fuzz;
 __s32 flat;
};
# 616 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/linux/input.h"
struct ff_replay {
 __u16 length;
 __u16 delay;
};

struct ff_trigger {
 __u16 button;
 __u16 interval;
};

struct ff_envelope {
 __u16 attack_length;
 __u16 attack_level;
 __u16 fade_length;
 __u16 fade_level;
};

struct ff_constant_effect {
 __s16 level;
 struct ff_envelope envelope;
};

struct ff_ramp_effect {
 __s16 start_level;
 __s16 end_level;
 struct ff_envelope envelope;
};

struct ff_condition_effect {
 __u16 right_saturation;
 __u16 left_saturation;

 __s16 right_coeff;
 __s16 left_coeff;

 __u16 deadband;
 __s16 center;

};

struct ff_periodic_effect {
 __u16 waveform;
 __u16 period;
 __s16 magnitude;
 __s16 offset;
 __u16 phase;

 struct ff_envelope envelope;

 __u32 custom_len;
 __s16 *custom_data;

};

struct ff_rumble_effect {
 __u16 strong_magnitude;
 __u16 weak_magnitude;
};

struct ff_effect {
 __u16 type;

 __s16 id;

 __u16 direction;

 struct ff_trigger trigger;
 struct ff_replay replay;

 union {
 struct ff_constant_effect constant;
 struct ff_ramp_effect ramp;
 struct ff_periodic_effect periodic;
 struct ff_condition_effect condition[2];
 struct ff_rumble_effect rumble;
 } u;
};
# 25 "webkey-2.09/service/suinput.h" 2


int suinput_mouse(int uinput_fd,
   int32_t x, int32_t y, int32_t down);
# 37 "webkey-2.09/service/suinput.h"
int suinput_open(const char* device_name, const struct input_id* id, bool mouse);
# 46 "webkey-2.09/service/suinput.h"
int suinput_close(int uinput_fd);
# 56 "webkey-2.09/service/suinput.h"
int suinput_move_pointer(int uinput_fd, int32_t x, int32_t y);
# 69 "webkey-2.09/service/suinput.h"
int suinput_press(int uinput_fd, uint16_t code);
# 81 "webkey-2.09/service/suinput.h"
int suinput_release(int uinput_fd, uint16_t code);
# 96 "webkey-2.09/service/suinput.h"
int suinput_click(int uinput_fd, uint16_t code, long time = 0);
# 54 "webkey-2.09/service/webkey.cpp" 2






# 1 "webkey-2.09/service/KeycodeLabels.h" 1
# 20 "webkey-2.09/service/KeycodeLabels.h"
struct KeycodeLabel {
    const char *literal;
    int value;
};

static const KeycodeLabel KEYCODES[] = {
    { "SOFT_LEFT", 1 },
    { "SOFT_RIGHT", 2 },
    { "HOME", 3 },
    { "BACK", 4 },
    { "CALL", 5 },
    { "ENDCALL", 6 },
    { "0", 7 },
    { "1", 8 },
    { "2", 9 },
    { "3", 10 },
    { "4", 11 },
    { "5", 12 },
    { "6", 13 },
    { "7", 14 },
    { "8", 15 },
    { "9", 16 },
    { "STAR", 17 },
    { "POUND", 18 },
    { "DPAD_UP", 19 },
    { "DPAD_DOWN", 20 },
    { "DPAD_LEFT", 21 },
    { "DPAD_RIGHT", 22 },
    { "DPAD_CENTER", 23 },
    { "VOLUME_UP", 24 },
    { "VOLUME_DOWN", 25 },
    { "POWER", 26 },
    { "CAMERA", 27 },
    { "CLEAR", 28 },
    { "A", 29 },
    { "B", 30 },
    { "C", 31 },
    { "D", 32 },
    { "E", 33 },
    { "F", 34 },
    { "G", 35 },
    { "H", 36 },
    { "I", 37 },
    { "J", 38 },
    { "K", 39 },
    { "L", 40 },
    { "M", 41 },
    { "N", 42 },
    { "O", 43 },
    { "P", 44 },
    { "Q", 45 },
    { "R", 46 },
    { "S", 47 },
    { "T", 48 },
    { "U", 49 },
    { "V", 50 },
    { "W", 51 },
    { "X", 52 },
    { "Y", 53 },
    { "Z", 54 },
    { "COMMA", 55 },
    { "PERIOD", 56 },
    { "ALT_LEFT", 57 },
    { "ALT_RIGHT", 58 },
    { "SHIFT_LEFT", 59 },
    { "SHIFT_RIGHT", 60 },
    { "TAB", 61 },
    { "SPACE", 62 },
    { "SYM", 63 },
    { "EXPLORER", 64 },
    { "ENVELOPE", 65 },
    { "ENTER", 66 },
    { "DEL", 67 },
    { "GRAVE", 68 },
    { "MINUS", 69 },
    { "EQUALS", 70 },
    { "LEFT_BRACKET", 71 },
    { "RIGHT_BRACKET", 72 },
    { "BACKSLASH", 73 },
    { "SEMICOLON", 74 },
    { "APOSTROPHE", 75 },
    { "SLASH", 76 },
    { "AT", 77 },
    { "NUM", 78 },
    { "HEADSETHOOK", 79 },
    { "FOCUS", 80 },
    { "PLUS", 81 },
    { "MENU", 82 },
    { "NOTIFICATION", 83 },
    { "SEARCH", 84 },
    { "MEDIA_PLAY_PAUSE", 85 },
    { "MEDIA_STOP", 86 },
    { "MEDIA_NEXT", 87 },
    { "MEDIA_PREVIOUS", 88 },
    { "MEDIA_REWIND", 89 },
    { "MEDIA_FAST_FORWARD", 90 },
    { "MUTE", 91 },







    { __null, 0 }
};


typedef enum KeyCode {
    kKeyCodeUnknown = 0,

    kKeyCodeSoftLeft = 1,
    kKeyCodeSoftRight = 2,
    kKeyCodeHome = 3,
    kKeyCodeBack = 4,
    kKeyCodeCall = 5,
    kKeyCodeEndCall = 6,
    kKeyCode0 = 7,
    kKeyCode1 = 8,
    kKeyCode2 = 9,
    kKeyCode3 = 10,
    kKeyCode4 = 11,
    kKeyCode5 = 12,
    kKeyCode6 = 13,
    kKeyCode7 = 14,
    kKeyCode8 = 15,
    kKeyCode9 = 16,
    kKeyCodeStar = 17,
    kKeyCodePound = 18,
    kKeyCodeDpadUp = 19,
    kKeyCodeDpadDown = 20,
    kKeyCodeDpadLeft = 21,
    kKeyCodeDpadRight = 22,
    kKeyCodeDpadCenter = 23,
    kKeyCodeVolumeUp = 24,
    kKeyCodeVolumeDown = 25,
    kKeyCodePower = 26,
    kKeyCodeCamera = 27,
    kKeyCodeClear = 28,
    kKeyCodeA = 29,
    kKeyCodeB = 30,
    kKeyCodeC = 31,
    kKeyCodeD = 32,
    kKeyCodeE = 33,
    kKeyCodeF = 34,
    kKeyCodeG = 35,
    kKeyCodeH = 36,
    kKeyCodeI = 37,
    kKeyCodeJ = 38,
    kKeyCodeK = 39,
    kKeyCodeL = 40,
    kKeyCodeM = 41,
    kKeyCodeN = 42,
    kKeyCodeO = 43,
    kKeyCodeP = 44,
    kKeyCodeQ = 45,
    kKeyCodeR = 46,
    kKeyCodeS = 47,
    kKeyCodeT = 48,
    kKeyCodeU = 49,
    kKeyCodeV = 50,
    kKeyCodeW = 51,
    kKeyCodeX = 52,
    kKeyCodeY = 53,
    kKeyCodeZ = 54,
    kKeyCodeComma = 55,
    kKeyCodePeriod = 56,
    kKeyCodeAltLeft = 57,
    kKeyCodeAltRight = 58,
    kKeyCodeShiftLeft = 59,
    kKeyCodeShiftRight = 60,
    kKeyCodeTab = 61,
    kKeyCodeSpace = 62,
    kKeyCodeSym = 63,
    kKeyCodeExplorer = 64,
    kKeyCodeEnvelope = 65,
    kKeyCodeNewline = 66,
    kKeyCodeDel = 67,
    kKeyCodeGrave = 68,
    kKeyCodeMinus = 69,
    kKeyCodeEquals = 70,
    kKeyCodeLeftBracket = 71,
    kKeyCodeRightBracket = 72,
    kKeyCodeBackslash = 73,
    kKeyCodeSemicolon = 74,
    kKeyCodeApostrophe = 75,
    kKeyCodeSlash = 76,
    kKeyCodeAt = 77,
    kKeyCodeNum = 78,
    kKeyCodeHeadSetHook = 79,
    kKeyCodeFocus = 80,
    kKeyCodePlus = 81,
    kKeyCodeMenu = 82,
    kKeyCodeNotification = 83,
    kKeyCodeSearch = 84,
    kKeyCodePlayPause = 85,
    kKeyCodeStop = 86,
    kKeyCodeNextSong = 87,
    kKeyCodePreviousSong = 88,
    kKeyCodeRewind = 89,
    kKeyCodeForward = 90,
    kKeyCodeMute = 91
} KeyCode;

static const KeycodeLabel FLAGS[] = {
    { "WAKE", 0x00000001 },
    { "WAKE_DROPPED", 0x00000002 },
    { "SHIFT", 0x00000004 },
    { "CAPS_LOCK", 0x00000008 },
    { "ALT", 0x00000010 },
    { "ALT_GR", 0x00000020 },
    { "MENU", 0x00000040 },
    { "LAUNCHER", 0x00000080 },
    { __null, 0 }
};
# 61 "webkey-2.09/service/webkey.cpp" 2
# 1 "webkey-2.09/service/kcm.h" 1





# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/string" 1
# 23 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/string"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_prolog.h" 1






# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_cprolog.h" 1
# 8 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_prolog.h" 2
# 24 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/string" 2





# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_string.h" 1
# 27 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_string.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_string_fwd.h" 1
# 23 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_string_fwd.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_iosfwd.h" 1
# 22 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_iosfwd.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/char_traits.h" 1
# 48 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/char_traits.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_cwchar.h" 1
# 68 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_cwchar.h"
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/../include/wchar.h" 1
# 36 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/../include/wchar.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stddef.h" 1
# 34 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stddef.h"
# 1 "/home/petya/download/android-ndk-r8b/toolchains/arm-linux-androideabi-4.4.3/prebuilt/linux-x86/bin/../lib/gcc/arm-linux-androideabi/4.4.3/include/../include/stddef.h" 1 3 4
# 35 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stddef.h" 2
# 37 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/../include/wchar.h" 2

# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stdarg.h" 1
# 39 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/../include/wchar.h" 2



# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stddef.h" 1
# 34 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stddef.h"
# 1 "/home/petya/download/android-ndk-r8b/toolchains/arm-linux-androideabi-4.4.3/prebuilt/linux-x86/bin/../lib/gcc/arm-linux-androideabi/4.4.3/include/../include/stddef.h" 1 3 4
# 35 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stddef.h" 2
# 43 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/../include/wchar.h" 2
# 51 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/../include/wchar.h"
extern "C" {

typedef int wint_t;
typedef struct { int dummy; } mbstate_t;

typedef enum {
    WC_TYPE_INVALID = 0,
    WC_TYPE_ALNUM,
    WC_TYPE_ALPHA,
    WC_TYPE_BLANK,
    WC_TYPE_CNTRL,
    WC_TYPE_DIGIT,
    WC_TYPE_GRAPH,
    WC_TYPE_LOWER,
    WC_TYPE_PRINT,
    WC_TYPE_PUNCT,
    WC_TYPE_SPACE,
    WC_TYPE_UPPER,
    WC_TYPE_XDIGIT,
    WC_TYPE_MAX
} wctype_t;





extern wint_t btowc(int);
extern int fwprintf(FILE *, const wchar_t *, ...);
extern int fwscanf(FILE *, const wchar_t *, ...);
extern int iswalnum(wint_t);
extern int iswalpha(wint_t);
extern int iswcntrl(wint_t);
extern int iswdigit(wint_t);
extern int iswgraph(wint_t);
extern int iswlower(wint_t);
extern int iswprint(wint_t);
extern int iswpunct(wint_t);
extern int iswspace(wint_t);
extern int iswupper(wint_t);
extern int iswxdigit(wint_t);
extern int iswctype(wint_t, wctype_t);
extern wint_t fgetwc(FILE *);
extern wchar_t *fgetws(wchar_t *, int, FILE *);
extern wint_t fputwc(wchar_t, FILE *);
extern int fputws(const wchar_t *, FILE *);
extern int fwide(FILE *, int);
extern wint_t getwc(FILE *);
extern wint_t getwchar(void);
extern int mbsinit(const mbstate_t *);
extern size_t mbrlen(const char *, size_t, mbstate_t *);
extern size_t mbrtowc(wchar_t *, const char *, size_t, mbstate_t *);
extern size_t mbsrtowcs(wchar_t *, const char **, size_t, mbstate_t *);
extern wint_t putwc(wchar_t, FILE *);
extern wint_t putwchar(wchar_t);
extern int swprintf(wchar_t *, size_t, const wchar_t *, ...);
extern int swscanf(const wchar_t *, const wchar_t *, ...);
extern wint_t towlower(wint_t);
extern wint_t towupper(wint_t);
extern wint_t ungetwc(wint_t, FILE *);
extern int vfwprintf(FILE *, const wchar_t *, va_list);
extern int vwprintf(const wchar_t *, va_list);
extern int vswprintf(wchar_t *, size_t, const wchar_t *, va_list);
extern size_t wcrtomb(char *, wchar_t, mbstate_t *);
extern wchar_t *wcscat(wchar_t *, const wchar_t *);
extern wchar_t *wcschr(const wchar_t *, wchar_t);
extern int wcscmp(const wchar_t *, const wchar_t *);
extern int wcscoll(const wchar_t *, const wchar_t *);
extern wchar_t *wcscpy(wchar_t *, const wchar_t *);
extern size_t wcscspn(const wchar_t *, const wchar_t *);
extern size_t wcsftime(wchar_t *, size_t, const wchar_t *, const struct tm *);
extern size_t wcslen(const wchar_t *);
extern wchar_t *wcsncat(wchar_t *, const wchar_t *, size_t);
extern int wcsncmp(const wchar_t *, const wchar_t *, size_t);
extern wchar_t *wcsncpy(wchar_t *, const wchar_t *, size_t);
extern wchar_t *wcspbrk(const wchar_t *, const wchar_t *);
extern wchar_t *wcsrchr(const wchar_t *, wchar_t);
extern size_t wcsrtombs(char *, const wchar_t **, size_t, mbstate_t *);
extern size_t wcsspn(const wchar_t *, const wchar_t *);
extern wchar_t *wcsstr(const wchar_t *, const wchar_t *);
extern double wcstod(const wchar_t *, wchar_t **);
extern wchar_t *wcstok(wchar_t *, const wchar_t *, wchar_t **);
extern long int wcstol(const wchar_t *, wchar_t **, int);
extern unsigned long int wcstoul(const wchar_t *, wchar_t **, int);
extern wchar_t *wcswcs(const wchar_t *, const wchar_t *);
extern int wcswidth(const wchar_t *, size_t);
extern size_t wcsxfrm(wchar_t *, const wchar_t *, size_t);
extern int wctob(wint_t);
extern wctype_t wctype(const char *);
extern int wcwidth(wchar_t);
extern wchar_t *wmemchr(const wchar_t *, wchar_t, size_t);
extern int wmemcmp(const wchar_t *, const wchar_t *, size_t);
extern wchar_t *wmemcpy(wchar_t *, const wchar_t *, size_t);
extern wchar_t *wmemmove(wchar_t *, const wchar_t *, size_t);
extern wchar_t *wmemset(wchar_t *, wchar_t, size_t);
extern int wprintf(const wchar_t *, ...);
extern int wscanf(const wchar_t *, ...);


typedef void *wctrans_t;
extern wint_t towctrans(wint_t, wctrans_t);
extern wctrans_t wctrans (const char *);

}
# 69 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_cwchar.h" 2
# 113 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_cwchar.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_mbstate_t.h" 1
# 114 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_cwchar.h" 2
# 170 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_cwchar.h"
namespace std {







using ::wint_t;





using ::size_t;


using ::mbstate_t;
# 213 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_cwchar.h"
using ::fgetwc;
using ::fgetws;
using ::fputwc;
using ::fputws;





using ::fwide;

using ::fwprintf;
using ::fwscanf;
using ::getwchar;




using ::getwc;

using ::ungetwc;

using ::putwc;

using ::putwchar;
# 251 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_cwchar.h"
using ::swprintf;
using ::vswprintf;

using ::swscanf;
using ::vfwprintf;
using ::vwprintf;




using ::wcsftime;

using ::wcstok;




using ::wcscoll;
using ::wcsxfrm;

using ::wcscat;
using ::wcsrchr;
using ::wcscmp;

using ::wcscpy;
using ::wcscspn;

using ::wcslen;
using ::wcsncat;
using ::wcsncmp;
using ::wcsncpy;
using ::wcspbrk;
using ::wcschr;

using ::wcsspn;


using ::wcstod;
using ::wcstol;



using ::wcsstr;
using ::wmemchr;



using ::wctob;


using ::wmemcmp;
using ::wmemmove;

using ::wprintf;
using ::wscanf;
# 327 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_cwchar.h"
using ::wmemcpy;
using ::wmemset;




}
# 49 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/char_traits.h" 2


namespace std {

template <class _Tp> class allocator;
# 74 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/char_traits.h"
typedef off_t streamoff;






typedef ptrdiff_t streamsize;





template <class _StateT> class fpos {
public:
  fpos(streamoff __pos) : _M_pos(__pos), _M_st(_StateT()) {}
  fpos() : _M_pos(0), _M_st(_StateT()) {}

  operator streamoff() const { return _M_pos; }

  bool operator==(const fpos& __y) const
  { return _M_pos == __y._M_pos; }
  bool operator!=(const fpos& __y) const
  { return _M_pos != __y._M_pos; }

  fpos& operator+=(streamoff __off) {
    _M_pos += __off;
    return *this;
  }
  fpos& operator-=(streamoff __off) {
    _M_pos -= __off;
    return *this;
  }

  fpos operator+(streamoff __off) {
    fpos __tmp(*this);
    __tmp += __off;
    return __tmp;
  }
  fpos operator-(streamoff __off) {
    fpos __tmp(*this);
    __tmp -= __off;
    return __tmp;
  }

public:
  _StateT state() const { return _M_st; }
  void state(_StateT __st) { _M_st = __st; }
private:
  streamoff _M_pos;
  _StateT _M_st;
};

typedef fpos<mbstate_t> streampos;
typedef fpos<mbstate_t> wstreampos;


template <class _CharT, class _IntT>
class __char_traits_base {
public:
  typedef _CharT char_type;
  typedef _IntT int_type;
  typedef streamoff off_type;
  typedef streampos pos_type;
  typedef mbstate_t state_type;

  static void assign(char_type& __c1, const char_type& __c2) { __c1 = __c2; }
  static bool eq(const char_type& __c1, const char_type& __c2)
  { return __c1 == __c2; }
  static bool lt(const char_type& __c1, const char_type& __c2)
  { return __c1 < __c2; }

  static int compare(const char_type* __s1, const char_type* __s2, size_t __n) {
    for (size_t __i = 0; __i < __n; ++__i)
      if (!eq(__s1[__i], __s2[__i]))
        return __s1[__i] < __s2[__i] ? -1 : 1;
    return 0;
  }

  static size_t length(const char_type* __s) {
    const char_type _NullChar = char_type();
    size_t __i(0);
    for (; !eq(__s[__i], _NullChar); ++__i) {}
    return __i;
  }

  static const char_type* find(const char_type* __s, size_t __n, const char_type& __c) {
    for ( ; __n > 0 ; ++__s, --__n)
      if (eq(*__s, __c))
        return __s;
    return 0;
  }

  static char_type* move(char_type* __s1, const char_type* __s2, size_t _Sz)
  { return (_Sz == 0 ? __s1 : (char_type*)memmove(__s1, __s2, _Sz * sizeof(char_type))); }

  static char_type* copy(char_type* __s1, const char_type* __s2, size_t __n) {
    return (__n == 0 ? __s1 :
      (char_type*)memcpy(__s1, __s2, __n * sizeof(char_type)));
  }

  static char_type* assign(char_type* __s, size_t __n, char_type __c) {
    for (size_t __i = 0; __i < __n; ++__i)
      __s[__i] = __c;
    return __s;
  }

  static int_type not_eof(const int_type& __c)
  { return !eq_int_type(__c, eof()) ? __c : static_cast<int_type>(0); }

  static char_type to_char_type(const int_type& __c)
  { return (char_type)__c; }

  static int_type to_int_type(const char_type& __c)
  { return (int_type)__c; }

  static bool eq_int_type(const int_type& __c1, const int_type& __c2)
  { return __c1 == __c2; }

  static int_type eof()
  { return (int_type)-1; }
};






template <class _CharT>
class char_traits
  : public __char_traits_base<_CharT, _CharT> {};



template<>
class __attribute__((visibility("default"))) char_traits<char>
  : public __char_traits_base<char, int>,
    public __stlport_class<char_traits<char> > {
public:
  typedef char char_type;
  typedef int int_type;
  typedef streamoff off_type;
  typedef streampos pos_type;
  typedef mbstate_t state_type;

  static char to_char_type(const int& __c)
  { return (char)(unsigned char)__c; }

  static int to_int_type(const char& __c)
  { return (unsigned char)__c; }

  static int compare(const char* __s1, const char* __s2, size_t __n)
  { return memcmp(__s1, __s2, __n); }

  static size_t length(const char* __s)
  { return strlen(__s); }

  static void assign(char& __c1, const char& __c2)
  { __c1 = __c2; }

  static char* assign(char* __s, size_t __n, char __c) {
    memset(__s, __c, __n);
    return __s;
  }
};



template<>
class __attribute__((visibility("default"))) char_traits<wchar_t>
  : public __char_traits_base<wchar_t, wint_t> {

public:

  static wchar_t* move(wchar_t* __dest, const wchar_t* __src, size_t __n)
  { return wmemmove(__dest, __src, __n); }


  static wchar_t* copy(wchar_t* __dest, const wchar_t* __src, size_t __n)
  { return wmemcpy(__dest, __src, __n); }


  static int compare(const wchar_t* __s1, const wchar_t* __s2, size_t __n)
  { return wmemcmp(__s1, __s2, __n); }


  static wchar_t* assign(wchar_t* __s, size_t __n, wchar_t __c)
  { return wmemset(__s, __c, __n); }

  static size_t length(const wchar_t* __s)
  { return wcslen(__s); }

  static void assign(wchar_t& __c1, const wchar_t& __c2)
  { __c1 = __c2; }

};


}
# 23 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_iosfwd.h" 2


namespace std {

class ios_base;

template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_ios;

template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_streambuf;

template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_istream;

template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_ostream;

template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_iostream;

template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
class basic_stringbuf;

template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
class basic_istringstream;

template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
class basic_ostringstream;

template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
class basic_stringstream;

template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_filebuf;

template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_ifstream;

template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_ofstream;

template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_fstream;

template <class _CharT, class _Traits = char_traits<_CharT> >
class istreambuf_iterator;

template <class _CharT, class _Traits = char_traits<_CharT> >
class ostreambuf_iterator;

typedef basic_ios<char, char_traits<char> > ios;


typedef basic_ios<wchar_t, char_traits<wchar_t> > wios;



class locale;
template <class _Facet>
# 95 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_iosfwd.h"
inline const _Facet& use_facet(const locale&);


template <class _CharT> class ctype;
template <class _CharT> class ctype_byname;
template <class _CharT> class collate;
template <class _CharT> class collate_byname;

template<> class ctype<char>;
template<> class ctype_byname<char>;
template<> class collate<char>;
template<> class collate_byname<char>;


template<> class ctype<wchar_t>;
template<> class ctype_byname<wchar_t>;
template<> class collate<wchar_t>;
template<> class collate_byname<wchar_t>;







typedef basic_istream<char, char_traits<char> > istream;
typedef basic_ostream<char, char_traits<char> > ostream;
typedef basic_iostream<char, char_traits<char> > iostream;
typedef basic_streambuf<char,char_traits<char> > streambuf;

typedef basic_stringbuf<char, char_traits<char>, allocator<char> > stringbuf;
typedef basic_istringstream<char, char_traits<char>, allocator<char> > istringstream;
typedef basic_ostringstream<char, char_traits<char>, allocator<char> > ostringstream;
typedef basic_stringstream<char, char_traits<char>, allocator<char> > stringstream;

typedef basic_filebuf<char, char_traits<char> > filebuf;
typedef basic_ifstream<char, char_traits<char> > ifstream;
typedef basic_ofstream<char, char_traits<char> > ofstream;
typedef basic_fstream<char, char_traits<char> > fstream;



typedef basic_streambuf<wchar_t, char_traits<wchar_t> > wstreambuf;
typedef basic_istream<wchar_t, char_traits<wchar_t> > wistream;
typedef basic_ostream<wchar_t, char_traits<wchar_t> > wostream;
typedef basic_iostream<wchar_t, char_traits<wchar_t> > wiostream;

typedef basic_stringbuf<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > wstringbuf;
typedef basic_istringstream<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > wistringstream;
typedef basic_ostringstream<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > wostringstream;
typedef basic_stringstream<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > wstringstream;

typedef basic_filebuf<wchar_t, char_traits<wchar_t> > wfilebuf;
typedef basic_ifstream<wchar_t, char_traits<wchar_t> > wifstream;
typedef basic_ofstream<wchar_t, char_traits<wchar_t> > wofstream;
typedef basic_fstream<wchar_t, char_traits<wchar_t> > wfstream;


}
# 24 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_string_fwd.h" 2


namespace std {


template <class _CharT,
          class _Traits = char_traits<_CharT>,
          class _Alloc = allocator<_CharT> >
class basic_string;







typedef basic_string<char, char_traits<char>, allocator<char> > string;


typedef basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > wstring;


namespace priv {



const char* __get_c_string(const string& __str);

}

}
# 28 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_string.h" 2
# 78 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_string.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_string_base.h" 1
# 36 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_string_base.h"
namespace std {

namespace priv {

template <class _Tp, class _Alloc>
class _String_base {
    typedef _String_base<_Tp, _Alloc> _Self;
protected:
 
public:

  enum {_DEFAULT_SIZE = 4 * sizeof( void * )};

  typedef _Alloc allocator_type;
  typedef _STLP_alloc_proxy<_Tp*, _Tp, allocator_type> _AllocProxy;
  typedef size_t size_type;
private:

  union _Buffers {
    _Tp* _M_end_of_storage;
    _Tp _M_static_buf[_DEFAULT_SIZE];
  } _M_buffers;



protected:

  bool _M_using_static_buf() const
  { return (_M_start_of_storage._M_data == _M_buffers._M_static_buf); }
  _Tp const* _M_Start() const { return _M_start_of_storage._M_data; }
  _Tp* _M_Start() { return _M_start_of_storage._M_data; }
  _Tp const* _M_End() const
  { return _M_using_static_buf() ? _M_buffers._M_static_buf + _DEFAULT_SIZE : _M_buffers._M_end_of_storage; }
  _Tp* _M_End()
  { return _M_using_static_buf() ? _M_buffers._M_static_buf + _DEFAULT_SIZE : _M_buffers._M_end_of_storage; }
  size_type _M_capacity() const
  { return _M_using_static_buf() ? _DEFAULT_SIZE : _M_buffers._M_end_of_storage - _M_start_of_storage._M_data; }
  size_type _M_rest() const
  { return _M_using_static_buf() ? _DEFAULT_SIZE - (_M_finish - _M_buffers._M_static_buf) : _M_buffers._M_end_of_storage - _M_finish; }
# 86 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_string_base.h"
  _Tp* _M_finish;
  _AllocProxy _M_start_of_storage;

  _Tp const* _M_Finish() const {return _M_finish;}
  _Tp* _M_Finish() {return _M_finish;}


  void _M_allocate_block(size_t __n = _DEFAULT_SIZE);
  void _M_deallocate_block() {

    if (!_M_using_static_buf() && (_M_start_of_storage._M_data != 0))
      _M_start_of_storage.deallocate(_M_start_of_storage._M_data, _M_buffers._M_end_of_storage - _M_start_of_storage._M_data);




  }

  size_t max_size() const {
    const size_type __string_max_size = size_type(-1) / sizeof(_Tp);
    typename allocator_type::size_type __alloc_max_size = _M_start_of_storage.max_size();
    return (min)(__alloc_max_size, __string_max_size) - 1;
  }

  _String_base(const allocator_type& __a)

    : _M_finish(_M_buffers._M_static_buf), _M_start_of_storage(__a, _M_buffers._M_static_buf)



    {}

  _String_base(const allocator_type& __a, size_t __n)

    : _M_finish(_M_buffers._M_static_buf), _M_start_of_storage(__a, _M_buffers._M_static_buf) {



      _M_allocate_block(__n);
    }


  void _M_move_src (_Self &src) {
    if (src._M_using_static_buf()) {
      _M_buffers = src._M_buffers;
      _M_finish = _M_buffers._M_static_buf + (src._M_finish - src._M_start_of_storage._M_data);
      _M_start_of_storage._M_data = _M_buffers._M_static_buf;
    }
    else {
      _M_start_of_storage._M_data = src._M_start_of_storage._M_data;
      _M_finish = src._M_finish;
      _M_buffers._M_end_of_storage = src._M_buffers._M_end_of_storage;
      src._M_start_of_storage._M_data = 0;
    }
  }



  _String_base(__move_source<_Self> src)

    : _M_start_of_storage(__move_source<_AllocProxy>(src.get()._M_start_of_storage)) {
      _M_move_src(src.get());





    }


  ~_String_base() { _M_deallocate_block(); }

  void _M_reset(_Tp *__start, _Tp *__finish, _Tp *__end_of_storage) {

    _M_buffers._M_end_of_storage = __end_of_storage;



    _M_finish = __finish;
    _M_start_of_storage._M_data = __start;
  }

  void _M_swap(_Self &__s) {

    if (_M_using_static_buf()) {
      if (__s._M_using_static_buf()) {
        ::std::swap(_M_buffers, __s._M_buffers);
        _Tp *__tmp = _M_finish;
        _M_finish = _M_start_of_storage._M_data + (__s._M_finish - __s._M_start_of_storage._M_data);
        __s._M_finish = __s._M_buffers._M_static_buf + (__tmp - _M_start_of_storage._M_data);

        _M_start_of_storage.swap(__s._M_start_of_storage);
        _M_start_of_storage._M_data = _M_buffers._M_static_buf;
        __s._M_start_of_storage._M_data = __s._M_buffers._M_static_buf;
      } else {
        __s._M_swap(*this);
        return;
      }
    }
    else if (__s._M_using_static_buf()) {
      _Tp *__tmp = _M_start_of_storage._M_data;
      _Tp *__tmp_finish = _M_finish;
      _Tp *__tmp_end_data = _M_buffers._M_end_of_storage;
      _M_buffers = __s._M_buffers;

      _M_start_of_storage.swap(__s._M_start_of_storage);
      _M_start_of_storage._M_data = _M_buffers._M_static_buf;
      _M_finish = _M_buffers._M_static_buf + (__s._M_finish - __s._M_buffers._M_static_buf);
      __s._M_buffers._M_end_of_storage = __tmp_end_data;
      __s._M_start_of_storage._M_data = __tmp;
      __s._M_finish = __tmp_finish;
    }
    else {
      ::std::swap(_M_buffers._M_end_of_storage, __s._M_buffers._M_end_of_storage);
      _M_start_of_storage.swap(__s._M_start_of_storage);
      ::std::swap(_M_finish, __s._M_finish);
    }





  }

  void _M_throw_length_error() const;
  void _M_throw_out_of_range() const;
};
# 221 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_string_base.h"
}

}
# 79 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_string.h" 2

namespace std {
# 98 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_string.h"
namespace priv {
struct _String_reserve_t {};
}
# 120 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_string.h"
template <class _CharT, class _Traits, class _Alloc>
class basic_string : private ::std::priv:: _String_base<_CharT,_Alloc>



{
private:
  typedef ::std::priv:: _String_base<_CharT,_Alloc> _Base;
  typedef basic_string<_CharT, _Traits, _Alloc> _Self;

public:
  typedef _CharT value_type;
  typedef _Traits traits_type;

  typedef value_type* pointer;
  typedef const value_type* const_pointer;
  typedef value_type& reference;
  typedef const value_type& const_reference;
  typedef typename _Base::size_type size_type;
  typedef ptrdiff_t difference_type;
  typedef random_access_iterator_tag _Iterator_category;

  typedef const value_type* const_iterator;
  typedef value_type* iterator;

  typedef ::std::reverse_iterator<const_iterator> const_reverse_iterator; typedef ::std::reverse_iterator<iterator> reverse_iterator;

# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_string_npos.h" 1
# 26 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_string_npos.h"
  static const size_t npos = ~(size_t)0;
# 148 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_string.h" 2

  typedef ::std::priv:: _String_reserve_t _Reserve_t;

public:
  typedef typename _Base::allocator_type allocator_type;

  allocator_type get_allocator() const
  { return (const allocator_type&)this->_M_start_of_storage; }


  explicit basic_string(const allocator_type& __a = allocator_type())






      : ::std::priv:: _String_base<_CharT,_Alloc>(__a, _Base::_DEFAULT_SIZE)
  { _M_terminate_string(); }


  basic_string(_Reserve_t, size_t __n,
               const allocator_type& __a = allocator_type())






    : ::std::priv:: _String_base<_CharT,_Alloc>(__a, __n + 1)
  { _M_terminate_string(); }

  basic_string(const _Self&);


  basic_string(const _Self& __s, size_type __pos, size_type __n = npos,
               const allocator_type& __a = allocator_type())
# 204 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_string.h"
    : ::std::priv:: _String_base<_CharT,_Alloc>(__a) {
    if (__pos > __s.size())
      this->_M_throw_out_of_range();
    else
      _M_range_initialize(__s._M_Start() + __pos,
                          __s._M_Start() + __pos + (min) (__n, __s.size() - __pos));
  }


  basic_string(const _CharT* __s, size_type __n,
               const allocator_type& __a = allocator_type())
# 223 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_string.h"
    : ::std::priv:: _String_base<_CharT,_Alloc>(__a) {
     
      _M_range_initialize(__s, __s + __n);
    }


  basic_string(const _CharT* __s,
               const allocator_type& __a = allocator_type());






  basic_string(size_type __n, _CharT __c,
               const allocator_type& __a = allocator_type())
# 247 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_string.h"
    : ::std::priv:: _String_base<_CharT,_Alloc>(__a, __n + 1) {
    this->_M_finish = ::std::priv:: __uninitialized_fill_n(this->_M_Start(), __n, __c);
    _M_terminate_string();
  }


  basic_string(__move_source<_Self> src)
    : ::std::priv:: _String_base<_CharT,_Alloc>(__move_source<_Base>(src.get())) {}





  template <class _InputIterator>
  basic_string(_InputIterator __f, _InputIterator __l,
               const allocator_type & __a = allocator_type())
    : ::std::priv:: _String_base<_CharT,_Alloc>(__a) {
    typedef typename _IsIntegral<_InputIterator>::_Ret _Integral;
    _M_initialize_dispatch(__f, __l, _Integral());
  }
# 301 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_string.h"
private:
  size_type _M_compute_next_size(size_type __n) {
    const size_type __size = size();
    if (__n > max_size() - __size)
      this->_M_throw_length_error();
    size_type __len = __size + (max)(__n, __size) + 1;
    if (__len > max_size() || __len < __size)
      __len = max_size();
    return __len;
  }

  template <class _InputIter>
  void _M_range_initialize(_InputIter __f, _InputIter __l,
                           const input_iterator_tag &__tag) {
    this->_M_allocate_block();
    _M_construct_null(this->_M_Finish());
    _M_appendT(__f, __l, __tag);
  }

  template <class _ForwardIter>
  void _M_range_initialize(_ForwardIter __f, _ForwardIter __l,
                           const forward_iterator_tag &) {
    difference_type __n = ::std::distance(__f, __l);
    this->_M_allocate_block(__n + 1);
    this->_M_finish = uninitialized_copy(__f, __l, this->_M_Start());
    this->_M_terminate_string();
  }

  template <class _InputIter>
  void _M_range_initializeT(_InputIter __f, _InputIter __l) {
    _M_range_initialize(__f, __l, typename ::std::iterator_traits< _InputIter >::iterator_category());
  }

  template <class _Integer>
  void _M_initialize_dispatch(_Integer __n, _Integer __x, const __true_type& ) {
    this->_M_allocate_block(__n + 1);
    this->_M_finish = ::std::priv:: __uninitialized_fill_n(this->_M_Start(), __n, __x);
    this->_M_terminate_string();
  }

  template <class _InputIter>
  void _M_initialize_dispatch(_InputIter __f, _InputIter __l, const __false_type& ) {
    _M_range_initializeT(__f, __l);
  }

public:
  _Self& operator=(const _Self& __s) {
    if (&__s != this)
      _M_assign(__s._M_Start(), __s._M_Finish());
    return *this;
  }

  _Self& operator=(const _CharT* __s) {
   
    return _M_assign(__s, __s + traits_type::length(__s));
  }

  _Self& operator=(_CharT __c)
  { return assign(static_cast<size_type>(1), __c); }

private:
  static _CharT _M_null()
  { return _CharT(); }

private:

  void _M_construct_null(_CharT* __p) const
  { ::std::_Construct(__p); }
  void _M_terminate_string()
  { _M_construct_null(this->_M_Finish()); }
  bool _M_inside(const _CharT* __s) const {
   
    return (__s >= this->_M_Start()) && (__s < this->_M_Finish());
  }

  void _M_range_initialize(const _CharT* __f, const _CharT* __l) {
   
    ptrdiff_t __n = __l - __f;
    this->_M_allocate_block(__n + 1);
    this->_M_finish = uninitialized_copy(__f, __l, this->_M_Start());
    _M_terminate_string();
  }

public:
  iterator begin() { return this->_M_Start(); }
  iterator end() { return this->_M_Finish(); }
  const_iterator begin() const { return this->_M_Start(); }
  const_iterator end() const { return this->_M_Finish(); }

  reverse_iterator rbegin()
  { return reverse_iterator(this->_M_Finish()); }
  reverse_iterator rend()
  { return reverse_iterator(this->_M_Start()); }
  const_reverse_iterator rbegin() const
  { return const_reverse_iterator(this->_M_Finish()); }
  const_reverse_iterator rend() const
  { return const_reverse_iterator(this->_M_Start()); }

public:
  size_type size() const { return this->_M_Finish() - this->_M_Start(); }
  size_type length() const { return size(); }
  size_type max_size() const { return _Base::max_size(); }

  void resize(size_type __n, _CharT __c) {
    if (__n <= size())
      erase(begin() + __n, end());
    else
      append(__n - size(), __c);
  }

  void resize(size_type __n) { resize(__n, _M_null()); }

private:
  void _M_reserve(size_type);
public:
  void reserve(size_type = 0);

  size_type capacity() const
  { return this->_M_capacity() - 1; }

  void clear() {
    if (!empty()) {
      _Traits::assign(*(this->_M_Start()), _M_null());
      this->_M_finish = this->_M_Start();
    }
  }

  bool empty() const { return this->_M_Start() == this->_M_Finish(); }

public:

  const_reference operator[](size_type __n) const
  { return *(this->_M_Start() + __n); }
  reference operator[](size_type __n)
  { return *(this->_M_Start() + __n); }

  const_reference at(size_type __n) const {
    if (__n >= size())
      this->_M_throw_out_of_range();
    return *(this->_M_Start() + __n);
  }

  reference at(size_type __n) {
    if (__n >= size())
      this->_M_throw_out_of_range();
    return *(this->_M_Start() + __n);
  }

public:

  _Self& operator+=(const _Self& __s) { return append(__s); }
  _Self& operator+=(const _CharT* __s) { return append(__s); }
  _Self& operator+=(_CharT __c) { push_back(__c); return *this; }

private:
  _Self& _M_append(const _CharT* __first, const _CharT* __last);


  template <class _InputIter>
  _Self& _M_appendT(_InputIter __first, _InputIter __last,
                    const input_iterator_tag &) {
    for ( ; __first != __last ; ++__first)
      push_back(*__first);
    return *this;
  }

  template <class _ForwardIter>
  _Self& _M_appendT(_ForwardIter __first, _ForwardIter __last,
                    const forward_iterator_tag &) {
    if (__first != __last) {
      size_type __n = static_cast<size_type>(::std::distance(__first, __last));
      if (__n >= this->_M_rest()) {
        size_type __len = _M_compute_next_size(__n);
        pointer __new_start = this->_M_start_of_storage.allocate(__len, __len);
        pointer __new_finish = uninitialized_copy(this->_M_Start(), this->_M_Finish(), __new_start);
        __new_finish = uninitialized_copy(__first, __last, __new_finish);
        _M_construct_null(__new_finish);
        this->_M_deallocate_block();
        this->_M_reset(__new_start, __new_finish, __new_start + __len);
      }
      else {
        _Traits::assign(*this->_M_finish, *__first++);
        uninitialized_copy(__first, __last, this->_M_Finish() + 1);
        _M_construct_null(this->_M_Finish() + __n);
        this->_M_finish += __n;
      }
    }
    return *this;
  }

  template <class _Integer>
  _Self& _M_append_dispatch(_Integer __n, _Integer __x, const __true_type& )
  { return append((size_type) __n, (_CharT) __x); }

  template <class _InputIter>
  _Self& _M_append_dispatch(_InputIter __f, _InputIter __l, const __false_type& )
  { return _M_appendT(__f, __l, typename ::std::iterator_traits< _InputIter >::iterator_category()); }

public:


  template <class _InputIter>
  _Self& append(_InputIter __first, _InputIter __last) {
    typedef typename _IsIntegral<_InputIter>::_Ret _Integral;
    return _M_append_dispatch(__first, __last, _Integral());
  }
# 515 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_string.h"
public:
  _Self& append(const _Self& __s)
  { return _M_append(__s._M_Start(), __s._M_Finish()); }

  _Self& append(const _Self& __s,
                size_type __pos, size_type __n) {
    if (__pos > __s.size())
      this->_M_throw_out_of_range();
    return _M_append(__s._M_Start() + __pos,
                     __s._M_Start() + __pos + (min) (__n, __s.size() - __pos));
  }

  _Self& append(const _CharT* __s, size_type __n)
  { return _M_append(__s, __s+__n); }
  _Self& append(const _CharT* __s)
  { return _M_append(__s, __s + traits_type::length(__s)); }
  _Self& append(size_type __n, _CharT __c);

public:
  void push_back(_CharT __c) {
    if (this->_M_rest() == 1 )
      _M_reserve(_M_compute_next_size(1));
    _M_construct_null(this->_M_Finish() + 1);
    _Traits::assign(*(this->_M_Finish()), __c);
    ++this->_M_finish;
  }

  void pop_back() {
    _Traits::assign(*(this->_M_Finish() - 1), _M_null());
    --this->_M_finish;
  }

public:
  _Self& assign(const _Self& __s)
  { return _M_assign(__s._M_Start(), __s._M_Finish()); }

  _Self& assign(const _Self& __s,
                size_type __pos, size_type __n) {
    if (__pos > __s.size())
      this->_M_throw_out_of_range();
    return _M_assign(__s._M_Start() + __pos,
                     __s._M_Start() + __pos + (min) (__n, __s.size() - __pos));
  }

  _Self& assign(const _CharT* __s, size_type __n)
  { return _M_assign(__s, __s + __n); }

  _Self& assign(const _CharT* __s)
  { return _M_assign(__s, __s + _Traits::length(__s)); }

  _Self& assign(size_type __n, _CharT __c);

private:
  _Self& _M_assign(const _CharT* __f, const _CharT* __l);



  template <class _Integer>
  _Self& _M_assign_dispatch(_Integer __n, _Integer __x, const __true_type& )
  { return assign((size_type) __n, (_CharT) __x); }

  template <class _InputIter>
  _Self& _M_assign_dispatch(_InputIter __f, _InputIter __l, const __false_type& ) {
    pointer __cur = this->_M_Start();
    while (__f != __l && __cur != this->_M_Finish()) {
      _Traits::assign(*__cur, *__f);
      ++__f;
      ++__cur;
    }
    if (__f == __l)
      erase(__cur, this->end());
    else
      _M_appendT(__f, __l, typename ::std::iterator_traits< _InputIter >::iterator_category());
    return *this;
  }

public:


  template <class _InputIter>
  _Self& assign(_InputIter __first, _InputIter __last) {
    typedef typename _IsIntegral<_InputIter>::_Ret _Integral;
    return _M_assign_dispatch(__first, __last, _Integral());
  }
# 607 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_string.h"
public:
  _Self& insert(size_type __pos, const _Self& __s) {
    if (__pos > size())
      this->_M_throw_out_of_range();
    if (__s.size() > max_size() - size())
      this->_M_throw_length_error();
    _M_insert(begin() + __pos, __s._M_Start(), __s._M_Finish(), &__s == this);
    return *this;
  }

  _Self& insert(size_type __pos, const _Self& __s,
                size_type __beg, size_type __n) {
    if (__pos > size() || __beg > __s.size())
      this->_M_throw_out_of_range();
    size_type __len = (min) (__n, __s.size() - __beg);
    if (__len > max_size() - size())
      this->_M_throw_length_error();
    _M_insert(begin() + __pos,
              __s._M_Start() + __beg, __s._M_Start() + __beg + __len, &__s == this);
    return *this;
  }
  _Self& insert(size_type __pos, const _CharT* __s, size_type __n) {
   
    if (__pos > size())
      this->_M_throw_out_of_range();
    if (__n > max_size() - size())
      this->_M_throw_length_error();
    _M_insert(begin() + __pos, __s, __s + __n, _M_inside(__s));
    return *this;
  }

  _Self& insert(size_type __pos, const _CharT* __s) {
   
    if (__pos > size())
      this->_M_throw_out_of_range();
    size_type __len = _Traits::length(__s);
    if (__len > max_size() - size())
      this->_M_throw_length_error();
    _M_insert(this->_M_Start() + __pos, __s, __s + __len, _M_inside(__s));
    return *this;
  }

  _Self& insert(size_type __pos, size_type __n, _CharT __c) {
    if (__pos > size())
      this->_M_throw_out_of_range();
    if (__n > max_size() - size())
      this->_M_throw_length_error();
    insert(begin() + __pos, __n, __c);
    return *this;
  }

  iterator insert(iterator __p, _CharT __c) {
   
    if (__p == end()) {
      push_back(__c);
      return this->_M_Finish() - 1;
    }
    else
      return _M_insert_aux(__p, __c);
  }

  void insert(iterator __p, size_t __n, _CharT __c);

private:
  void _M_insert(iterator __p, const _CharT* __first, const _CharT* __last, bool __self_ref);

  pointer _M_insert_aux(pointer, _CharT);

  void _M_copy(const _CharT* __f, const _CharT* __l, _CharT* __res) {
   
   
    _Traits::copy(__res, __f, __l - __f);
  }

  void _M_move(const _CharT* __f, const _CharT* __l, _CharT* __res) {
   
    _Traits::move(__res, __f, __l - __f);
  }



  template <class _ForwardIter>
  void _M_insert_overflow(iterator __pos, _ForwardIter __first, _ForwardIter __last,
                          size_type __n) {
    size_type __len = _M_compute_next_size(__n);
    pointer __new_start = this->_M_start_of_storage.allocate(__len, __len);
    pointer __new_finish = uninitialized_copy(this->_M_Start(), __pos, __new_start);
    __new_finish = uninitialized_copy(__first, __last, __new_finish);
    __new_finish = uninitialized_copy(__pos, this->_M_Finish(), __new_finish);
    _M_construct_null(__new_finish);
    this->_M_deallocate_block();
    this->_M_reset(__new_start, __new_finish, __new_start + __len);
  }

  template <class _InputIter>
  void _M_insertT(iterator __p, _InputIter __first, _InputIter __last,
                  const input_iterator_tag &) {
    for ( ; __first != __last; ++__first) {
      __p = insert(__p, *__first);
      ++__p;
    }
  }

  template <class _ForwardIter>
  void _M_insertT(iterator __pos, _ForwardIter __first, _ForwardIter __last,
                  const forward_iterator_tag &) {
    if (__first != __last) {
      size_type __n = ::std::distance(__first, __last);
      if (__n < this->_M_rest()) {
        const size_type __elems_after = this->_M_finish - __pos;
        if (__elems_after >= __n) {
          uninitialized_copy((this->_M_Finish() - __n) + 1, this->_M_Finish() + 1, this->_M_Finish() + 1);
          this->_M_finish += __n;
          _Traits::move(__pos + __n, __pos, (__elems_after - __n) + 1);
          _M_copyT(__first, __last, __pos);
        }
        else {
          pointer __old_finish = this->_M_Finish();
          _ForwardIter __mid = __first;
          ::std::advance(__mid, __elems_after + 1);
          ::std::uninitialized_copy(__mid, __last, this->_M_Finish() + 1);
          this->_M_finish += __n - __elems_after;
          uninitialized_copy(__pos, __old_finish + 1, this->_M_Finish());
          this->_M_finish += __elems_after;
          _M_copyT(__first, __mid, __pos);
        }
      }
      else {
        _M_insert_overflow(__pos, __first, __last, __n);
      }
    }
  }

  template <class _Integer>
  void _M_insert_dispatch(iterator __p, _Integer __n, _Integer __x,
                          const __true_type& )
  { insert(__p, (size_type) __n, (_CharT) __x); }

  template <class _InputIter>
  void _M_insert_dispatch(iterator __p, _InputIter __first, _InputIter __last,
                          const __false_type& ) {
   

    const _Self __self(__first, __last, get_allocator());
    _M_insertT(__p, __self.begin(), __self.end(), forward_iterator_tag());
  }

  template <class _InputIterator>
  void _M_copyT(_InputIterator __first, _InputIterator __last, pointer __result) {
   
    for ( ; __first != __last; ++__first, ++__result)
      _Traits::assign(*__result, *__first);
  }


  void _M_copyT(const _CharT* __f, const _CharT* __l, _CharT* __res) {
   
   
    _Traits::copy(__res, __f, __l - __f);
  }

public:


  template <class _InputIter>
  void insert(iterator __p, _InputIter __first, _InputIter __last) {
    typedef typename _IsIntegral<_InputIter>::_Ret _Integral;
    _M_insert_dispatch(__p, __first, __last, _Integral());
  }




public:
  void insert(iterator __p, const _CharT* __f, const _CharT* __l) {
   
    _M_insert(__p, __f, __l, _M_inside(__f));
  }


public:
  _Self& erase(size_type __pos = 0, size_type __n = npos) {
    if (__pos > size())
      this->_M_throw_out_of_range();
    erase(begin() + __pos, begin() + __pos + (min) (__n, size() - __pos));
    return *this;
  }

  iterator erase(iterator __pos) {

    _Traits::move(__pos, __pos + 1, this->_M_Finish() - __pos);
    --this->_M_finish;
    return __pos;
  }

  iterator erase(iterator __first, iterator __last) {
    if (__first != __last) {

      traits_type::move(__first, __last, (this->_M_Finish() - __last) + 1);
      this->_M_finish = this->_M_Finish() - (__last - __first);
    }
    return __first;
  }

public:

  _Self& replace(size_type __pos, size_type __n, const _Self& __s) {
    const size_type __size = size();
    if (__pos > __size)
      this->_M_throw_out_of_range();
    const size_type __len = (min) (__n, __size - __pos);
    if (__s.size() > max_size() - (__size - __len))
      this->_M_throw_length_error();
    return _M_replace(begin() + __pos, begin() + __pos + __len,
                      __s._M_Start(), __s._M_Finish(), &__s == this);
  }

  _Self& replace(size_type __pos1, size_type __n1, const _Self& __s,
                 size_type __pos2, size_type __n2) {
    const size_type __size1 = size();
    const size_type __size2 = __s.size();
    if (__pos1 > __size1 || __pos2 > __size2)
      this->_M_throw_out_of_range();
    const size_type __len1 = (min) (__n1, __size1 - __pos1);
    const size_type __len2 = (min) (__n2, __size2 - __pos2);
    if (__len2 > max_size() - (__size1 - __len1))
      this->_M_throw_length_error();
    return _M_replace(begin() + __pos1, begin() + __pos1 + __len1,
                      __s._M_Start() + __pos2, __s._M_Start() + __pos2 + __len2, &__s == this);
  }

  _Self& replace(size_type __pos, size_type __n1,
                 const _CharT* __s, size_type __n2) {
   
    const size_type __size = size();
    if (__pos > __size)
      this->_M_throw_out_of_range();
    const size_type __len = (min) (__n1, __size - __pos);
    if (__n2 > max_size() - (__size - __len))
      this->_M_throw_length_error();
    return _M_replace(begin() + __pos, begin() + __pos + __len,
                      __s, __s + __n2, _M_inside(__s));
  }

  _Self& replace(size_type __pos, size_type __n1, const _CharT* __s) {
   
    return replace(__pos, __n1, __s, _Traits::length(__s));
  }

  _Self& replace(size_type __pos, size_type __n1,
                 size_type __n2, _CharT __c) {
    const size_type __size = size();
    if (__pos > __size)
      this->_M_throw_out_of_range();
    const size_type __len = (min) (__n1, __size - __pos);
    if (__n2 > max_size() - (__size - __len))
      this->_M_throw_length_error();
    return replace(begin() + __pos, begin() + __pos + __len, __n2, __c);
  }

  _Self& replace(iterator __first, iterator __last, const _Self& __s) {
   
    return _M_replace(__first, __last, __s._M_Start(), __s._M_Finish(), &__s == this);
  }

  _Self& replace(iterator __first, iterator __last,
                 const _CharT* __s, size_type __n) {
   
   
    return _M_replace(__first, __last, __s, __s + __n, _M_inside(__s));
  }

  _Self& replace(iterator __first, iterator __last,
                 const _CharT* __s) {
   
   
    return _M_replace(__first, __last, __s, __s + _Traits::length(__s), _M_inside(__s));
  }

  _Self& replace(iterator __first, iterator __last, size_type __n, _CharT __c);

private:
  _Self& _M_replace(iterator __first, iterator __last,
                    const _CharT* __f, const _CharT* __l, bool __self_ref);


  template <class _Integer>
  _Self& _M_replace_dispatch(iterator __first, iterator __last,
                             _Integer __n, _Integer __x, const __true_type& ) {
   
    return replace(__first, __last, (size_type) __n, (_CharT) __x);
  }

  template <class _InputIter>
  _Self& _M_replace_dispatch(iterator __first, iterator __last,
                             _InputIter __f, _InputIter __l, const __false_type& ) {
   

    const _Self __self(__f, __l, get_allocator());
    return _M_replace(__first, __last, __self._M_Start(), __self._M_Finish(), false);
  }

public:


  template <class _InputIter>
  _Self& replace(iterator __first, iterator __last,
                 _InputIter __f, _InputIter __l) {
   
    typedef typename _IsIntegral<_InputIter>::_Ret _Integral;
    return _M_replace_dispatch(__first, __last, __f, __l, _Integral());
  }



public:
  _Self& replace(iterator __first, iterator __last,
                 const _CharT* __f, const _CharT* __l) {
   
   
    return _M_replace(__first, __last, __f, __l, _M_inside(__f));
  }


public:

  size_type copy(_CharT* __s, size_type __n, size_type __pos = 0) const {
   
    if (__pos > size())
      this->_M_throw_out_of_range();
    const size_type __len = (min) (__n, size() - __pos);
    _Traits::copy(__s, this->_M_Start() + __pos, __len);
    return __len;
  }

  void swap(_Self& __s) { this->_M_swap(__s); }




public:

  const _CharT* c_str() const { return this->_M_Start(); }
  const _CharT* data() const { return this->_M_Start(); }

public:
  size_type find(const _Self& __s, size_type __pos = 0) const
  { return find(__s._M_Start(), __pos, __s.size()); }

  size_type find(const _CharT* __s, size_type __pos = 0) const
  { return find(__s, __pos, _Traits::length(__s)); }

  size_type find(const _CharT* __s, size_type __pos, size_type __n) const;


  size_type find(_CharT __c) const { return find(__c, 0); }
  size_type find(_CharT __c, size_type __pos ) const;

public:
  size_type rfind(const _Self& __s, size_type __pos = npos) const
  { return rfind(__s._M_Start(), __pos, __s.size()); }

  size_type rfind(const _CharT* __s, size_type __pos = npos) const
  { return rfind(__s, __pos, _Traits::length(__s)); }

  size_type rfind(const _CharT* __s, size_type __pos, size_type __n) const;
  size_type rfind(_CharT __c, size_type __pos = npos) const;

public:
  size_type find_first_of(const _Self& __s, size_type __pos = 0) const
  { return find_first_of(__s._M_Start(), __pos, __s.size()); }

  size_type find_first_of(const _CharT* __s, size_type __pos = 0) const
  { return find_first_of(__s, __pos, _Traits::length(__s)); }

  size_type find_first_of(const _CharT* __s, size_type __pos, size_type __n) const;

  size_type find_first_of(_CharT __c, size_type __pos = 0) const
  { return find(__c, __pos); }

public:
  size_type find_last_of(const _Self& __s, size_type __pos = npos) const
  { return find_last_of(__s._M_Start(), __pos, __s.size()); }

  size_type find_last_of(const _CharT* __s, size_type __pos = npos) const
  { return find_last_of(__s, __pos, _Traits::length(__s)); }

  size_type find_last_of(const _CharT* __s, size_type __pos, size_type __n) const;

  size_type find_last_of(_CharT __c, size_type __pos = npos) const
  { return rfind(__c, __pos); }

public:
  size_type find_first_not_of(const _Self& __s, size_type __pos = 0) const
  { return find_first_not_of(__s._M_Start(), __pos, __s.size()); }

  size_type find_first_not_of(const _CharT* __s, size_type __pos = 0) const
  { return find_first_not_of(__s, __pos, _Traits::length(__s)); }

  size_type find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const;

  size_type find_first_not_of(_CharT __c, size_type __pos = 0) const;

public:
  size_type find_last_not_of(const _Self& __s, size_type __pos = npos) const
  { return find_last_not_of(__s._M_Start(), __pos, __s.size()); }

  size_type find_last_not_of(const _CharT* __s, size_type __pos = npos) const
  { return find_last_not_of(__s, __pos, _Traits::length(__s)); }

  size_type find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const;

  size_type find_last_not_of(_CharT __c, size_type __pos = npos) const;

public:
  _Self substr(size_type __pos = 0, size_type __n = npos) const
  { return _Self(*this, __pos, __n, get_allocator()); }

public:
  int compare(const _Self& __s) const
  { return _M_compare(this->_M_Start(), this->_M_Finish(), __s._M_Start(), __s._M_Finish()); }

  int compare(size_type __pos1, size_type __n1, const _Self& __s) const {
    if (__pos1 > size())
      this->_M_throw_out_of_range();
    return _M_compare(this->_M_Start() + __pos1,
                      this->_M_Start() + __pos1 + (min) (__n1, size() - __pos1),
                      __s._M_Start(), __s._M_Finish());
  }

  int compare(size_type __pos1, size_type __n1, const _Self& __s,
              size_type __pos2, size_type __n2) const {
    if (__pos1 > size() || __pos2 > __s.size())
      this->_M_throw_out_of_range();
    return _M_compare(this->_M_Start() + __pos1,
                      this->_M_Start() + __pos1 + (min) (__n1, size() - __pos1),
                      __s._M_Start() + __pos2,
                      __s._M_Start() + __pos2 + (min) (__n2, __s.size() - __pos2));
  }

  int compare(const _CharT* __s) const {
   
    return _M_compare(this->_M_Start(), this->_M_Finish(), __s, __s + _Traits::length(__s));
  }

  int compare(size_type __pos1, size_type __n1, const _CharT* __s) const {
   
    if (__pos1 > size())
      this->_M_throw_out_of_range();
    return _M_compare(this->_M_Start() + __pos1,
                      this->_M_Start() + __pos1 + (min) (__n1, size() - __pos1),
                      __s, __s + _Traits::length(__s));
  }

  int compare(size_type __pos1, size_type __n1, const _CharT* __s, size_type __n2) const {
   
    if (__pos1 > size())
      this->_M_throw_out_of_range();
    return _M_compare(this->_M_Start() + __pos1,
                      this->_M_Start() + __pos1 + (min) (__n1, size() - __pos1),
                      __s, __s + __n2);
  }

public:
  static int _M_compare(const _CharT* __f1, const _CharT* __l1,
                                   const _CharT* __f2, const _CharT* __l2) {
    const ptrdiff_t __n1 = __l1 - __f1;
    const ptrdiff_t __n2 = __l2 - __f2;
    const int cmp = _Traits::compare(__f1, __f2, (min) (__n1, __n2));
    return cmp != 0 ? cmp : (__n1 < __n2 ? -1 : (__n1 > __n2 ? 1 : 0));
  }





};
# 1104 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_string.h"
}
# 1114 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_string.h"
namespace std {





template <class _CharT, class _Traits, class _Alloc>
inline void
swap(basic_string<_CharT,_Traits,_Alloc>& __x,
     basic_string<_CharT,_Traits,_Alloc>& __y)
{ __x.swap(__y); }
# 1135 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_string.h"
template <class _CharT, class _Traits, class _Alloc>
struct __move_traits<basic_string<_CharT, _Traits, _Alloc> > {
  typedef __true_type implemented;

  typedef typename __move_traits<_Alloc>::complete complete;
};
# 1150 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_string.h"
namespace priv {

template <class _CharT, class _Traits, class _Alloc>
void _S_string_copy(const basic_string<_CharT,_Traits,_Alloc>& __s,
                               _CharT* __buf, size_t __n);







inline const char*
__get_c_string(const string& __str) { return __str.c_str(); }

}

}

# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_string_operators.h" 1
# 19 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_string_operators.h"
namespace std {







template <class _CharT, class _Traits, class _Alloc>
inline basic_string<_CharT,_Traits,_Alloc>
operator+(const basic_string<_CharT,_Traits,_Alloc>& __s,
          const basic_string<_CharT,_Traits,_Alloc>& __y) {
  typedef basic_string<_CharT,_Traits,_Alloc> _Str;
  typedef typename _Str::_Reserve_t _Reserve_t;


  _Str __result = _Str(_Reserve_t(), __s.size() + __y.size(), __s.get_allocator());



  __result.append(__s);
  __result.append(__y);
  return __result;
}

template <class _CharT, class _Traits, class _Alloc>
inline basic_string<_CharT,_Traits,_Alloc>
operator+(const _CharT* __s,
          const basic_string<_CharT,_Traits,_Alloc>& __y) {
 
  typedef basic_string<_CharT,_Traits,_Alloc> _Str;
  typedef typename _Str::_Reserve_t _Reserve_t;
  const size_t __n = _Traits::length(__s);

  _Str __result = _Str(_Reserve_t(), __n + __y.size(), __y.get_allocator());



  __result.append(__s, __s + __n);
  __result.append(__y);
  return __result;
}

template <class _CharT, class _Traits, class _Alloc>
inline basic_string<_CharT,_Traits,_Alloc>
operator+(_CharT __c,
          const basic_string<_CharT,_Traits,_Alloc>& __y) {
  typedef basic_string<_CharT,_Traits,_Alloc> _Str;
  typedef typename _Str::_Reserve_t _Reserve_t;

  _Str __result = _Str(_Reserve_t(), 1 + __y.size(), __y.get_allocator());



  __result.push_back(__c);
  __result.append(__y);
  return __result;
}

template <class _CharT, class _Traits, class _Alloc>
inline basic_string<_CharT,_Traits,_Alloc>
operator+(const basic_string<_CharT,_Traits,_Alloc>& __x,
          const _CharT* __s) {
 
  typedef basic_string<_CharT,_Traits,_Alloc> _Str;
  typedef typename _Str::_Reserve_t _Reserve_t;
  const size_t __n = _Traits::length(__s);

  _Str __result = _Str(_Reserve_t(), __x.size() + __n, __x.get_allocator());



  __result.append(__x);
  __result.append(__s, __s + __n);
  return __result;
}

template <class _CharT, class _Traits, class _Alloc>
inline basic_string<_CharT,_Traits,_Alloc>
operator+(const basic_string<_CharT,_Traits,_Alloc>& __x,
          const _CharT __c) {
  typedef basic_string<_CharT,_Traits,_Alloc> _Str;
  typedef typename _Str::_Reserve_t _Reserve_t;

  _Str __result = _Str(_Reserve_t(), __x.size() + 1, __x.get_allocator());



  __result.append(__x);
  __result.push_back(__c);
  return __result;
}
# 285 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_string_operators.h"
template <class _CharT, class _Traits, class _Alloc>
inline bool
operator==(const basic_string<_CharT,_Traits,_Alloc>& __x,
           const basic_string<_CharT,_Traits,_Alloc>& __y) {
  return __x.size() == __y.size() && _Traits::compare(__x.data(), __y.data(), __x.size()) == 0;
}
# 309 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_string_operators.h"
template <class _CharT, class _Traits, class _Alloc>
inline bool
operator==(const _CharT* __s,
           const basic_string<_CharT,_Traits,_Alloc>& __y) {
 
  size_t __n = _Traits::length(__s);
  return __n == __y.size() && _Traits::compare(__s, __y.data(), __n) == 0;
}

template <class _CharT, class _Traits, class _Alloc>
inline bool
operator==(const basic_string<_CharT,_Traits,_Alloc>& __x,
           const _CharT* __s) {
 
  size_t __n = _Traits::length(__s);
  return __x.size() == __n && _Traits::compare(__x.data(), __s, __n) == 0;
}
# 349 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_string_operators.h"
template <class _CharT, class _Traits, class _Alloc>
inline bool
operator<(const basic_string<_CharT,_Traits,_Alloc>& __x,
          const basic_string<_CharT,_Traits,_Alloc>& __y) {
  return basic_string<_CharT,_Traits,_Alloc> ::_M_compare(__x.begin(), __x.end(),
                                                          __y.begin(), __y.end()) < 0;
}
# 375 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_string_operators.h"
template <class _CharT, class _Traits, class _Alloc>
inline bool
operator<(const _CharT* __s,
          const basic_string<_CharT,_Traits,_Alloc>& __y) {
 
  size_t __n = _Traits::length(__s);
  return basic_string<_CharT,_Traits,_Alloc> ::_M_compare(__s, __s + __n,
                                                          __y.begin(), __y.end()) < 0;
}

template <class _CharT, class _Traits, class _Alloc>
inline bool
operator<(const basic_string<_CharT,_Traits,_Alloc>& __x,
          const _CharT* __s) {
 
  size_t __n = _Traits::length(__s);
  return basic_string<_CharT,_Traits,_Alloc> ::_M_compare(__x.begin(), __x.end(),
                                                          __s, __s + __n) < 0;
}
# 423 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_string_operators.h"
template <class _CharT, class _Traits, class _Alloc>
inline bool
operator!=(const basic_string<_CharT,_Traits,_Alloc>& __x,
           const basic_string<_CharT,_Traits,_Alloc>& __y)
{ return !(__x == __y); }

template <class _CharT, class _Traits, class _Alloc>
inline bool
operator>(const basic_string<_CharT,_Traits,_Alloc>& __x,
          const basic_string<_CharT,_Traits,_Alloc>& __y)
{ return __y < __x; }

template <class _CharT, class _Traits, class _Alloc>
inline bool
operator<=(const basic_string<_CharT,_Traits,_Alloc>& __x,
           const basic_string<_CharT,_Traits,_Alloc>& __y)
{ return !(__y < __x); }

template <class _CharT, class _Traits, class _Alloc>
inline bool
operator>=(const basic_string<_CharT,_Traits,_Alloc>& __x,
           const basic_string<_CharT,_Traits,_Alloc>& __y)
{ return !(__x < __y); }
# 463 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_string_operators.h"
template <class _CharT, class _Traits, class _Alloc>
inline bool
operator!=(const _CharT* __s,
           const basic_string<_CharT,_Traits,_Alloc>& __y) {
 
  return !(__s == __y);
}

template <class _CharT, class _Traits, class _Alloc>
inline bool
operator!=(const basic_string<_CharT,_Traits,_Alloc>& __x,
           const _CharT* __s) {
 
  return !(__x == __s);
}
# 497 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_string_operators.h"
template <class _CharT, class _Traits, class _Alloc>
inline bool
operator>(const _CharT* __s,
          const basic_string<_CharT,_Traits,_Alloc>& __y) {
 
  return __y < __s;
}

template <class _CharT, class _Traits, class _Alloc>
inline bool
operator>(const basic_string<_CharT,_Traits,_Alloc>& __x,
          const _CharT* __s) {
 
  return __s < __x;
}
# 531 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_string_operators.h"
template <class _CharT, class _Traits, class _Alloc>
inline bool
operator<=(const _CharT* __s,
           const basic_string<_CharT,_Traits,_Alloc>& __y) {
 
  return !(__y < __s);
}

template <class _CharT, class _Traits, class _Alloc>
inline bool
operator<=(const basic_string<_CharT,_Traits,_Alloc>& __x,
           const _CharT* __s) {
 
  return !(__s < __x);
}
# 565 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_string_operators.h"
template <class _CharT, class _Traits, class _Alloc>
inline bool
operator>=(const _CharT* __s,
           const basic_string<_CharT,_Traits,_Alloc>& __y) {
 
  return !(__s < __y);
}

template <class _CharT, class _Traits, class _Alloc>
inline bool
operator>=(const basic_string<_CharT,_Traits,_Alloc>& __x,
           const _CharT* __s) {
 
  return !(__x < __s);
}
# 599 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_string_operators.h"
}
# 1170 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_string.h" 2



# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_string.c" 1
# 32 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_string.c"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_ctraits_fns.h" 1
# 28 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_ctraits_fns.h"
namespace std {

namespace priv {

template <class _Traits>
struct _Eq_traits
  : public binary_function<typename _Traits::char_type,
                           typename _Traits::char_type,
                           bool> {
  bool operator()(const typename _Traits::char_type& __x,
                  const typename _Traits::char_type& __y) const
  { return _Traits::eq(__x, __y); }
};

template <class _Traits>
struct _Eq_char_bound
  : public unary_function<typename _Traits::char_type, bool> {
  typename _Traits::char_type __val;
  _Eq_char_bound(typename _Traits::char_type __c) : __val(__c) {}
  bool operator()(const typename _Traits::char_type& __x) const
  { return _Traits::eq(__x, __val); }
};

template <class _Traits>
struct _Neq_char_bound
  : public unary_function<typename _Traits::char_type, bool>
{
  typename _Traits::char_type __val;
  _Neq_char_bound(typename _Traits::char_type __c) : __val(__c) {}
  bool operator()(const typename _Traits::char_type& __x) const
  { return !_Traits::eq(__x, __val); }
};

template <class _Traits>
struct _Eq_int_bound
  : public unary_function<typename _Traits::char_type, bool> {
  typename _Traits::int_type __val;

  _Eq_int_bound(typename _Traits::int_type __c) : __val(__c) {}
  bool operator()(const typename _Traits::char_type& __x) const
  { return _Traits::eq_int_type(_Traits::to_int_type(__x), __val); }
};
# 83 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_ctraits_fns.h"
}

}
# 33 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_string.c" 2



# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_function.h" 1
# 41 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_function.h"
namespace std {

template <class _Tp>
struct not_equal_to : public binary_function<_Tp, _Tp, bool> {
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x != __y; }
};

template <class _Tp>
struct greater : public binary_function<_Tp, _Tp, bool> {
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x > __y; }
};

template <class _Tp>
struct greater_equal : public binary_function<_Tp, _Tp, bool> {
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x >= __y; }
};

template <class _Tp>
struct less_equal : public binary_function<_Tp, _Tp, bool> {
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x <= __y; }
};

template <class _Tp>
struct divides : public binary_function<_Tp, _Tp, _Tp> {
  _Tp operator()(const _Tp& __x, const _Tp& __y) const { return __x / __y; }
};

template <class _Tp>
struct modulus : public binary_function<_Tp, _Tp, _Tp> {
  _Tp operator()(const _Tp& __x, const _Tp& __y) const { return __x % __y; }
};

template <class _Tp>
struct negate : public unary_function<_Tp, _Tp> {
  _Tp operator()(const _Tp& __x) const { return -__x; }
};

template <class _Tp>
struct logical_and : public binary_function<_Tp, _Tp, bool> {
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x && __y; }
};

template <class _Tp>
struct logical_or : public binary_function<_Tp, _Tp,bool> {
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x || __y; }
};

template <class _Tp>
struct logical_not : public unary_function<_Tp, bool> {
  bool operator()(const _Tp& __x) const { return !__x; }
};



template <class _Tp> inline _Tp identity_element(plus<_Tp>) { return _Tp(0); }
template <class _Tp> inline _Tp identity_element(multiplies<_Tp>) { return _Tp(1); }
# 135 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_function.h"
template <class _Predicate>
class unary_negate
    : public unary_function<typename _Predicate::argument_type, bool> {
  typedef unary_function<typename _Predicate::argument_type, bool> _Base;
public:
  typedef typename _Base::argument_type argument_type;
private:
  typedef typename __call_traits<argument_type>::const_param_type _ArgParamType;
protected:
  _Predicate _M_pred;
public:
  explicit unary_negate(const _Predicate& __x) : _M_pred(__x) {}
  bool operator()(_ArgParamType __x) const {
    return !_M_pred(__x);
  }
};

template <class _Predicate>
inline unary_negate<_Predicate>
not1(const _Predicate& __pred) {
  return unary_negate<_Predicate>(__pred);
}

template <class _Predicate>
class binary_negate
    : public binary_function<typename _Predicate::first_argument_type,
                             typename _Predicate::second_argument_type,
                             bool> {
  typedef binary_function<typename _Predicate::first_argument_type,
                          typename _Predicate::second_argument_type,
                          bool> _Base;
public:
  typedef typename _Base::first_argument_type first_argument_type;
  typedef typename _Base::second_argument_type second_argument_type;
private:
  typedef typename __call_traits<first_argument_type>::const_param_type _FstArgParamType;
  typedef typename __call_traits<second_argument_type>::const_param_type _SndArgParamType;
protected:
  _Predicate _M_pred;
public:
  explicit binary_negate(const _Predicate& __x) : _M_pred(__x) {}
  bool operator()(_FstArgParamType __x, _SndArgParamType __y) const {
    return !_M_pred(__x, __y);
  }
};

template <class _Predicate>
inline binary_negate<_Predicate>
not2(const _Predicate& __pred) {
  return binary_negate<_Predicate>(__pred);
}

template <class _Operation>
class binder1st :
    public unary_function<typename _Operation::second_argument_type,
                          typename _Operation::result_type > {
  typedef unary_function<typename _Operation::second_argument_type,
                         typename _Operation::result_type > _Base;
public:
  typedef typename _Base::argument_type argument_type;
  typedef typename _Base::result_type result_type;
private:
  typedef typename __call_traits<argument_type>::param_type _ArgParamType;
  typedef typename __call_traits<argument_type>::const_param_type _ConstArgParamType;
  typedef typename __call_traits<typename _Operation::first_argument_type>::const_param_type _ValueParamType;
protected:

  _Operation op;
  typename _Operation::first_argument_type _M_value;
public:
  binder1st(const _Operation& __x, _ValueParamType __y)
    : op(__x), _M_value(__y) {}

  result_type operator()(_ConstArgParamType __x) const
  { return op(_M_value, __x); }

  result_type operator()(_ArgParamType __x) const
  { return op(_M_value, __x); }
};

template <class _Operation, class _Tp>
inline binder1st<_Operation>
bind1st(const _Operation& __fn, const _Tp& __x) {
  typedef typename _Operation::first_argument_type _Arg1_type;
  return binder1st<_Operation>(__fn, _Arg1_type(__x));
}

template <class _Operation>
class binder2nd
  : public unary_function<typename _Operation::first_argument_type,
                          typename _Operation::result_type> {
  typedef unary_function<typename _Operation::first_argument_type,
                         typename _Operation::result_type> _Base;
public:
  typedef typename _Base::argument_type argument_type;
  typedef typename _Base::result_type result_type;
private:
  typedef typename __call_traits<argument_type>::param_type _ArgParamType;
  typedef typename __call_traits<argument_type>::const_param_type _ConstArgParamType;
  typedef typename __call_traits<typename _Operation::second_argument_type>::const_param_type _ValueParamType;
protected:

  _Operation op;
  typename _Operation::second_argument_type value;
public:
  binder2nd(const _Operation& __x, _ValueParamType __y)
      : op(__x), value(__y) {}

  result_type operator()(_ConstArgParamType __x) const
  { return op(__x, value); }

  result_type operator()(_ArgParamType __x) const
  { return op(__x, value); }
};

template <class _Operation, class _Tp>
inline binder2nd<_Operation>
bind2nd(const _Operation& __fn, const _Tp& __x) {
  typedef typename _Operation::second_argument_type _Arg2_type;
  return binder2nd<_Operation>(__fn, _Arg2_type(__x));
}




template <class _Operation1, class _Operation2>
class unary_compose :
  public unary_function<typename _Operation2::argument_type,
                        typename _Operation1::result_type> {
  typedef unary_function<typename _Operation2::argument_type,
                         typename _Operation1::result_type> _Base;
public:
  typedef typename _Base::argument_type argument_type;
  typedef typename _Base::result_type result_type;
private:
  typedef typename __call_traits<argument_type>::const_param_type _ArgParamType;
protected:
  _Operation1 _M_fn1;
  _Operation2 _M_fn2;
public:
  unary_compose(const _Operation1& __x, const _Operation2& __y)
    : _M_fn1(__x), _M_fn2(__y) {}

  result_type operator()(_ArgParamType __x) const {
    return _M_fn1(_M_fn2(__x));
  }
};

template <class _Operation1, class _Operation2>
inline unary_compose<_Operation1,_Operation2>
compose1(const _Operation1& __fn1, const _Operation2& __fn2) {
  return unary_compose<_Operation1,_Operation2>(__fn1, __fn2);
}

template <class _Operation1, class _Operation2, class _Operation3>
class binary_compose :
    public unary_function<typename _Operation2::argument_type,
                          typename _Operation1::result_type> {
  typedef unary_function<typename _Operation2::argument_type,
                         typename _Operation1::result_type> _Base;
public:
  typedef typename _Base::argument_type argument_type;
  typedef typename _Base::result_type result_type;
private:
  typedef typename __call_traits<argument_type>::const_param_type _ArgParamType;
protected:
  _Operation1 _M_fn1;
  _Operation2 _M_fn2;
  _Operation3 _M_fn3;
public:
  binary_compose(const _Operation1& __x, const _Operation2& __y,
                 const _Operation3& __z)
    : _M_fn1(__x), _M_fn2(__y), _M_fn3(__z) { }

  result_type operator()(_ArgParamType __x) const {
    return _M_fn1(_M_fn2(__x), _M_fn3(__x));
  }
};

template <class _Operation1, class _Operation2, class _Operation3>
inline binary_compose<_Operation1, _Operation2, _Operation3>
compose2(const _Operation1& __fn1, const _Operation2& __fn2,
         const _Operation3& __fn3) {
  return binary_compose<_Operation1,_Operation2,_Operation3>(__fn1, __fn2, __fn3);
}


template <class _Tp> struct identity : public ::std::priv:: _Identity<_Tp> {};

template <class _Pair> struct select1st : public ::std::priv:: _Select1st<_Pair> {};
template <class _Pair> struct select2nd : public ::std::priv:: _Select2nd<_Pair> {};

template <class _Arg1, class _Arg2>
struct project1st : public ::std::priv:: _Project1st<_Arg1, _Arg2> {};

template <class _Arg1, class _Arg2>
struct project2nd : public ::std::priv:: _Project2nd<_Arg1, _Arg2> {};






namespace priv {

template <class _Result>
struct _Constant_void_fun {
  typedef _Result result_type;
  result_type _M_val;

  _Constant_void_fun(const result_type& __v) : _M_val(__v) {}
  const result_type& operator()() const { return _M_val; }
};

}

template <class _Result>
struct constant_void_fun : public ::std::priv:: _Constant_void_fun<_Result> {
  constant_void_fun(const _Result& __v)
    : ::std::priv:: _Constant_void_fun<_Result>(__v) {}
};

template <class _Result, class _Argument = _Result >
struct constant_unary_fun : public ::std::priv:: _Constant_unary_fun<_Result, _Argument> {
  constant_unary_fun(const _Result& __v)
    : ::std::priv:: _Constant_unary_fun<_Result, _Argument>(__v) {}
};

template <class _Result, class _Arg1 = _Result, class _Arg2 = _Arg1 >
struct constant_binary_fun
  : public ::std::priv:: _Constant_binary_fun<_Result, _Arg1, _Arg2> {
  constant_binary_fun(const _Result& __v)
    : ::std::priv:: _Constant_binary_fun<_Result, _Arg1, _Arg2>(__v) {}
};

template <class _Result>
inline constant_void_fun<_Result> constant0(const _Result& __val) {
  return constant_void_fun<_Result>(__val);
}

template <class _Result>
inline constant_unary_fun<_Result,_Result> constant1(const _Result& __val) {
  return constant_unary_fun<_Result,_Result>(__val);
}

template <class _Result>
inline constant_binary_fun<_Result,_Result,_Result>
constant2(const _Result& __val) {
  return constant_binary_fun<_Result,_Result,_Result>(__val);
}



class subtractive_rng : public unary_function<unsigned long, unsigned long> {
private:
  unsigned long _M_table[55];
  unsigned long _M_index1;
  unsigned long _M_index2;
public:
  unsigned long operator()(unsigned long __limit) {
    _M_index1 = (_M_index1 + 1) % 55;
    _M_index2 = (_M_index2 + 1) % 55;
    _M_table[_M_index1] = _M_table[_M_index1] - _M_table[_M_index2];
    return _M_table[_M_index1] % __limit;
  }

  void _M_initialize(unsigned long __seed) {
    unsigned long __k = 1;
    _M_table[54] = __seed;
    unsigned long __i;
    for (__i = 0; __i < 54; __i++) {
        unsigned long __ii = (21 * (__i + 1) % 55) - 1;
        _M_table[__ii] = __k;
        __k = __seed - __k;
        __seed = _M_table[__ii];
    }
    for (int __loop = 0; __loop < 4; __loop++) {
        for (__i = 0; __i < 55; __i++)
            _M_table[__i] = _M_table[__i] - _M_table[(1 + __i + 30) % 55];
    }
    _M_index1 = 0;
    _M_index2 = 31;
  }

  subtractive_rng(unsigned int __seed) { _M_initialize(__seed); }
  subtractive_rng() { _M_initialize(161803398ul); }
};



}

# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_function_adaptors.h" 1
# 58 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_function_adaptors.h"
namespace std {
# 498 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_function_adaptors.h"
template <class _Ret, class _Tp>
class mem_fun_t : public unary_function<_Tp*,_Ret> {
  typedef _Ret (_Tp::*__fun_type)(void);
public:
  explicit mem_fun_t(__fun_type __pf) : _M_f(__pf) {}
  _Ret operator()(_Tp* __p) const { return (__p->*_M_f)(); }
private:
  __fun_type _M_f;
};

template <class _Ret, class _Tp>
class const_mem_fun_t : public unary_function<const _Tp*,_Ret> {
  typedef _Ret (_Tp::*__fun_type)(void) const;
public:
  explicit const_mem_fun_t(__fun_type __pf) : _M_f(__pf) {}
  _Ret operator()(const _Tp* __p) const { return (__p->*_M_f)(); }
private:
  __fun_type _M_f;
};

template <class _Ret, class _Tp>
class mem_fun_ref_t : public unary_function<_Tp,_Ret> {
  typedef _Ret (_Tp::*__fun_type)(void);
public:
  explicit mem_fun_ref_t(__fun_type __pf) : _M_f(__pf) {}
  _Ret operator()(_Tp& __r) const { return (__r.*_M_f)(); }
private:
  __fun_type _M_f;
};

template <class _Ret, class _Tp>
class const_mem_fun_ref_t : public unary_function<_Tp,_Ret> {
  typedef _Ret (_Tp::*__fun_type)(void) const;
public:
  explicit const_mem_fun_ref_t(__fun_type __pf) : _M_f(__pf) {}
  _Ret operator()(const _Tp& __r) const { return (__r.*_M_f)(); }
private:
  __fun_type _M_f;
};

template <class _Ret, class _Tp, class _Arg>
class mem_fun1_t : public binary_function<_Tp*,_Arg,_Ret> {
  typedef _Ret (_Tp::*__fun_type)(_Arg);
public:
  explicit mem_fun1_t(__fun_type __pf) : _M_f(__pf) {}
  _Ret operator()(_Tp* __p, _Arg __x) const { return (__p->*_M_f)(__x); }
private:
  __fun_type _M_f;
};

template <class _Ret, class _Tp, class _Arg>
class const_mem_fun1_t : public binary_function<const _Tp*,_Arg,_Ret> {
  typedef _Ret (_Tp::*__fun_type)(_Arg) const;
public:
  explicit const_mem_fun1_t(__fun_type __pf) : _M_f(__pf) {}
  _Ret operator()(const _Tp* __p, _Arg __x) const
    { return (__p->*_M_f)(__x); }
private:
  __fun_type _M_f;
};

template <class _Ret, class _Tp, class _Arg>
class mem_fun1_ref_t : public binary_function<_Tp,_Arg,_Ret> {
  typedef _Ret (_Tp::*__fun_type)(_Arg);
public:
  explicit mem_fun1_ref_t(__fun_type __pf) : _M_f(__pf) {}
  _Ret operator()(_Tp& __r, _Arg __x) const { return (__r.*_M_f)(__x); }
private:
  __fun_type _M_f;
};

template <class _Ret, class _Tp, class _Arg>
class const_mem_fun1_ref_t : public binary_function<_Tp,_Arg,_Ret> {
  typedef _Ret (_Tp::*__fun_type)(_Arg) const;
public:
  explicit const_mem_fun1_ref_t(__fun_type __pf) : _M_f(__pf) {}
  _Ret operator()(const _Tp& __r, _Arg __x) const { return (__r.*_M_f)(__x); }
private:
  __fun_type _M_f;
};

template <class _Arg, class _Result>
class pointer_to_unary_function : public unary_function<_Arg, _Result> {
protected:
  _Result (*_M_ptr)(_Arg);
public:
  pointer_to_unary_function() {}
  explicit pointer_to_unary_function(_Result (*__x)(_Arg)) : _M_ptr(__x) {}
  _Result operator()(_Arg __x) const { return _M_ptr(__x); }
};

template <class _Arg1, class _Arg2, class _Result>
class pointer_to_binary_function :
  public binary_function<_Arg1,_Arg2,_Result> {
protected:
    _Result (*_M_ptr)(_Arg1, _Arg2);
public:
    pointer_to_binary_function() {}
    explicit pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2))
      : _M_ptr(__x) {}
    _Result operator()(_Arg1 __x, _Arg2 __y) const {
      return _M_ptr(__x, __y);
    }
};
# 718 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_function_adaptors.h"
template <class _Result, class _Tp>
inline mem_fun_t<_Result,_Tp>
mem_fun(_Result (_Tp::*__f)()) { return mem_fun_t<_Result,_Tp>(__f); }

template <class _Result, class _Tp>
inline const_mem_fun_t<_Result,_Tp>
mem_fun(_Result (_Tp::*__f)() const) { return const_mem_fun_t<_Result,_Tp>(__f); }

template <class _Result, class _Tp>
inline mem_fun_ref_t<_Result,_Tp>
mem_fun_ref(_Result (_Tp::*__f)()) { return mem_fun_ref_t<_Result,_Tp>(__f); }

template <class _Result, class _Tp>
inline const_mem_fun_ref_t<_Result,_Tp>
mem_fun_ref(_Result (_Tp::*__f)() const) { return const_mem_fun_ref_t<_Result,_Tp>(__f); }

template <class _Result, class _Tp, class _Arg>
inline mem_fun1_t<_Result,_Tp,_Arg>
mem_fun(_Result (_Tp::*__f)(_Arg)) { return mem_fun1_t<_Result,_Tp,_Arg>(__f); }

template <class _Result, class _Tp, class _Arg>
inline const_mem_fun1_t<_Result,_Tp,_Arg>
mem_fun(_Result (_Tp::*__f)(_Arg) const) { return const_mem_fun1_t<_Result,_Tp,_Arg>(__f); }

template <class _Result, class _Tp, class _Arg>
inline mem_fun1_ref_t<_Result,_Tp,_Arg>
mem_fun_ref(_Result (_Tp::*__f)(_Arg)) { return mem_fun1_ref_t<_Result,_Tp,_Arg>(__f); }

template <class _Result, class _Tp, class _Arg>
inline const_mem_fun1_ref_t<_Result,_Tp,_Arg>
mem_fun_ref(_Result (_Tp::*__f)(_Arg) const) { return const_mem_fun1_ref_t<_Result,_Tp,_Arg>(__f); }




template <class _Result, class _Tp, class _Arg>
inline mem_fun1_t<_Result,_Tp,_Arg>
mem_fun1(_Result (_Tp::*__f)(_Arg)) { return mem_fun1_t<_Result,_Tp,_Arg>(__f); }

template <class _Result, class _Tp, class _Arg>
inline const_mem_fun1_t<_Result,_Tp,_Arg>
mem_fun1(_Result (_Tp::*__f)(_Arg) const) { return const_mem_fun1_t<_Result,_Tp,_Arg>(__f); }

template <class _Result, class _Tp, class _Arg>
inline mem_fun1_ref_t<_Result,_Tp,_Arg>
mem_fun1_ref(_Result (_Tp::*__f)(_Arg)) { return mem_fun1_ref_t<_Result,_Tp,_Arg>(__f); }

template <class _Result, class _Tp, class _Arg>
inline const_mem_fun1_ref_t<_Result,_Tp,_Arg>
mem_fun1_ref(_Result (_Tp::*__f)(_Arg) const) { return const_mem_fun1_ref_t<_Result,_Tp,_Arg>(__f); }





template <class _Arg, class _Result>
inline pointer_to_unary_function<_Arg, _Result>
ptr_fun(_Result (*__f)(_Arg))
{ return pointer_to_unary_function<_Arg, _Result>(__f); }

template <class _Arg1, class _Arg2, class _Result>
inline pointer_to_binary_function<_Arg1,_Arg2,_Result>
ptr_fun(_Result (*__f)(_Arg1, _Arg2))
{ return pointer_to_binary_function<_Arg1,_Arg2,_Result>(__f); }

}
# 428 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_function.h" 2
# 37 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_string.c" 2
# 53 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_string.c"
namespace std {

namespace priv {


template <class _Traits>
struct _Not_within_traits : public unary_function<typename _Traits::char_type, bool> {
  typedef typename _Traits::char_type _CharT;
  const _CharT* _M_first;
  const _CharT* _M_last;

  _Not_within_traits(const _CharT* __f, const _CharT* __l)
    : _M_first(__f), _M_last(__l) {}

  bool operator()(const _CharT& __x) const {
    return find_if(_M_first, _M_last,
                   ::std::priv:: _Eq_char_bound<_Traits>(__x)) == _M_last;
  }
};

template <class _InputIter, class _CharT, class _Traits>
inline _InputIter __str_find_first_of_aux(_InputIter __first1, _InputIter __last1,
                                          const _CharT* __first2, const _CharT* __last2,
                                          _Traits*, const __true_type& )
{ return __find_first_of(__first1, __last1, __first2, __last2); }

template <class _InputIter, class _CharT, class _Traits>
inline _InputIter __str_find_first_of_aux(_InputIter __first1, _InputIter __last1,
                                          const _CharT* __first2, const _CharT* __last2,
                                          _Traits*, const __false_type& )
{ return __find_first_of(__first1, __last1, __first2, __last2, ::std::priv:: _Eq_traits<_Traits>()); }

template <class _InputIter, class _CharT, class _Traits>
inline _InputIter __str_find_first_of(_InputIter __first1, _InputIter __last1,
                                      const _CharT* __first2, const _CharT* __last2,
                                      _Traits* __traits) {

  typedef typename _IsSTLportClass<_Traits>::_Ret _STLportTraits;




  return __str_find_first_of_aux(__first1, __last1, __first2, __last2, __traits, _STLportTraits());
}

template <class _InputIter, class _CharT, class _Traits>
inline _InputIter __str_find_first_not_of_aux3(_InputIter __first1, _InputIter __last1,
                                               const _CharT* __first2, const _CharT* __last2,
                                               _Traits* , const __true_type& __useStrcspnLikeAlgo)
{ return __find_first_of_aux2(__first1, __last1, __first2, __last2, __first2, not1(_Identity<bool>()), __useStrcspnLikeAlgo); }

template <class _InputIter, class _CharT, class _Traits>
inline _InputIter __str_find_first_not_of_aux3(_InputIter __first1, _InputIter __last1,
                                               const _CharT* __first2, const _CharT* __last2,
                                               _Traits* , const __false_type& )
{ return ::std::find_if(__first1, __last1, ::std::priv:: _Not_within_traits<_Traits>(__first2, __last2)); }

template <class _InputIter, class _CharT, class _Tp, class _Traits>
inline _InputIter __str_find_first_not_of_aux2(_InputIter __first1, _InputIter __last1,
                                               const _CharT* __first2, const _CharT* __last2,
                                               _Tp* __pt, _Traits* __traits) {
  typedef typename _IsIntegral<_Tp>::_Ret _IsIntegral;
  typedef typename _IsCharLikeType<_CharT>::_Ret _IsCharLike;
  typedef typename _Land2<_IsIntegral, _IsCharLike>::_Ret _UseStrcspnLikeAlgo;
  return __str_find_first_not_of_aux3(__first1, __last1, __first2, __last2, __traits, _UseStrcspnLikeAlgo());
}

template <class _InputIter, class _CharT, class _Traits>
inline _InputIter __str_find_first_not_of_aux1(_InputIter __first1, _InputIter __last1,
                                               const _CharT* __first2, const _CharT* __last2,
                                               _Traits* __traits, const __true_type& )
{ return __str_find_first_not_of_aux2(__first1, __last1, __first2, __last2,
                                      (typename ::std::iterator_traits< _InputIter >::value_type*)0, __traits); }

template <class _InputIter, class _CharT, class _Traits>
inline _InputIter __str_find_first_not_of_aux1(_InputIter __first1, _InputIter __last1,
                                               const _CharT* __first2, const _CharT* __last2,
                                               _Traits*, const __false_type& )
{ return ::std::find_if(__first1, __last1, ::std::priv:: _Not_within_traits<_Traits>(__first2, __last2)); }

template <class _InputIter, class _CharT, class _Traits>
inline _InputIter __str_find_first_not_of(_InputIter __first1, _InputIter __last1,
                                          const _CharT* __first2, const _CharT* __last2,
                                          _Traits* __traits) {

  typedef typename _IsSTLportClass<_Traits>::_Ret _STLportTraits;




  return __str_find_first_not_of_aux1(__first1, __last1, __first2, __last2, __traits, _STLportTraits());
}





}






template <class _CharT, class _Traits, class _Alloc>
void basic_string<_CharT,_Traits,_Alloc>::reserve(size_type __res_arg) {
  if (__res_arg > max_size())
    this->_M_throw_length_error();

  size_type __n = (max)(__res_arg, size()) + 1;
  if (__n < this->_M_capacity())
    return;

  _M_reserve(__n);
}

template <class _CharT, class _Traits, class _Alloc>
void basic_string<_CharT,_Traits,_Alloc>::_M_reserve(size_type __n) {
  pointer __new_start = this->_M_start_of_storage.allocate(__n, __n);
  pointer __new_finish = ::std::priv:: __ucopy(this->_M_Start(), this->_M_Finish(), __new_start);
  _M_construct_null(__new_finish);
  this->_M_deallocate_block();
  this->_M_reset(__new_start, __new_finish, __new_start + __n);
}

template <class _CharT, class _Traits, class _Alloc>
basic_string<_CharT,_Traits,_Alloc>&
basic_string<_CharT,_Traits,_Alloc>::append(size_type __n, _CharT __c) {
  if (__n > 0) {
    if (__n > max_size() - size())
      this->_M_throw_length_error();
    if (__n >= this->_M_rest())
      _M_reserve(_M_compute_next_size(__n));
    ::std::priv:: __uninitialized_fill_n(this->_M_finish + 1, __n - 1, __c);
    _M_construct_null(this->_M_finish + __n);
    _Traits::assign(*end(), __c);
    this->_M_finish += __n;
  }
  return *this;
}

template <class _CharT, class _Traits, class _Alloc>
basic_string<_CharT, _Traits, _Alloc>&
basic_string<_CharT, _Traits, _Alloc>::_M_append(const _CharT* __first, const _CharT* __last) {
  if (__first != __last) {
    size_type __n = static_cast<size_type>(__last - __first);
    if (__n >= this->_M_rest()) {
      size_type __len = _M_compute_next_size(__n);
      pointer __new_start = this->_M_start_of_storage.allocate(__len, __len);
      pointer __new_finish = ::std::priv:: __ucopy(this->_M_Start(), this->_M_Finish(), __new_start);
      __new_finish = ::std::priv:: __ucopy(__first, __last, __new_finish);
      _M_construct_null(__new_finish);
      this->_M_deallocate_block();
      this->_M_reset(__new_start, __new_finish, __new_start + __len);
    }
    else {
      const _CharT* __f1 = __first;
      ++__f1;
      ::std::priv:: __ucopy(__f1, __last, this->_M_finish + 1);
      _M_construct_null(this->_M_finish + __n);
      _Traits::assign(*end(), *__first);
      this->_M_finish += __n;
    }
  }
  return *this;
}

template <class _CharT, class _Traits, class _Alloc>
basic_string<_CharT,_Traits,_Alloc>&
basic_string<_CharT,_Traits,_Alloc>::assign(size_type __n, _CharT __c) {
  if (__n <= size()) {
    _Traits::assign(this->_M_Start(), __n, __c);
    erase(begin() + __n, end());
  }
  else {
    if (__n < capacity()) {
      _Traits::assign(this->_M_Start(), size(), __c);
      append(__n - size(), __c);
    }
    else {
      _Self __str(__n, __c);
      this->swap(__str);
    }
  }
  return *this;
}

template <class _CharT, class _Traits, class _Alloc>
basic_string<_CharT,_Traits,_Alloc>&
basic_string<_CharT,_Traits,_Alloc>::_M_assign(const _CharT* __f, const _CharT* __l) {
  ptrdiff_t __n = __l - __f;
  if (static_cast<size_type>(__n) <= size()) {
    _Traits::move(this->_M_Start(), __f, __n);
    erase(begin() + __n, end());
  }
  else {
    _Traits::move(this->_M_Start(), __f, size());
    _M_append(__f + size(), __l);
  }
  return *this;
}

template <class _CharT, class _Traits, class _Alloc>
_CharT* basic_string<_CharT,_Traits,_Alloc> ::_M_insert_aux(_CharT* __p,
                                                            _CharT __c) {
  pointer __new_pos = __p;
  if (this->_M_rest() > 1 ) {
    _M_construct_null(this->_M_finish + 1);
    _Traits::move(__p + 1, __p, this->_M_finish - __p);
    _Traits::assign(*__p, __c);
    ++this->_M_finish;
  }
  else {
    size_type __len = _M_compute_next_size(1);
    pointer __new_start = this->_M_start_of_storage.allocate(__len, __len);
    __new_pos = ::std::priv:: __ucopy(this->_M_Start(), __p, __new_start);
    _Traits::assign(*__new_pos, __c);
    pointer __new_finish = __new_pos + 1;
    __new_finish = ::std::priv:: __ucopy(__p, this->_M_finish, __new_finish);
    _M_construct_null(__new_finish);
    this->_M_deallocate_block();
    this->_M_reset(__new_start, __new_finish, __new_start + __len);
  }
  return __new_pos;
}

template <class _CharT, class _Traits, class _Alloc>
void basic_string<_CharT,_Traits,_Alloc>::insert(iterator __pos,
                                                 size_t __n, _CharT __c) {
  if (__n != 0) {
    if (this->_M_rest() > __n) {
      const size_type __elems_after = this->_M_finish - __pos;
      pointer __old_finish = this->_M_finish;
      if (__elems_after >= __n) {
        ::std::priv:: __ucopy((this->_M_finish - __n) + 1, this->_M_finish + 1, this->_M_finish + 1);
        this->_M_finish += __n;
        _Traits::move(__pos + __n, __pos, (__elems_after - __n) + 1);
        _Traits::assign(__pos, __n, __c);
      }
      else {
        ::std::priv:: __uninitialized_fill_n(this->_M_finish + 1, __n - __elems_after - 1, __c);
        this->_M_finish += __n - __elems_after;
        ::std::priv:: __ucopy(__pos, __old_finish + 1, this->_M_finish);
        this->_M_finish += __elems_after;
        _Traits::assign(__pos, __elems_after + 1, __c);
      }
    }
    else {
      size_type __len = _M_compute_next_size(__n);
      pointer __new_start = this->_M_start_of_storage.allocate(__len, __len);
      pointer __new_finish = ::std::priv:: __ucopy(this->_M_Start(), __pos, __new_start);
      __new_finish = ::std::priv:: __uninitialized_fill_n(__new_finish, __n, __c);
      __new_finish = ::std::priv:: __ucopy(__pos, this->_M_finish, __new_finish);
      _M_construct_null(__new_finish);
      this->_M_deallocate_block();
      this->_M_reset(__new_start, __new_finish, __new_start + __len);
    }
  }
}

template <class _CharT, class _Traits, class _Alloc>
void basic_string<_CharT,_Traits,_Alloc>::_M_insert(iterator __pos,
                                                    const _CharT* __first, const _CharT* __last,
                                                    bool __self_ref) {

  if (__first != __last) {
    const size_t __n = __last - __first;
    if (this->_M_rest() > __n) {
      const size_t __elems_after = this->_M_finish - __pos;
      pointer __old_finish = this->_M_finish;
      if (__elems_after >= __n) {
        ::std::priv:: __ucopy((this->_M_finish - __n) + 1, this->_M_finish + 1, this->_M_finish + 1);
        this->_M_finish += __n;
        _Traits::move(__pos + __n, __pos, (__elems_after - __n) + 1);
        if (!__self_ref || __last < __pos) {
          _M_copy(__first, __last, __pos);
        }
        else {

          if (__first >= __pos) {

            __first += __n;
            __last += __n;
            _M_copy(__first, __last, __pos);
          }
          else {

            _M_move(__first, __last, __pos);
          }
        }
      }
      else {
        const_iterator __mid = __first;
        __mid += __elems_after + 1;
        ::std::priv:: __ucopy(__mid, __last, this->_M_finish + 1);
        this->_M_finish += __n - __elems_after;
        ::std::priv:: __ucopy(__pos, __old_finish + 1, this->_M_finish);
        this->_M_finish += __elems_after;
        if (!__self_ref)
          _M_copy(__first, __mid, __pos);
        else
          _M_move(__first, __mid, __pos);
      }
    }
    else {
      size_type __len = _M_compute_next_size(__n);
      pointer __new_start = this->_M_start_of_storage.allocate(__len, __len);
      pointer __new_finish = ::std::priv:: __ucopy(this->_M_Start(), __pos, __new_start);
      __new_finish = ::std::priv:: __ucopy(__first, __last, __new_finish);
      __new_finish = ::std::priv:: __ucopy(__pos, this->_M_finish, __new_finish);
      _M_construct_null(__new_finish);
      this->_M_deallocate_block();
      this->_M_reset(__new_start, __new_finish, __new_start + __len);
    }
  }
}

template <class _CharT, class _Traits, class _Alloc>
basic_string<_CharT,_Traits,_Alloc>&
basic_string<_CharT,_Traits,_Alloc> ::replace(iterator __first, iterator __last,
                                              size_type __n, _CharT __c) {
  size_type __len = (size_type)(__last - __first);

  if (__len >= __n) {
    _Traits::assign(__first, __n, __c);
    erase(__first + __n, __last);
  }
  else {
    _Traits::assign(__first, __len, __c);
    insert(__last, __n - __len, __c);
  }
  return *this;
}

template <class _CharT, class _Traits, class _Alloc>
basic_string<_CharT,_Traits,_Alloc>&
basic_string<_CharT,_Traits,_Alloc> ::_M_replace(iterator __first, iterator __last,
                                                 const _CharT* __f, const _CharT* __l,
                                                 bool __self_ref) {
  const ptrdiff_t __n = __l - __f;
  const difference_type __len = __last - __first;
  if (__len >= __n) {
    if (!__self_ref || __l < __first || __f >= __last)
      _M_copy(__f, __l, __first);
    else
      _M_move(__f, __l, __first);
    erase(__first + __n, __last);
  } else if (!__self_ref || (__f >= __last) || (__l <= __first)) {
    const_iterator __m = __f + __len;
    _M_copy(__f, __m, __first);
    _M_insert(__last, __m, __l, __self_ref );
  } else if (__f < __first) {
    const_iterator __m = __f + __len;

    const difference_type __off_dest = __first - this->begin();
    const difference_type __off_src = __f - this->begin();
    _M_insert(__last, __m, __l, true);
    _Traits::move(begin() + __off_dest, begin() + __off_src, __len);
  } else {
    const_iterator __m = __f + __len;
    _Traits::move(__first, __f, __len);
    _M_insert(__last, __m, __l, true);
  }
  return *this;
}

template <class _CharT, class _Traits, class _Alloc>
typename basic_string<_CharT,_Traits,_Alloc>::size_type basic_string<_CharT,_Traits,_Alloc>::find( const _CharT* __s, size_type __pos,
                                                         size_type __n) const
{
  const size_t __len = size();
  if (__pos >= __len || __pos + __n > __len) {
    if ( __n == 0 && __pos <= __len ) {
      return __pos;
    }
    return npos;
  }

  const_pointer __result =
    ::std::search(this->_M_Start() + __pos, this->_M_Finish(),
                      __s, __s + __n, ::std::priv:: _Eq_traits<_Traits>());
  return __result != this->_M_Finish() ? __result - this->_M_Start() : npos;
}

template <class _CharT, class _Traits, class _Alloc>
typename basic_string<_CharT,_Traits,_Alloc>::size_type basic_string<_CharT,_Traits,_Alloc>::find(_CharT __c, size_type __pos) const
{
  if (__pos >= size()) {
    return npos;
  }

  const_pointer __result =
    ::std::find_if(this->_M_Start() + __pos, this->_M_Finish(),
                       ::std::priv:: _Eq_char_bound<_Traits>(__c));
  return __result != this->_M_Finish() ? __result - this->_M_Start() : npos;
}

template <class _CharT, class _Traits, class _Alloc>
typename basic_string<_CharT,_Traits,_Alloc>::size_type basic_string<_CharT,_Traits,_Alloc>::rfind(const _CharT* __s, size_type __pos,
                                                         size_type __n) const
{
  const size_type __len = size();
  if ( __len < __n ) {
    return npos;
  }
  const_pointer __last = this->_M_Start() + (min)( __len - __n, __pos) + __n;
  if ( __n == 0 ) {
    return __last - this->_M_Start();
  }
  const_pointer __result = ::std::find_end(this->_M_Start(), __last,
                                               __s, __s + __n, ::std::priv:: _Eq_traits<_Traits>());
  return __result != __last ? __result - this->_M_Start() : npos;
}

template <class _CharT, class _Traits, class _Alloc>
typename basic_string<_CharT,_Traits,_Alloc>::size_type basic_string<_CharT,_Traits,_Alloc>::rfind(_CharT __c, size_type __pos) const
{
  const size_type __len = size();
  if ( __len < 1 ) {
    return npos;
  }
  const_iterator __last = begin() + (min)(__len - 1, __pos) + 1;
  const_reverse_iterator __rresult =
    ::std::find_if(const_reverse_iterator(__last), rend(),
                       ::std::priv:: _Eq_char_bound<_Traits>(__c));
  return __rresult != rend() ? (__rresult.base() - 1) - begin() : npos;
}

template <class _CharT, class _Traits, class _Alloc> typename basic_string<_CharT,_Traits,_Alloc>::size_type
basic_string<_CharT,_Traits,_Alloc> ::find_first_of(const _CharT* __s, size_type __pos,
                                                    size_type __n) const {
  if (__pos >= size())
    return npos;
  else {
    const_iterator __result = ::std::priv:: __str_find_first_of(begin() + __pos, end(),
                                                             __s, __s + __n,
                                                             static_cast<_Traits*>(0));
    return __result != end() ? __result - begin() : npos;
  }
}

template <class _CharT, class _Traits, class _Alloc>
 typename basic_string<_CharT,_Traits,_Alloc>::size_type
basic_string<_CharT,_Traits,_Alloc> ::find_last_of(const _CharT* __s, size_type __pos,
                                                   size_type __n) const
{
  const size_type __len = size();
  if ( __len < 1 ) {
    return npos;
  }
  const const_iterator __last = begin() + (min)(__len - 1, __pos) + 1;
  const const_reverse_iterator __rresult =
    ::std::priv:: __str_find_first_of(const_reverse_iterator(__last), rend(),
                                   __s, __s + __n,
                                   static_cast<_Traits*>(0));
  return __rresult != rend() ? (__rresult.base() - 1) - begin() : npos;
}


template <class _CharT, class _Traits, class _Alloc> typename basic_string<_CharT,_Traits,_Alloc>::size_type
basic_string<_CharT,_Traits,_Alloc> ::find_first_not_of(const _CharT* __s, size_type __pos,
                                                        size_type __n) const {
  typedef typename _Traits::char_type _CharType;
  if (__pos >= size())
    return npos;
  else {
    const_pointer __result = ::std::priv:: __str_find_first_not_of(this->_M_Start() + __pos, this->_M_Finish(),
                                                                static_cast<const _CharType*>(__s),
                                                                static_cast<const _CharType*>(__s) + __n,
                                                                static_cast<_Traits*>(0));
    return __result != this->_M_finish ? __result - this->_M_Start() : npos;
  }
}

template <class _CharT, class _Traits, class _Alloc> typename basic_string<_CharT,_Traits,_Alloc>::size_type
basic_string<_CharT,_Traits,_Alloc> ::find_first_not_of(_CharT __c, size_type __pos) const {
  if (1 > size())
    return npos;
  else {
    const_pointer __result = ::std::find_if(this->_M_Start() + __pos, this->_M_Finish(),
                                                ::std::priv:: _Neq_char_bound<_Traits>(__c));
    return __result != this->_M_finish ? __result - this->_M_Start() : npos;
  }
}

template <class _CharT, class _Traits, class _Alloc>
typename basic_string<_CharT,_Traits,_Alloc>::size_type
basic_string<_CharT,_Traits,_Alloc>::find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const
{
  typedef typename _Traits::char_type _CharType;
  const size_type __len = size();
  if ( __len < 1 ) {
    return npos;
  }
  const_iterator __last = begin() + (min)(__len - 1, __pos) + 1;
  const_reverse_iterator __rlast = const_reverse_iterator(__last);
  const_reverse_iterator __rresult =
    ::std::priv:: __str_find_first_not_of(__rlast, rend(),
                                       static_cast<const _CharType*>(__s),
                                       static_cast<const _CharType*>(__s) + __n,
                                       static_cast<_Traits*>(0));
  return __rresult != rend() ? (__rresult.base() - 1) - begin() : npos;
}

template <class _CharT, class _Traits, class _Alloc>
typename basic_string<_CharT,_Traits,_Alloc>::size_type
basic_string<_CharT, _Traits, _Alloc>::find_last_not_of(_CharT __c, size_type __pos) const
{
  const size_type __len = size();
  if ( __len < 1 ) {
    return npos;
  }
  const_iterator __last = begin() + (min)(__len - 1, __pos) + 1;
  const_reverse_iterator __rlast = const_reverse_iterator(__last);
  const_reverse_iterator __rresult =
    ::std::find_if(__rlast, rend(),
                       ::std::priv:: _Neq_char_bound<_Traits>(__c));
  return __rresult != rend() ? (__rresult.base() - 1) - begin() : npos;
}


namespace priv {


template <class _CharT, class _Traits, class _Alloc>
void _S_string_copy(const basic_string<_CharT,_Traits,_Alloc>& __s,
                               _CharT* __buf, size_t __n) {
  if (__n > 0) {
    __n = (min) (__n - 1, __s.size());
    ::std::copy(__s.begin(), __s.begin() + __n, __buf);
    __buf[__n] = _CharT();
  }
}

}

}



namespace std {

namespace priv {


template <class _Tp, class _Alloc>
void _String_base<_Tp,_Alloc>::_M_throw_length_error() const
{ __stl_throw_length_error("basic_string"); }

template <class _Tp, class _Alloc>
void _String_base<_Tp, _Alloc>::_M_throw_out_of_range() const
{ __stl_throw_out_of_range("basic_string"); }

template <class _Tp, class _Alloc>
void _String_base<_Tp, _Alloc>::_M_allocate_block(size_t __n) {
  if ((__n <= (max_size() + 1)) && (__n > 0)) {

    if (__n > _DEFAULT_SIZE) {
      this->_M_start_of_storage._M_data = _M_start_of_storage.allocate(__n, __n);
      this->_M_finish = this->_M_start_of_storage._M_data;
      this->_M_buffers._M_end_of_storage = this->_M_start_of_storage._M_data + __n;
    }





  } else {
    this->_M_throw_length_error();
  }
}


}
# 638 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_string.c"
template <class _CharT, class _Traits, class _Alloc>
basic_string<_CharT, _Traits, _Alloc>::basic_string(const _CharT* __s,
                                                    const allocator_type& __a)
  : ::std::priv:: _String_base<_CharT,_Alloc>(__a) {
 
  _M_range_initialize(__s, __s + traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Alloc>
basic_string<_CharT, _Traits, _Alloc>::basic_string(const basic_string<_CharT, _Traits, _Alloc> & __s)
  : ::std::priv:: _String_base<_CharT,_Alloc>(__s.get_allocator())
{ _M_range_initialize(__s._M_Start(), __s._M_Finish()); }







template <class _CharT, class _Traits, class _Alloc>
const size_t basic_string<_CharT, _Traits, _Alloc>::npos;


}
# 1174 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_string.h" 2
# 30 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/string" 2



# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_string_hash.h" 1
# 23 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_string_hash.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_hash_fun.h" 1
# 38 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_hash_fun.h"
namespace std {

template <class _Key> struct hash { };

namespace priv {

inline size_t __stl_hash_string(const char* __s) {
 
  unsigned long __h = 0;
  for ( ; *__s; ++__s)
    __h = 5*__h + *__s;

  return size_t(__h);
}

}

template<>
struct hash<char*> {
  size_t operator()(const char* __s) const {
   
    return ::std::priv:: __stl_hash_string(__s);
  }
};

template<>
struct hash<const char*> {
  size_t operator()(const char* __s) const {
   
    return ::std::priv:: __stl_hash_string(__s);
  }
};

template<> struct hash<char> {
  size_t operator()(char __x) const { return __x; }
};
template<> struct hash<unsigned char> {
  size_t operator()(unsigned char __x) const { return __x; }
};

template<> struct hash<signed char> {
  size_t operator()(unsigned char __x) const { return __x; }
};

template<> struct hash<short> {
  size_t operator()(short __x) const { return __x; }
};
template<> struct hash<unsigned short> {
  size_t operator()(unsigned short __x) const { return __x; }
};
template<> struct hash<int> {
  size_t operator()(int __x) const { return __x; }
};


template<> struct hash<unsigned int> {
  size_t operator()(unsigned int __x) const { return __x; }
};
# 108 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_hash_fun.h"
template<> struct hash<long> {
  size_t operator()(long __x) const { return __x; }
};
template<> struct hash<unsigned long> {
  size_t operator()(unsigned long __x) const { return __x; }
};


template<> struct hash<long long> {
  size_t operator()(long long x) const { return (size_t)x; }
};
template<> struct hash<unsigned long long> {
  size_t operator()(unsigned long long x) const { return (size_t)x; }
};


template<>
struct hash<void *>
{
    union __vp {
        size_t s;
        void *p;
    };

    size_t operator()(void *__x) const
      {
        __vp vp;
        vp.p = __x;
        return vp.s;
      }
};

}
# 24 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_string_hash.h" 2






namespace std {

template <class _CharT, class _Traits, class _Alloc>
inline size_t
__stl_string_hash(const basic_string<_CharT,_Traits,_Alloc>& __s) {
  unsigned long __h = 0;
  size_t __len = __s.size();
  const _CharT* __data = __s.data();
  for ( size_t __i = 0; __i < __len; ++__i)
    __h = (__h << 2) + __h + __data[__i];
  return size_t(__h);
}



template <class _CharT, class _Traits, class _Alloc>
struct hash<basic_string<_CharT,_Traits,_Alloc> > {
  size_t operator()(const basic_string<_CharT,_Traits,_Alloc>& __s) const
    { return __stl_string_hash(__s); }
};
# 69 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_string_hash.h"
}
# 34 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/string" 2



# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_string_io.h" 1
# 23 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_string_io.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_ostream.h" 1
# 24 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_ostream.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_ios.h" 1
# 23 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_ios.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_ios_base.h" 1
# 22 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_ios_base.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_stdexcept_base.h" 1
# 25 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_stdexcept_base.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_exception.h" 1
# 158 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_exception.h"
namespace std {


class __attribute__((visibility("default"))) exception {
public:

  exception() ;
  virtual ~exception() ;
  virtual const char* what() const ;





};


class __attribute__((visibility("default"))) bad_exception : public exception {
public:

  bad_exception() ;
  ~bad_exception() ;
  const char* what() const ;





};


class __Named_exception;
}
# 26 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_stdexcept_base.h" 2
# 40 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_stdexcept_base.h"
namespace std {
# 65 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_stdexcept_base.h"
class __attribute__((visibility("default"))) __Named_exception : public exception {
public:
  __Named_exception(const string& __str);
  __Named_exception(const __Named_exception&);
  __Named_exception& operator = (const __Named_exception&);

  const char* what() const ;
  ~__Named_exception() ;

private:
  enum { _S_bufsize = 256 };
  char _M_static_name[_S_bufsize];
  char *_M_name;
};
# 90 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_stdexcept_base.h"
}
# 23 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_ios_base.h" 2







# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_locale.h" 1
# 35 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_locale.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_threads.h" 1
# 82 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_threads.h"
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/pthread.h" 1
# 33 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/pthread.h"
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sched.h" 1
# 34 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sched.h"
extern "C" {






struct sched_param {
    int sched_priority;
};

extern int sched_setscheduler(pid_t, int, const struct sched_param *);
extern int sched_getscheduler(pid_t);
extern int sched_yield(void);
extern int sched_get_priority_max(int policy);
extern int sched_get_priority_min(int policy);
extern int sched_setparam(pid_t, const struct sched_param *);
extern int sched_getparam(pid_t, struct sched_param *);
extern int sched_rr_get_interval(pid_t pid, struct timespec *tp);

}
# 34 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/pthread.h" 2






typedef struct
{
    int volatile value;
} pthread_mutex_t;





enum {
    PTHREAD_MUTEX_NORMAL = 0,
    PTHREAD_MUTEX_RECURSIVE = 1,
    PTHREAD_MUTEX_ERRORCHECK = 2,

    PTHREAD_MUTEX_ERRORCHECK_NP = PTHREAD_MUTEX_ERRORCHECK,
    PTHREAD_MUTEX_RECURSIVE_NP = PTHREAD_MUTEX_RECURSIVE,

    PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL
};



typedef struct
{
    int volatile value;
} pthread_cond_t;

typedef struct
{
    uint32_t flags;
    void * stack_base;
    size_t stack_size;
    size_t guard_size;
    int32_t sched_policy;
    int32_t sched_priority;
} pthread_attr_t;

typedef long pthread_mutexattr_t;
typedef long pthread_condattr_t;

typedef int pthread_key_t;
typedef long pthread_t;

typedef volatile int pthread_once_t;
# 107 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/pthread.h"
extern "C" {


int pthread_attr_init(pthread_attr_t * attr);
int pthread_attr_destroy(pthread_attr_t * attr);

int pthread_attr_setdetachstate(pthread_attr_t * attr, int state);
int pthread_attr_getdetachstate(pthread_attr_t const * attr, int * state);

int pthread_attr_setschedpolicy(pthread_attr_t * attr, int policy);
int pthread_attr_getschedpolicy(pthread_attr_t const * attr, int * policy);

int pthread_attr_setschedparam(pthread_attr_t * attr, struct sched_param const * param);
int pthread_attr_getschedparam(pthread_attr_t const * attr, struct sched_param * param);

int pthread_attr_setstacksize(pthread_attr_t * attr, size_t stack_size);
int pthread_attr_getstacksize(pthread_attr_t const * attr, size_t * stack_size);

int pthread_attr_setstackaddr(pthread_attr_t * attr, void * stackaddr);
int pthread_attr_getstackaddr(pthread_attr_t const * attr, void ** stackaddr);

int pthread_attr_setstack(pthread_attr_t * attr, void * stackaddr, size_t stack_size);
int pthread_attr_getstack(pthread_attr_t const * attr, void ** stackaddr, size_t * stack_size);

int pthread_attr_setguardsize(pthread_attr_t * attr, size_t guard_size);
int pthread_attr_getguardsize(pthread_attr_t const * attr, size_t * guard_size);

int pthread_attr_setscope(pthread_attr_t *attr, int scope);
int pthread_attr_getscope(pthread_attr_t const *attr);

int pthread_getattr_np(pthread_t thid, pthread_attr_t * attr);

int pthread_create(pthread_t *thread, pthread_attr_t const * attr,
                   void *(*start_routine)(void *), void * arg);
void pthread_exit(void * retval);
int pthread_join(pthread_t thid, void ** ret_val);
int pthread_detach(pthread_t thid);

pthread_t pthread_self(void);
int pthread_equal(pthread_t one, pthread_t two);

int pthread_getschedparam(pthread_t thid, int * policy,
                          struct sched_param * param);
int pthread_setschedparam(pthread_t thid, int poilcy,
                          struct sched_param const * param);

int pthread_mutexattr_init(pthread_mutexattr_t *attr);
int pthread_mutexattr_destroy(pthread_mutexattr_t *attr);
int pthread_mutexattr_gettype(const pthread_mutexattr_t *attr, int *type);
int pthread_mutexattr_settype(pthread_mutexattr_t *attr, int type);
int pthread_mutexattr_setpshared(pthread_mutexattr_t *attr, int pshared);
int pthread_mutexattr_getpshared(pthread_mutexattr_t *attr, int *pshared);

int pthread_mutex_init(pthread_mutex_t *mutex,
                       const pthread_mutexattr_t *attr);
int pthread_mutex_destroy(pthread_mutex_t *mutex);
int pthread_mutex_lock(pthread_mutex_t *mutex);
int pthread_mutex_unlock(pthread_mutex_t *mutex);
int pthread_mutex_trylock(pthread_mutex_t *mutex);
int pthread_mutex_timedlock(pthread_mutex_t *mutex, struct timespec* ts);

int pthread_cond_init(pthread_cond_t *cond,
                      const pthread_condattr_t *attr);
int pthread_cond_destroy(pthread_cond_t *cond);
int pthread_cond_broadcast(pthread_cond_t *cond);
int pthread_cond_signal(pthread_cond_t *cond);
int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);
int pthread_cond_timedwait(pthread_cond_t *cond,
                           pthread_mutex_t * mutex,
                           const struct timespec *abstime);





int pthread_cond_timedwait_monotonic(pthread_cond_t *cond,
                                     pthread_mutex_t *mutex,
                                     const struct timespec *abstime);

int pthread_cond_timeout_np(pthread_cond_t *cond,
                            pthread_mutex_t * mutex,
                            unsigned msecs);

int pthread_key_create(pthread_key_t *key, void (*destructor_function)(void *));
int pthread_key_delete (pthread_key_t);
int pthread_setspecific(pthread_key_t key, const void *value);
void *pthread_getspecific(pthread_key_t key);

int pthread_kill(pthread_t tid, int sig);
int pthread_sigmask(int how, const sigset_t *set, sigset_t *oset);

int pthread_getcpuclockid(pthread_t tid, clockid_t *clockid);

int pthread_once(pthread_once_t *once_control, void (*init_routine)(void));

typedef void (*__pthread_cleanup_func_t)(void*);

typedef struct __pthread_cleanup_t {
    struct __pthread_cleanup_t* __cleanup_prev;
    __pthread_cleanup_func_t __cleanup_routine;
    void* __cleanup_arg;
} __pthread_cleanup_t;

extern void __pthread_cleanup_push(__pthread_cleanup_t* c,
                                    __pthread_cleanup_func_t routine,
                                    void* arg);

extern void __pthread_cleanup_pop(__pthread_cleanup_t* c,
                                   int execute);
# 235 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/pthread.h"
}
# 83 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_threads.h" 2
# 127 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_threads.h"
typedef size_t __stl_atomic_t;
# 245 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_threads.h"
namespace std {




template <int __inst>
struct _STLP_mutex_spin {
  enum { __low_max = 30, __high_max = 1000 };

  static unsigned __max;
  static unsigned __last;
  static void _M_do_lock(volatile __stl_atomic_t* __lock);
  static void _S_nsec_sleep(int __log_nsec, unsigned int& __iteration);
};
# 275 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_threads.h"
struct __attribute__((visibility("default"))) _STLP_mutex_base {
# 338 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_threads.h"
  pthread_mutex_t _M_lock;
  inline void _M_initialize()
  { pthread_mutex_init(&_M_lock,0); }
  inline void _M_destroy()
  { pthread_mutex_destroy(&_M_lock); }
  inline void _M_acquire_lock() {



    pthread_mutex_lock(&_M_lock);
  }
  inline void _M_release_lock() { pthread_mutex_unlock(&_M_lock); }
# 403 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_threads.h"
};




class __attribute__((visibility("default"))) _STLP_mutex : public _STLP_mutex_base {
  public:
    inline _STLP_mutex () { _M_initialize(); }
    inline ~_STLP_mutex () { _M_destroy(); }
  private:
    _STLP_mutex(const _STLP_mutex&);
    void operator=(const _STLP_mutex&);
};







struct __attribute__((visibility("default"))) _STLP_auto_lock {
  _STLP_auto_lock(_STLP_mutex_base& __lock) : _M_lock(__lock)
  { _M_lock._M_acquire_lock(); }
  ~_STLP_auto_lock()
  { _M_lock._M_release_lock(); }

private:
  _STLP_mutex_base& _M_lock;
  void operator=(const _STLP_auto_lock&);
  _STLP_auto_lock(const _STLP_auto_lock&);
};







class __attribute__((visibility("default"))) _Refcount_Base {




  volatile __stl_atomic_t _M_ref_count;





  _STLP_mutex _M_mutex;


  public:

  _Refcount_Base(__stl_atomic_t __n) : _M_ref_count(__n) {}
# 469 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_threads.h"
  __stl_atomic_t _M_incr() {
    _STLP_auto_lock l(_M_mutex);
    return ++_M_ref_count;
  }
  __stl_atomic_t _M_decr() {
    _STLP_auto_lock l(_M_mutex);
    return --_M_ref_count;
  }





};
# 496 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_threads.h"
template <int __use_ptr_atomic_swap>
class _Atomic_swap_struct {
public:





  static _STLP_mutex_base _S_swap_lock;


  static __stl_atomic_t _S_swap(volatile __stl_atomic_t* __p, __stl_atomic_t __q) {




  _S_swap_lock._M_acquire_lock();
  __stl_atomic_t __result = *__p;
  *__p = __q;
  _S_swap_lock._M_release_lock();
  return __result;
# 526 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_threads.h"
  }

  static void* _S_swap_ptr(void* volatile* __p, void* __q) {
# 538 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_threads.h"
  _S_swap_lock._M_acquire_lock();
  void *__result = *__p;
  *__p = __q;
  _S_swap_lock._M_release_lock();
  return __result;
# 552 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_threads.h"
  }
};

template<>
class _Atomic_swap_struct<0> {
public:





  static _STLP_mutex_base _S_swap_lock;


  static __stl_atomic_t _S_swap(volatile __stl_atomic_t* __p, __stl_atomic_t __q) {
# 575 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_threads.h"
  _S_swap_lock._M_acquire_lock();
  __stl_atomic_t __result = *__p;
  *__p = __q;
  _S_swap_lock._M_release_lock();
  return __result;
# 589 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_threads.h"
  }

  static void* _S_swap_ptr(void* volatile* __p, void* __q) {
# 601 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_threads.h"
  _S_swap_lock._M_acquire_lock();
  void *__result = *__p;
  *__p = __q;
  _S_swap_lock._M_release_lock();
  return __result;
# 615 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_threads.h"
  }
};






inline __stl_atomic_t _Atomic_swap(volatile __stl_atomic_t * __p, __stl_atomic_t __q) {
  const int __use_ptr_atomic_swap = sizeof(__stl_atomic_t) == sizeof(void*);
  return _Atomic_swap_struct<__use_ptr_atomic_swap>::_S_swap(__p, __q);
}

inline void* _Atomic_swap_ptr(void* volatile* __p, void* __q) {
  const int __use_ptr_atomic_swap = sizeof(__stl_atomic_t) == sizeof(void*);
  return _Atomic_swap_struct<__use_ptr_atomic_swap>::_S_swap_ptr(__p, __q);
}
# 677 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_threads.h"
}


# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_threads.c" 1
# 39 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_threads.c"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_ctime.h" 1
# 32 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_ctime.h"
namespace std {
using ::size_t;
using ::clock_t;
using ::time_t;
using ::tm;

using ::clock;
using ::asctime;
using ::ctime;
using ::gmtime;


using ::difftime;

using ::mktime;
using ::localtime;
using ::strftime;
using ::time;

}
# 40 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_threads.c" 2







namespace std {


template<int __32bits>
_STLP_mutex_base
_Atomic_swap_struct<__32bits>::_S_swap_lock ;




template <int __inst>
unsigned _STLP_mutex_spin<__inst>::__max = _STLP_mutex_spin<__inst>::__low_max;

template <int __inst>
unsigned _STLP_mutex_spin<__inst>::__last = 0;
# 74 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_threads.c"
template <int __inst>
void
_STLP_mutex_spin<__inst>::_S_nsec_sleep(int __log_nsec, unsigned int& __iteration) {
# 108 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_threads.c"
  timespec __ts;

  __ts.tv_sec = 0;
  __ts.tv_nsec = 1 << __log_nsec;
  nanosleep(&__ts, 0);

}

template <int __inst>
void
_STLP_mutex_spin<__inst>::_M_do_lock(volatile __stl_atomic_t* __lock) {
# 157 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_threads.c"
}


}
# 681 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_threads.h" 2
# 36 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_locale.h" 2
# 44 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_locale.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_facets_fwd.h" 1






namespace std {




template <class _CharT, class _InputIter = istreambuf_iterator<_CharT, char_traits<_CharT> > >

class money_get;




template <class _CharT, class _OutputIter = ostreambuf_iterator<_CharT, char_traits<_CharT> > >

class money_put;




template <class _CharT, class _InputIter = istreambuf_iterator<_CharT, char_traits<_CharT> > >

class num_get;




template <class _CharT, class _OutputIter = ostreambuf_iterator<_CharT, char_traits<_CharT> > >

class num_put;




template <class _Ch, class _InIt = istreambuf_iterator<_Ch, char_traits<_Ch> > >

class time_get;




template <class _Ch, class _OutIt = ostreambuf_iterator<_Ch, char_traits<_Ch> > >

class time_put;

}
# 45 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_locale.h" 2

namespace std {

class _Locale_impl;
class locale;

template <class _CharT, class _Traits, class _Alloc>
bool __locale_do_operator_call(const locale& __loc,
                               const basic_string<_CharT, _Traits, _Alloc>& __x,
                               const basic_string<_CharT, _Traits, _Alloc>& __y);

__attribute__((visibility("default"))) _Locale_impl * _get_Locale_impl( _Locale_impl *locimpl );
__attribute__((visibility("default"))) _Locale_impl * _copy_Nameless_Locale_impl( _Locale_impl *locimpl );

namespace priv {

template <class _Facet>
bool _HasFacet(const locale& __loc, const _Facet* __facet) ;

template <class _Facet>
_Facet* _UseFacet(const locale& __loc, const _Facet* __facet);

template <class _Facet>
void _InsertFacet(locale& __loc, _Facet* __facet);

}






class __attribute__((visibility("default"))) locale {
public:

  class __attribute__((visibility("default"))) facet : protected _Refcount_Base {
  protected:




    explicit facet(size_t __init_count = 0) : _Refcount_Base( __init_count == 0 ? 0 : 1 ) {}
    virtual ~facet();
    friend class locale;
    friend class _Locale_impl;
    friend facet * _get_facet( facet * );
    friend void _release_facet( facet *& );

  private:
    facet(const facet& ) ;
    void operator=(const facet&);
  };




  class

  __attribute__((visibility("default"))) id {
  public:
    size_t _M_index;
    static size_t _S_max;
  };

  typedef int category;
  static const category none = 0x000;
  static const category collate = 0x010;
  static const category ctype = 0x020;
  static const category monetary = 0x040;
  static const category numeric = 0x100;
  static const category time = 0x200;
  static const category messages = 0x400;
  static const category all = collate | ctype | monetary | numeric | time | messages;


  locale() ;
  locale(const locale&) ;
  explicit locale(const char *);
  locale(const locale&, const char*, category);


  template <class _Facet>
  locale(const locale& __loc, _Facet* __f) {
    if ( __f != 0 ) {
      this->_M_impl = _get_Locale_impl( _copy_Nameless_Locale_impl( __loc._M_impl ) );
      ::std::priv:: _InsertFacet(*this, __f);
    } else {
      this->_M_impl = _get_Locale_impl( __loc._M_impl );
    }
  }


protected:

  locale(_Locale_impl*);

public:
  locale(const locale&, const locale&, category);
  const locale& operator=(const locale&) ;




   ~locale() ;

public:


  template <class _Facet>
  locale combine(const locale& __loc) const {
    _Facet *__facet = 0;
    if (!::std::priv:: _HasFacet(__loc, __facet))
      _M_throw_on_combine_error(__loc.name());

    return locale(*this, ::std::priv:: _UseFacet(__loc, __facet));
  }



  string name() const;

  bool operator==(const locale&) const;
  bool operator!=(const locale&) const;







  template <class _CharT, class _Traits, class _Alloc>
  bool operator()(const basic_string<_CharT, _Traits, _Alloc>& __x,
                  const basic_string<_CharT, _Traits, _Alloc>& __y) const
  { return __locale_do_operator_call(*this, __x, __y); }




  static locale global(const locale&);



  static const locale& classic();


  facet* _M_get_facet(const id&) const;

  facet* _M_use_facet(const id&) const;
  static void _M_throw_on_combine_error(const string& name);
  static void _M_throw_on_null_name();
  static void _M_throw_on_creation_failure(int __err_code,
                                                                            const char* name, const char* facet);


  void _M_insert(facet* __f, id& __id);


  friend class _Locale_impl;

protected:
  _Locale_impl* _M_impl;
  _Locale_impl* _M_get_impl() const { return _M_impl; }
};
# 287 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_locale.h"
template <class _Facet>
inline const _Facet&



use_facet(const locale& __loc)

{
  _Facet *__facet = 0;
  return *(::std::priv:: _UseFacet(__loc, __facet));
}

template <class _Facet>






inline bool has_facet(const locale& __loc)

{
  _Facet *__facet = 0;
  return ::std::priv:: _HasFacet(__loc, __facet);
}





namespace priv {







template <class _Facet>
inline locale::id& _GetFacetId(const _Facet*)
{ return _Facet::id; }

__attribute__((visibility("default"))) locale::id& _GetFacetId(const money_get<char, istreambuf_iterator<char, char_traits<char> > >*);
__attribute__((visibility("default"))) locale::id& _GetFacetId(const money_put<char, ostreambuf_iterator<char, char_traits<char> > >*);
__attribute__((visibility("default"))) locale::id& _GetFacetId(const num_get<char, istreambuf_iterator<char, char_traits<char> > >*);
__attribute__((visibility("default"))) locale::id& _GetFacetId(const num_put<char, ostreambuf_iterator<char, char_traits<char> > >*);
__attribute__((visibility("default"))) locale::id& _GetFacetId(const time_get<char, istreambuf_iterator<char, char_traits<char> > >*);
__attribute__((visibility("default"))) locale::id& _GetFacetId(const time_put<char, ostreambuf_iterator<char, char_traits<char> > >*);


__attribute__((visibility("default"))) locale::id& _GetFacetId(const money_get<wchar_t, istreambuf_iterator<wchar_t, char_traits<wchar_t> > >*);
__attribute__((visibility("default"))) locale::id& _GetFacetId(const money_put<wchar_t, ostreambuf_iterator<wchar_t, char_traits<wchar_t> > >*);
__attribute__((visibility("default"))) locale::id& _GetFacetId(const num_get<wchar_t, istreambuf_iterator<wchar_t, char_traits<wchar_t> > >*);
__attribute__((visibility("default"))) locale::id& _GetFacetId(const num_put<wchar_t, ostreambuf_iterator<wchar_t, char_traits<wchar_t> > >*);
__attribute__((visibility("default"))) locale::id& _GetFacetId(const time_get<wchar_t, istreambuf_iterator<wchar_t, char_traits<wchar_t> > >*);
__attribute__((visibility("default"))) locale::id& _GetFacetId(const time_put<wchar_t, ostreambuf_iterator<wchar_t, char_traits<wchar_t> > >*);


template <class _Facet>
inline bool _HasFacet(const locale& __loc, const _Facet* __facet)
{ return (__loc._M_get_facet(_GetFacetId(__facet)) != 0); }

template <class _Facet>
inline _Facet* _UseFacet(const locale& __loc, const _Facet* __facet)
{ return static_cast<_Facet*>(__loc._M_use_facet(_GetFacetId(__facet))); }

template <class _Facet>
inline void _InsertFacet(locale& __loc, _Facet* __facet)
{ __loc._M_insert(__facet, _GetFacetId(__facet)); }

}

}
# 31 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_ios_base.h" 2






namespace std {
# 48 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_ios_base.h"
class __attribute__((visibility("default"))) ios_base {
public:

  class __attribute__((visibility("default"))) failure : public __Named_exception {
  public:
    explicit failure(const string&);
    virtual ~failure() ;
  };

  typedef int fmtflags;
  typedef int iostate;
  typedef int openmode;
  typedef int seekdir;


  typedef fmtflags fmt_flags;



  static const int left = 0x0001;
  static const int right = 0x0002;
  static const int internal = 0x0004;
  static const int dec = 0x0008;
  static const int hex = 0x0010;
  static const int oct = 0x0020;
  static const int fixed = 0x0040;
  static const int scientific = 0x0080;
  static const int boolalpha = 0x0100;
  static const int showbase = 0x0200;
  static const int showpoint = 0x0400;
  static const int showpos = 0x0800;
  static const int skipws = 0x1000;
  static const int unitbuf = 0x2000;
  static const int uppercase = 0x4000;
  static const int adjustfield = left | right | internal;
  static const int basefield = dec | hex | oct;
  static const int floatfield = scientific | fixed;


  static const int goodbit = 0x00;
  static const int badbit = 0x01;
  static const int eofbit = 0x02;
  static const int failbit = 0x04;


  static const int __default_mode = 0x0;
  static const int app = 0x01;
  static const int ate = 0x02;
  static const int binary = 0x04;
  static const int in = 0x08;
  static const int out = 0x10;
  static const int trunc = 0x20;


  static const int beg = 0x01;
  static const int cur = 0x02;
  static const int end = 0x04;

public:
  fmtflags flags() const { return _M_fmtflags; }
  fmtflags flags(fmtflags __flags) {
    fmtflags __tmp = _M_fmtflags;
    _M_fmtflags = __flags;
    return __tmp;
  }

  fmtflags setf(fmtflags __flag) {
    fmtflags __tmp = _M_fmtflags;
    _M_fmtflags |= __flag;
    return __tmp;
  }
  fmtflags setf(fmtflags __flag, fmtflags __mask) {
    fmtflags __tmp = _M_fmtflags;
    _M_fmtflags &= ~__mask;
    _M_fmtflags |= __flag & __mask;
    return __tmp;
  }
  void unsetf(fmtflags __mask) { _M_fmtflags &= ~__mask; }

  streamsize precision() const { return _M_precision; }
  streamsize precision(streamsize __newprecision) {
    streamsize __tmp = _M_precision;
    _M_precision = __newprecision;
    return __tmp;
  }

  streamsize width() const { return _M_width; }
  streamsize width(streamsize __newwidth) {
    streamsize __tmp = _M_width;
    _M_width = __newwidth;
    return __tmp;
  }

public:
  locale imbue(const locale&);
  locale getloc() const { return _M_locale; }

public:
  static int xalloc();
  long& iword(int __index);
  void*& pword(int __index);

public:
  virtual ~ios_base();

public:
  enum event { erase_event, imbue_event, copyfmt_event };
  typedef void (*event_callback)(event, ios_base&, int __index);
  void register_callback(event_callback __fn, int __index);

public:


  static bool sync_with_stdio(bool __sync = true);

public:



  operator void*() const { return !fail() ? (void*) const_cast<ios_base*>(this) : (void*) 0; }
  bool operator!() const { return fail(); }

  iostate rdstate() const { return _M_iostate; }

  bool good() const { return _M_iostate == 0; }
  bool eof() const { return (_M_iostate & eofbit) != 0; }
  bool fail() const { return (_M_iostate & (failbit | badbit)) != 0; }
  bool bad() const { return (_M_iostate & badbit) != 0; }

protected:





  void _M_copy_state(const ios_base& __x);

  void _M_setstate_nothrow(iostate __state) { _M_iostate |= __state; }
  void _M_clear_nothrow(iostate __state) { _M_iostate = __state; }
  iostate _M_get_exception_mask() const { return _M_exception_mask; }
  void _M_set_exception_mask(iostate __mask) { _M_exception_mask = __mask; }
  void _M_check_exception_mask() {
    if (_M_iostate & _M_exception_mask)
      _M_throw_failure();
  }

  void _M_invoke_callbacks(event);
  void _M_throw_failure();

  ios_base();

protected:
  static void _S_initialize();
  static void _S_uninitialize();
  static bool _S_is_synced;

private:

  ios_base(const ios_base&);
  void operator=(const ios_base&);

private:

  fmtflags _M_fmtflags;
  iostate _M_iostate;
  openmode _M_openmode;
  seekdir _M_seekdir;
  iostate _M_exception_mask;

  streamsize _M_precision;
  streamsize _M_width;

  locale _M_locale;

  pair<event_callback, int>* _M_callbacks;
  size_t _M_num_callbacks;
  size_t _M_callback_index;


  long* _M_iwords;
  size_t _M_num_iwords;

  void** _M_pwords;
  size_t _M_num_pwords;

public:





  class __attribute__((visibility("default"))) Init
  {
    public:
      Init();
      ~Init();
    private:
      static long _S_count;
      friend class ios_base;
  };

  friend class Init;

public:


  typedef iostate io_state;
  typedef openmode open_mode;
  typedef seekdir seek_dir;
  typedef ::std::streamoff streamoff;
  typedef ::std::streampos streampos;

};






inline ios_base& boolalpha(ios_base& __s)
  { __s.setf(ios_base::boolalpha); return __s;}

inline ios_base& noboolalpha(ios_base& __s)
  { __s.unsetf(ios_base::boolalpha); return __s;}

inline ios_base& showbase(ios_base& __s)
  { __s.setf(ios_base::showbase); return __s;}

inline ios_base& noshowbase(ios_base& __s)
  { __s.unsetf(ios_base::showbase); return __s;}

inline ios_base& showpoint(ios_base& __s)
  { __s.setf(ios_base::showpoint); return __s;}

inline ios_base& noshowpoint(ios_base& __s)
  { __s.unsetf(ios_base::showpoint); return __s;}

inline ios_base& showpos(ios_base& __s)
  { __s.setf(ios_base::showpos); return __s;}

inline ios_base& noshowpos(ios_base& __s)
  { __s.unsetf(ios_base::showpos); return __s;}

inline ios_base& skipws(ios_base& __s)
  { __s.setf(ios_base::skipws); return __s;}

inline ios_base& noskipws(ios_base& __s)
  { __s.unsetf(ios_base::skipws); return __s;}

inline ios_base& uppercase(ios_base& __s)
  { __s.setf(ios_base::uppercase); return __s;}

inline ios_base& nouppercase(ios_base& __s)
  { __s.unsetf(ios_base::uppercase); return __s;}

inline ios_base& unitbuf(ios_base& __s)
  { __s.setf(ios_base::unitbuf); return __s;}

inline ios_base& nounitbuf(ios_base& __s)
  { __s.unsetf(ios_base::unitbuf); return __s;}



inline ios_base& internal(ios_base& __s)
  { __s.setf(ios_base::internal, ios_base::adjustfield); return __s; }

inline ios_base& left(ios_base& __s)
  { __s.setf(ios_base::left, ios_base::adjustfield); return __s; }

inline ios_base& right(ios_base& __s)
  { __s.setf(ios_base::right, ios_base::adjustfield); return __s; }


inline ios_base& dec(ios_base& __s)
  { __s.setf(ios_base::dec, ios_base::basefield); return __s; }

inline ios_base& hex(ios_base& __s)
  { __s.setf(ios_base::hex, ios_base::basefield); return __s; }

inline ios_base& oct(ios_base& __s)
  { __s.setf(ios_base::oct, ios_base::basefield); return __s; }



inline ios_base& fixed(ios_base& __s)
  { __s.setf(ios_base::fixed, ios_base::floatfield); return __s; }

inline ios_base& scientific(ios_base& __s)
  { __s.setf(ios_base::scientific, ios_base::floatfield); return __s; }

}
# 24 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_ios.h" 2



# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_ctype.h" 1
# 26 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_ctype.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/c_locale.h" 1
# 88 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/c_locale.h"
struct _Locale_ctype;
struct _Locale_codecvt;
struct _Locale_numeric;
struct _Locale_time;
struct _Locale_collate;
struct _Locale_monetary;
struct _Locale_messages;
# 27 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_ctype.h" 2
# 37 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_ctype.h"
namespace std {

class __attribute__((visibility("default"))) ctype_base {
public:
  enum mask {
    space = 0x0001,
    print = 0x0002,
    cntrl = 0x0004,
    upper = 0x0008,
    lower = 0x0010,
    alpha = 0x0020,
    digit = 0x0040,
    punct = 0x0080,
    xdigit = 0x0100,
    alnum = alpha | digit,
    graph = alnum | punct
  };
};



template <class charT> class ctype {};
template <class charT> class ctype_byname {};



template<>
class __attribute__((visibility("default"))) ctype<char> : public locale::facet, public ctype_base {





    friend class ctype<wchar_t>;


public:

  typedef char char_type;

  explicit ctype(const mask* __tab = 0, bool __del = false, size_t __refs = 0);
  bool is(mask __m, char __c) const
  { return ((*(_M_ctype_table+(unsigned char)__c)) & __m) != 0; }

  const char* is(const char* __low, const char* __high, mask* __vec) const {
    for (const char* __p = __low;__p != __high; ++__p, ++__vec) {
      *__vec = _M_ctype_table[(unsigned char)*__p];
    }
    return __high;
  }

  const char* scan_is(mask __m, const char* __low, const char* __high) const;
  const char* scan_not(mask __m, const char* __low, const char* __high) const;

  char (toupper)(char __c) const { return do_toupper(__c); }
  const char* (toupper)(char* __low, const char* __high) const {
    return do_toupper(__low, __high);
  }

  char (tolower)(char __c) const { return do_tolower(__c); }
  const char* (tolower)(char* __low, const char* __high) const {
    return do_tolower(__low, __high);
  }

  char widen(char __c) const { return do_widen(__c); }
  const char* widen(const char* __low, const char* __high, char* __to) const {
    return do_widen(__low, __high, __to);
  }

  char narrow(char __c, char __dfault) const {
    return do_narrow(__c, __dfault);
  }
  const char* narrow(const char* __low, const char* __high,
                     char __dfault, char* __to) const {
    return do_narrow(__low, __high, __dfault, __to);
  }

  static locale::id id;
  static const size_t table_size = 256;

protected:
  const mask* table() const { return _M_ctype_table; }
  static const mask* classic_table() ;

  ~ctype();

  virtual char do_toupper(char __c) const;
  virtual char do_tolower(char __c) const;
  virtual const char* do_toupper(char* __low, const char* __high) const;
  virtual const char* do_tolower(char* __low, const char* __high) const;
  virtual char do_widen(char __c) const;
  virtual const char* do_widen(const char* __low, const char* __high,
                               char* __to) const;
  virtual char do_narrow(char __c, char ) const;
  virtual const char* do_narrow(const char* __low, const char* __high,
                                char , char* __to) const;
private:
  struct _Is_mask {
    mask __m;
    _Is_mask(mask __x): __m(__x) {}
   bool operator()(char __c) {return (__m & (unsigned char) __c) != 0;}
  };

protected:
  const mask* _M_ctype_table;
private:
  bool _M_delete;
};

template<>
class __attribute__((visibility("default"))) ctype_byname<char>: public ctype<char> {
  friend class _Locale_impl;
public:
  explicit ctype_byname(const char*, size_t = 0);
  ~ctype_byname();

  virtual char do_toupper(char __c) const;
  virtual char do_tolower(char __c) const;

  virtual const char* do_toupper(char*, const char*) const;
  virtual const char* do_tolower(char*, const char*) const;

private:
  ctype_byname(_Locale_ctype* __ctype)
    : _M_ctype(__ctype)
  { _M_init(); }

  void _M_init();


  typedef ctype_byname<char> _Self;
  ctype_byname(_Self const&);
  _Self& operator = (_Self const&);

  mask _M_byname_table[table_size];
  _Locale_ctype* _M_ctype;
};


template<>
class __attribute__((visibility("default"))) ctype<wchar_t> : public locale::facet, public ctype_base {
public:
  typedef wchar_t char_type;

  explicit ctype(size_t __refs = 0) : locale::facet(__refs) {}

  bool is(mask __m, wchar_t __c) const
    { return do_is(__m, __c); }

  const wchar_t* is(const wchar_t* __low, const wchar_t* __high,
                    mask* __vec) const
    { return do_is(__low, __high, __vec); }

  const wchar_t* scan_is(mask __m,
                         const wchar_t* __low, const wchar_t* __high) const
    { return do_scan_is(__m, __low, __high); }

  const wchar_t* scan_not (mask __m,
                           const wchar_t* __low, const wchar_t* __high) const
    { return do_scan_not(__m, __low, __high); }

  wchar_t (toupper)(wchar_t __c) const { return do_toupper(__c); }
  const wchar_t* (toupper)(wchar_t* __low, const wchar_t* __high) const
    { return do_toupper(__low, __high); }

  wchar_t (tolower)(wchar_t __c) const { return do_tolower(__c); }
  const wchar_t* (tolower)(wchar_t* __low, const wchar_t* __high) const
    { return do_tolower(__low, __high); }

  wchar_t widen(char __c) const { return do_widen(__c); }
  const char* widen(const char* __low, const char* __high,
                    wchar_t* __to) const
    { return do_widen(__low, __high, __to); }

  char narrow(wchar_t __c, char __dfault) const
    { return do_narrow(__c, __dfault); }
  const wchar_t* narrow(const wchar_t* __low, const wchar_t* __high,
                        char __dfault, char* __to) const
    { return do_narrow(__low, __high, __dfault, __to); }

  static locale::id id;

protected:
  ~ctype();

  virtual bool do_is(mask __m, wchar_t __c) const;
  virtual const wchar_t* do_is(const wchar_t*, const wchar_t*, mask*) const;
  virtual const wchar_t* do_scan_is(mask,
                                    const wchar_t*, const wchar_t*) const;
  virtual const wchar_t* do_scan_not(mask,
                                     const wchar_t*, const wchar_t*) const;
  virtual wchar_t do_toupper(wchar_t __c) const;
  virtual const wchar_t* do_toupper(wchar_t*, const wchar_t*) const;
  virtual wchar_t do_tolower(wchar_t c) const;
  virtual const wchar_t* do_tolower(wchar_t*, const wchar_t*) const;
  virtual wchar_t do_widen(char c) const;
  virtual const char* do_widen(const char*, const char*, wchar_t*) const;
  virtual char do_narrow(wchar_t __c, char __dfault) const;
  virtual const wchar_t* do_narrow(const wchar_t*, const wchar_t*,
                                   char, char*) const;
};

template<>
class __attribute__((visibility("default"))) ctype_byname<wchar_t>: public ctype<wchar_t> {
  friend class _Locale_impl;
public:
  explicit ctype_byname(const char* __name, size_t __refs = 0);

protected:
  ~ctype_byname();

  virtual bool do_is(mask __m, wchar_t __c) const;
  virtual const wchar_t* do_is(const wchar_t*, const wchar_t*, mask*) const;
  virtual const wchar_t* do_scan_is(mask,
                                    const wchar_t*, const wchar_t*) const;
  virtual const wchar_t* do_scan_not(mask,
                                     const wchar_t*, const wchar_t*) const;
  virtual wchar_t do_toupper(wchar_t __c) const;
  virtual const wchar_t* do_toupper(wchar_t*, const wchar_t*) const;
  virtual wchar_t do_tolower(wchar_t c) const;
  virtual const wchar_t* do_tolower(wchar_t*, const wchar_t*) const;

private:
  ctype_byname(_Locale_ctype* __ctype)
    : _M_ctype(__ctype) {}


  typedef ctype_byname<wchar_t> _Self;
  ctype_byname(_Self const&);
  _Self& operator = (_Self const&);

  _Locale_ctype* _M_ctype;
};



}
# 28 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_ios.h" 2



# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_numpunct.h" 1
# 38 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_numpunct.h"
namespace std {




template <class _CharT> class numpunct {};
template <class _CharT> class numpunct_byname {};
template <class _Ch, class _InIt> class num_get;

template<>
class __attribute__((visibility("default"))) numpunct<char> : public locale::facet {
public:
  typedef char char_type;
  typedef string string_type;

  explicit numpunct(size_t __refs = 0)
    : locale::facet(__refs) {}

  char decimal_point() const { return do_decimal_point(); }
  char thousands_sep() const { return do_thousands_sep(); }
  string grouping() const { return do_grouping(); }
  string truename() const { return do_truename(); }
  string falsename() const { return do_falsename(); }

  static locale::id id;

protected:
  ~numpunct();

  virtual char do_decimal_point() const;
  virtual char do_thousands_sep() const;
  virtual string do_grouping() const;
  virtual string do_truename() const;
  virtual string do_falsename() const;
};



template<>
class __attribute__((visibility("default"))) numpunct<wchar_t> : public locale::facet {
public:
  typedef wchar_t char_type;
  typedef wstring string_type;

  explicit numpunct(size_t __refs = 0)
    : locale::facet(__refs) {}

  wchar_t decimal_point() const { return do_decimal_point(); }
  wchar_t thousands_sep() const { return do_thousands_sep(); }
  string grouping() const { return do_grouping(); }
  wstring truename() const { return do_truename(); }
  wstring falsename() const { return do_falsename(); }

  static locale::id id;

protected:
  ~numpunct();

  virtual wchar_t do_decimal_point() const;
  virtual wchar_t do_thousands_sep() const;
  virtual string do_grouping() const;
  virtual wstring do_truename() const;
  virtual wstring do_falsename() const;
};



template<>
class __attribute__((visibility("default"))) numpunct_byname<char> : public numpunct<char> {
  friend class _Locale_impl;
public:
  typedef char char_type;
  typedef string string_type;

  explicit numpunct_byname(const char* __name, size_t __refs = 0);

protected:

  ~numpunct_byname();

  virtual char do_decimal_point() const;
  virtual char do_thousands_sep() const;
  virtual string do_grouping() const;
  virtual string do_truename() const;
  virtual string do_falsename() const;

private:
  numpunct_byname(_Locale_numeric *__numeric)
    : _M_numeric(__numeric) {}


  typedef numpunct_byname<char> _Self;
  numpunct_byname(_Self const&);
  _Self& operator = (_Self const&);

  _Locale_numeric* _M_numeric;
};


template<>
class __attribute__((visibility("default"))) numpunct_byname<wchar_t>: public numpunct<wchar_t> {
  friend class _Locale_impl;
public:
  typedef wchar_t char_type;
  typedef wstring string_type;

  explicit numpunct_byname(const char* __name, size_t __refs = 0);

protected:
  ~numpunct_byname();

  virtual wchar_t do_decimal_point() const;
  virtual wchar_t do_thousands_sep() const;
  virtual string do_grouping() const;
  virtual wstring do_truename() const;
  virtual wstring do_falsename() const;

private:
  numpunct_byname(_Locale_numeric *__numeric)
    : _M_numeric(__numeric) {}


  typedef numpunct_byname<wchar_t> _Self;
  numpunct_byname(_Self const&);
  _Self& operator = (_Self const&);

  _Locale_numeric* _M_numeric;
};



}
# 32 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_ios.h" 2


namespace std {
# 47 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_ios.h"
template <class _CharT, class _Traits>
class basic_ios : public ios_base {
  friend class ios_base;
public:
  typedef _CharT char_type;
  typedef typename _Traits::int_type int_type;
  typedef typename _Traits::pos_type pos_type;
  typedef typename _Traits::off_type off_type;
  typedef _Traits traits_type;

public:
  explicit basic_ios(basic_streambuf<_CharT, _Traits>* __streambuf);
  virtual ~basic_ios() {}

public:
  basic_ostream<_CharT, _Traits>* tie() const {
    return _M_tied_ostream;
  }
  basic_ostream<_CharT, _Traits>*
  tie(basic_ostream<char_type, traits_type>* __new_tied_ostream) {
    basic_ostream<char_type, traits_type>* __tmp = _M_tied_ostream;
    _M_tied_ostream = __new_tied_ostream;
    return __tmp;
  }

  basic_streambuf<_CharT, _Traits>* rdbuf() const
    { return _M_streambuf; }

  basic_streambuf<_CharT, _Traits>*
  rdbuf(basic_streambuf<char_type, traits_type>*);


  basic_ios<_CharT, _Traits>& copyfmt(const basic_ios<_CharT, _Traits>& __x);

  char_type fill() const { return _M_fill; }
  char_type fill(char_type __fill) {
    char_type __tmp(_M_fill);
    _M_fill = __fill;
    return __tmp;
  }

public:


  void clear(iostate __state = goodbit) {
    _M_clear_nothrow(this->rdbuf() ? __state : iostate(__state|ios_base::badbit));
    _M_check_exception_mask();
  }
  void setstate(iostate __state) { this->clear(rdstate() | __state); }

  iostate exceptions() const { return this->_M_get_exception_mask(); }
  void exceptions(iostate __mask) {
    this->_M_set_exception_mask(__mask);
    this->clear(this->rdstate());
  }

public:
  locale imbue(const locale&);

  inline char narrow(_CharT, char) const ;
  inline _CharT widen(char) const;


  static bool _S_eof(int_type __c) {
    const int_type __eof = _Traits::eof();
    return _Traits::eq_int_type(__c, __eof);
  }

protected:

  const ctype<char_type>* _M_cached_ctype;

public:

  const ctype<char_type>* _M_ctype_facet() const { return _M_cached_ctype; }

protected:
  basic_ios();

  void init(basic_streambuf<_CharT, _Traits>* __streambuf);

public:



  void _M_handle_exception(ios_base::iostate __flag);

private:
  char_type _M_fill;

  basic_streambuf<_CharT, _Traits>* _M_streambuf;
  basic_ostream<_CharT, _Traits>* _M_tied_ostream;

};


template <class _CharT, class _Traits>
inline char
basic_ios<_CharT, _Traits>::narrow(_CharT __c, char __default) const
{ return _M_ctype_facet()->narrow(__c, __default); }

template <class _CharT, class _Traits>
inline _CharT
basic_ios<_CharT, _Traits>::widen(char __c) const
{ return _M_ctype_facet()->widen(__c); }


template<>
inline char
basic_ios<char, char_traits<char> >::narrow(char __c, char) const
{
  return __c;
}

template<>
inline char
basic_ios<char, char_traits<char> >::widen(char __c) const
{
  return __c;
}
# 176 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_ios.h"
}


# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_ios.c" 1
# 26 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_ios.c"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_streambuf.h" 1
# 25 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_streambuf.h"
namespace std {
# 47 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_streambuf.h"
template <class _CharT, class _Traits>
class basic_streambuf {
  friend class basic_istream<_CharT, _Traits>;
  friend class basic_ostream<_CharT, _Traits>;

public:
  typedef _CharT char_type;
  typedef typename _Traits::int_type int_type;
  typedef typename _Traits::pos_type pos_type;
  typedef typename _Traits::off_type off_type;
  typedef _Traits traits_type;

private:

  char_type* _M_gbegin;
  char_type* _M_gnext;
  char_type* _M_gend;

  char_type* _M_pbegin;
  char_type* _M_pnext;
  char_type* _M_pend;

  locale _M_locale;

public:
  virtual ~basic_streambuf();

protected:
  basic_streambuf()







  ;


protected:
  char_type* eback() const { return _M_gbegin; }
  char_type* gptr() const { return _M_gnext; }
  char_type* egptr() const { return _M_gend; }

  void gbump(int __n) { _M_gnext += __n; }
  void setg(char_type* __gbegin, char_type* __gnext, char_type* __gend) {
    _M_gbegin = __gbegin;
    _M_gnext = __gnext;
    _M_gend = __gend;
  }

public:



  char_type* _M_eback() const { return eback(); }
  char_type* _M_gptr() const { return gptr(); }
  char_type* _M_egptr() const { return egptr(); }
  void _M_gbump(int __n) { gbump(__n); }
  void _M_setg(char_type* __gbegin, char_type* __gnext, char_type* __gend)
  { this->setg(__gbegin, __gnext, __gend); }

protected:

  char_type* pbase() const { return _M_pbegin; }
  char_type* pptr() const { return _M_pnext; }
  char_type* epptr() const { return _M_pend; }

  void pbump(int __n) { _M_pnext += __n; }
  void setp(char_type* __pbegin, char_type* __pend) {
    _M_pbegin = __pbegin;
    _M_pnext = __pbegin;
    _M_pend = __pend;
  }

protected:

  virtual basic_streambuf<_CharT, _Traits>* setbuf(char_type*, streamsize);



  virtual pos_type seekoff(off_type, ios_base::seekdir,
                           ios_base::openmode = ios_base::in | ios_base::out);



  virtual pos_type
  seekpos(pos_type, ios_base::openmode = ios_base::in | ios_base::out);



  virtual int sync();


public:
  basic_streambuf<_CharT, _Traits>* pubsetbuf(char_type* __s, streamsize __n)
  { return this->setbuf(__s, __n); }

  pos_type pubseekoff(off_type __offset, ios_base::seekdir __way,
                      ios_base::openmode __mod = ios_base::in | ios_base::out)
  { return this->seekoff(__offset, __way, __mod); }

  pos_type pubseekpos(pos_type __sp,
                      ios_base::openmode __mod = ios_base::in | ios_base::out)
  { return this->seekpos(__sp, __mod); }

  int pubsync() { return this->sync(); }

protected:





  virtual streamsize showmanyc();



  virtual streamsize xsgetn(char_type* __s, streamsize __n);




  virtual int_type underflow();



  virtual int_type uflow();




  virtual int_type pbackfail(int_type = traits_type::eof());

protected:




  virtual streamsize xsputn(const char_type* __s, streamsize __n);



  virtual streamsize _M_xsputnc(char_type __c, streamsize __n);



  virtual int_type overflow(int_type = traits_type::eof());

public:

  int_type sputc(char_type __c) {
    return ((_M_pnext < _M_pend) ? _Traits::to_int_type(*_M_pnext++ = __c)
      : this->overflow(_Traits::to_int_type(__c)));
  }


  streamsize sputn(const char_type* __s, streamsize __n)
  { return this->xsputn(__s, __n); }


  streamsize _M_sputnc(char_type __c, streamsize __n)
  { return this->_M_xsputnc(__c, __n); }

private:
  int_type _M_snextc_aux();

public:
  streamsize in_avail() {
    return (_M_gnext < _M_gend) ? (_M_gend - _M_gnext) : this->showmanyc();
  }


  int_type snextc() {
  return ( _M_gend - _M_gnext > 1 ?
             _Traits::to_int_type(*++_M_gnext) :
             this->_M_snextc_aux());
  }


  int_type sbumpc() {
    return _M_gnext < _M_gend ? _Traits::to_int_type(*_M_gnext++)
      : this->uflow();
  }


  int_type sgetc() {
    return _M_gnext < _M_gend ? _Traits::to_int_type(*_M_gnext)
      : this->underflow();
  }

  streamsize sgetn(char_type* __s, streamsize __n)
  { return this->xsgetn(__s, __n); }

  int_type sputbackc(char_type __c) {
    return ((_M_gbegin < _M_gnext) && _Traits::eq(__c, *(_M_gnext - 1)))
      ? _Traits::to_int_type(*--_M_gnext)
      : this->pbackfail(_Traits::to_int_type(__c));
  }

  int_type sungetc() {
    return (_M_gbegin < _M_gnext)
      ? _Traits::to_int_type(*--_M_gnext)
      : this->pbackfail();
  }

protected:





  virtual void imbue(const locale&);

public:
  locale pubimbue(const locale&);
  locale getloc() const { return _M_locale; }


  void stossc() { this->sbumpc(); }

};
# 277 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_streambuf.h"
}


# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_streambuf.c" 1
# 25 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_streambuf.c"
namespace std {




template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>::basic_streambuf()
  : _M_gbegin(0), _M_gnext(0), _M_gend(0),
    _M_pbegin(0), _M_pnext(0), _M_pend(0),
    _M_locale() {

}


template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>::~basic_streambuf()
{}

template <class _CharT, class _Traits>
locale
basic_streambuf<_CharT, _Traits>::pubimbue(const locale& __loc) {
  this->imbue(__loc);
  locale __tmp = _M_locale;
  _M_locale = __loc;
  return __tmp;
}

template <class _CharT, class _Traits>
streamsize
basic_streambuf<_CharT, _Traits>::xsgetn(_CharT* __s, streamsize __n) {
  streamsize __result = 0;
  const int_type __eof = _Traits::eof();

  while (__result < __n) {
    if (_M_gnext < _M_gend) {
      size_t __chunk = (min) (static_cast<size_t>(_M_gend - _M_gnext),
                              static_cast<size_t>(__n - __result));
      _Traits::copy(__s, _M_gnext, __chunk);
      __result += __chunk;
      __s += __chunk;
      _M_gnext += __chunk;
    }
    else {
      int_type __c = this->sbumpc();
      if (!_Traits::eq_int_type(__c, __eof)) {
        *__s = _Traits::to_char_type(__c);
        ++__result;
        ++__s;
      }
      else
        break;
    }
  }

  return __result;
}

template <class _CharT, class _Traits>
streamsize
basic_streambuf<_CharT, _Traits>::xsputn(const _CharT* __s, streamsize __n)
{
  streamsize __result = 0;
  const int_type __eof = _Traits::eof();

  while (__result < __n) {
    if (_M_pnext < _M_pend) {
      size_t __chunk = (min) (static_cast<size_t>(_M_pend - _M_pnext),
                           static_cast<size_t>(__n - __result));
      _Traits::copy(_M_pnext, __s, __chunk);
      __result += __chunk;
      __s += __chunk;
      _M_pnext += __chunk;
    }

    else if (!_Traits::eq_int_type(this->overflow(_Traits::to_int_type(*__s)),
                                   __eof)) {
      ++__result;
      ++__s;
    }
    else
      break;
  }
  return __result;
}

template <class _CharT, class _Traits>
streamsize
basic_streambuf<_CharT, _Traits>::_M_xsputnc(_CharT __c, streamsize __n)
{
  streamsize __result = 0;
  const int_type __eof = _Traits::eof();

  while (__result < __n) {
    if (_M_pnext < _M_pend) {
      size_t __chunk = (min) (static_cast<size_t>(_M_pend - _M_pnext),
                           static_cast<size_t>(__n - __result));
      _Traits::assign(_M_pnext, __chunk, __c);
      __result += __chunk;
      _M_pnext += __chunk;
    }

    else if (!_Traits::eq_int_type(this->overflow(_Traits::to_int_type(__c)),
                                   __eof))
      ++__result;
    else
      break;
  }
  return __result;
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::_M_snextc_aux()
{
  int_type __eof = _Traits::eof();
  if (_M_gend == _M_gnext)
    return _Traits::eq_int_type(this->uflow(), __eof) ? __eof : this->sgetc();
  else {
    _M_gnext = _M_gend;
    return this->underflow();
  }
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::pbackfail(int_type) {
 return _Traits::eof();
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::overflow(int_type) {
  return _Traits::eof();
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::uflow() {
    return ( _Traits::eq_int_type(this->underflow(),_Traits::eof()) ?
             _Traits::eof() :
             _Traits::to_int_type(*_M_gnext++));
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::underflow()
{ return _Traits::eof(); }

template <class _CharT, class _Traits>
streamsize
basic_streambuf<_CharT, _Traits>::showmanyc()
{ return 0; }

template <class _CharT, class _Traits>
void
basic_streambuf<_CharT, _Traits>::imbue(const locale&) {}

template <class _CharT, class _Traits>
int
basic_streambuf<_CharT, _Traits>::sync() { return 0; }

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::pos_type
basic_streambuf<_CharT, _Traits>::seekpos(pos_type, ios_base::openmode)
{ return pos_type(-1); }

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::pos_type
basic_streambuf<_CharT, _Traits>::seekoff(off_type, ios_base::seekdir,
                                          ios_base::openmode)
{ return pos_type(-1); }

template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>*
basic_streambuf<_CharT, _Traits>:: setbuf(char_type*, streamsize)
{ return this; }

}
# 281 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_streambuf.h" 2
# 27 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_ios.c" 2






namespace std {




template <class _CharT, class _Traits>
basic_ios<_CharT, _Traits>
  ::basic_ios(basic_streambuf<_CharT, _Traits>* __streambuf)
    : ios_base(), _M_cached_ctype(0),
      _M_fill(_CharT()), _M_streambuf(0), _M_tied_ostream(0) {
  basic_ios<_CharT, _Traits>::init(__streambuf);
}

template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>*
basic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<_CharT, _Traits>* __buf) {
  basic_streambuf<_CharT, _Traits>* __tmp = _M_streambuf;
  _M_streambuf = __buf;
  this->clear();
  return __tmp;
}

template <class _CharT, class _Traits>
basic_ios<_CharT, _Traits>&
basic_ios<_CharT, _Traits>::copyfmt(const basic_ios<_CharT, _Traits>& __x) {
  _M_invoke_callbacks(erase_event);
  _M_copy_state(__x);
  _M_cached_ctype = __x._M_cached_ctype;
  _M_fill = __x._M_fill;
  _M_tied_ostream = __x._M_tied_ostream;
  _M_invoke_callbacks(copyfmt_event);
  this->_M_set_exception_mask(__x.exceptions());
  return *this;
}

template <class _CharT, class _Traits>
locale basic_ios<_CharT, _Traits>::imbue(const locale& __loc) {
  locale __tmp = ios_base::imbue(__loc);
  {
    if (_M_streambuf)
      _M_streambuf->pubimbue(__loc);


    _M_cached_ctype = &use_facet<ctype<char_type> >(__loc);
  }
  if (false) {
    __tmp = ios_base::imbue(__tmp);
    _M_handle_exception(ios_base::failbit);
  }
  return __tmp;
}





template <class _CharT, class _Traits>
basic_ios<_CharT, _Traits>::basic_ios()
  : ios_base(),
    _M_fill(_CharT()), _M_streambuf(0), _M_tied_ostream(0)
{}

template <class _CharT, class _Traits>
void
basic_ios<_CharT, _Traits>::init(basic_streambuf<_CharT, _Traits>* __sb)
{
  this->rdbuf(__sb);
  this->imbue(locale());
  this->tie(0);
  this->_M_set_exception_mask(ios_base::goodbit);
  this->_M_clear_nothrow(__sb != 0 ? ios_base::goodbit : ios_base::badbit);
  ios_base::flags(ios_base::skipws | ios_base::dec);
  ios_base::width(0);
  ios_base::precision(6);
  this->fill(widen(' '));


}


template <class _CharT, class _Traits>
void basic_ios<_CharT, _Traits>::_M_handle_exception(ios_base::iostate __flag)
{
  this->_M_setstate_nothrow(__flag);
  if (this->_M_get_exception_mask() & __flag)
    {};
}

}
# 180 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_ios.h" 2
# 25 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_ostream.h" 2



# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_ostreambuf_iterator.h" 1
# 30 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_ostreambuf_iterator.h"
namespace std {

namespace priv {

template<class _CharT, class _Traits>
extern basic_streambuf<_CharT, _Traits>* __get_ostreambuf(basic_ostream<_CharT, _Traits>&);

}


template <class _CharT, class _Traits>
class ostreambuf_iterator :
  public iterator<output_iterator_tag, void, void, void, void> {
public:
  typedef _CharT char_type;
  typedef _Traits traits_type;
  typedef typename _Traits::int_type int_type;
  typedef basic_streambuf<_CharT, _Traits> streambuf_type;
  typedef basic_ostream<_CharT, _Traits> ostream_type;

  typedef output_iterator_tag iterator_category;
  typedef void value_type;
  typedef void difference_type;
  typedef void pointer;
  typedef void reference;

public:
  ostreambuf_iterator(streambuf_type* __buf) : _M_buf(__buf), _M_ok(__buf!=0) {}

  inline ostreambuf_iterator(ostream_type& __o) ;

  ostreambuf_iterator<_CharT, _Traits>& operator=(char_type __c) {
    _M_ok = _M_ok && !traits_type::eq_int_type(_M_buf->sputc(__c),
                                               traits_type::eof());
    return *this;
  }

  ostreambuf_iterator<_CharT, _Traits>& operator*() { return *this; }
  ostreambuf_iterator<_CharT, _Traits>& operator++() { return *this; }
  ostreambuf_iterator<_CharT, _Traits>& operator++(int) { return *this; }

  bool failed() const { return !_M_ok; }

private:
  streambuf_type* _M_buf;
  bool _M_ok;
};

template <class _CharT, class _Traits>
inline ostreambuf_iterator<_CharT, _Traits>::ostreambuf_iterator(basic_ostream<_CharT, _Traits>& __o)
  : _M_buf(::std::priv:: __get_ostreambuf(__o)), _M_ok(_M_buf != 0) {}
# 95 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_ostreambuf_iterator.h"
}
# 29 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_ostream.h" 2






namespace std {






namespace priv {

template <class _CharT, class _Traits>
bool __init_bostr(basic_ostream<_CharT, _Traits>& __str);

}




template <class _CharT, class _Traits>
class basic_ostream : virtual public basic_ios<_CharT, _Traits> {
  typedef basic_ostream<_CharT, _Traits> _Self;







public:
  typedef _CharT char_type;
  typedef typename _Traits::int_type int_type;
  typedef typename _Traits::pos_type pos_type;
  typedef typename _Traits::off_type off_type;
  typedef _Traits traits_type;
  typedef basic_ios<_CharT, _Traits> _Basic_ios;

public:
  explicit basic_ostream(basic_streambuf<_CharT, _Traits>* __buf);
  ~basic_ostream();

public:
  typedef basic_ios<_CharT, _Traits>& ( *__ios_fn)(basic_ios<_CharT, _Traits>&);
  typedef ios_base& ( *__ios_base_fn)(ios_base&);
  typedef _Self& ( *__ostream_fn)(_Self&);
  _Self& operator<< (__ostream_fn __f) { return __f(*this); }
  _Self & operator<< (__ios_base_fn __f) { __f(*this); return *this; }
  _Self& operator<< (__ios_fn __ff) { __ff(*this); return *this; }

private:
  bool _M_copy_buffered(basic_streambuf<_CharT, _Traits>* __from,
                        basic_streambuf<_CharT, _Traits>* __to);
  bool _M_copy_unbuffered(basic_streambuf<_CharT, _Traits>* __from,
                          basic_streambuf<_CharT, _Traits>* __to);

public:
  void _M_put_char(_CharT __c);

  void _M_put_nowiden(const _CharT* __s);
  void _M_put_widen(const char* __s);
  bool _M_put_widen_aux(const char* __s, streamsize __n);

public:
  _Self& put(char_type __c);
  _Self& write(const char_type* __s, streamsize __n);

public:

  _Self& operator<<(basic_streambuf<_CharT, _Traits>* __buf);


  _Self& operator<<(unsigned char __x) { _M_put_char(__x); return *this; }

  _Self& operator<<(short __x);
  _Self& operator<<(unsigned short __x);
  _Self& operator<<(int __x);

  _Self& operator<<(unsigned int __x);






  _Self& operator<<(long __x);
  _Self& operator<<(unsigned long __x);

  _Self& operator<< (long long __x);
  _Self& operator<< (unsigned long long __x);

  _Self& operator<<(float __x);
  _Self& operator<<(double __x);

  _Self& operator<<(long double __x);

  _Self& operator<<(const void* __x);

  _Self& operator<<(bool __x);


public:
  _Self& flush() {
    if (this->rdbuf())
      if (this->rdbuf()->pubsync() == -1)
        this->setstate(ios_base::badbit);
    return *this;
  }

  pos_type tellp() {
    return this->rdbuf() && !this->fail()
      ? this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out)
      : pos_type(-1);
  }

  _Self& seekp(pos_type __pos) {
    if (this->rdbuf() && !this->fail()) {
      if (this->rdbuf()->pubseekpos(__pos, ios_base::out) == pos_type(-1)) {
        this->setstate(ios_base::failbit);
      }
    }
    return *this;
  }

  _Self& seekp(off_type __off, ios_base::seekdir __dir) {
    if (this->rdbuf() && !this->fail())
      this->rdbuf()->pubseekoff(__off, __dir, ios_base::out);
    return *this;
  }
# 172 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_ostream.h"
    class sentry {
      typedef sentry _Self;

    private:
      basic_ostream<_CharT, _Traits>& _M_str;

      bool _M_ok;
    public:
      explicit sentry(basic_ostream<_CharT, _Traits>& __str)
        : _M_str(__str), _M_ok(::std::priv:: __init_bostr(__str))
      {}

      ~sentry() {
        if (_M_str.flags() & ios_base::unitbuf)



            _M_str.flush();
      }

      operator bool() const { return _M_ok; }
    private:

      sentry(const _Self& __s) : _M_str(__s._M_str) {}
      _Self& operator=(const _Self&) { return *this; }
    };




};
# 214 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_ostream.h"
namespace priv {


template <class _CharT, class _Traits>
bool __init_bostr(basic_ostream<_CharT, _Traits>& __str) {
  if (__str.good()) {

    if (!__str.rdbuf())
      __str.setstate(ios_base::badbit);
    if (__str.tie())
      __str.tie()->flush();
    return __str.good();
  }
  else
    return false;
}

template <class _CharT, class _Traits>
inline basic_streambuf<_CharT, _Traits>*
__get_ostreambuf(basic_ostream<_CharT, _Traits>& __St)
{ return __St.rdbuf(); }

}


template <class _CharT, class _Traits>
inline basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, _CharT __c){
  __os._M_put_char(__c);
  return __os;
}

template <class _CharT, class _Traits>
inline basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, const _CharT* __s) {
  __os._M_put_nowiden(__s);
  return __os;
}
# 295 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_ostream.h"
template <class _CharT, class _Traits>
inline basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, char __c) {
  __os._M_put_char(__os.widen(__c));
  return __os;
}

template <class _Traits>
inline basic_ostream<char, _Traits>&
operator<<(basic_ostream<char, _Traits>& __os, char __c) {
  __os._M_put_char(__c);
  return __os;
}

template <class _Traits>
inline basic_ostream<char, _Traits>&
operator<<(basic_ostream<char, _Traits>& __os, signed char __c) {
  __os._M_put_char(__c);
  return __os;
}

template <class _Traits>
inline basic_ostream<char, _Traits>&
operator<<(basic_ostream<char, _Traits>& __os, unsigned char __c) {
  __os._M_put_char(__c);
  return __os;
}

template <class _CharT, class _Traits>
inline basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, const char* __s) {
  __os._M_put_widen(__s);
  return __os;
}

template <class _Traits>
inline basic_ostream<char, _Traits>&
operator<<(basic_ostream<char, _Traits>& __os, const char* __s) {
  __os._M_put_nowiden(__s);
  return __os;
}

template <class _Traits>
inline basic_ostream<char, _Traits>&
operator<<(basic_ostream<char, _Traits>& __os, const signed char* __s) {
  __os._M_put_nowiden(reinterpret_cast<const char*>(__s));
  return __os;
}

template <class _Traits>
inline basic_ostream<char, _Traits>&
operator<<(basic_ostream<char, _Traits>& __os, const unsigned char* __s) {
  __os._M_put_nowiden(reinterpret_cast<const char*>(__s));
  return __os;
}





template <class _CharT, class _Traits>
inline basic_ostream<_CharT, _Traits>&
endl(basic_ostream<_CharT, _Traits>& __os) {
  __os.put(__os.widen('\n'));
  __os.flush();
  return __os;
}

template <class _CharT, class _Traits>
inline basic_ostream<_CharT, _Traits>&
ends(basic_ostream<_CharT, _Traits>& __os) {
  __os.put(_CharT());
  return __os;
}

template <class _CharT, class _Traits>
inline basic_ostream<_CharT, _Traits>&
flush(basic_ostream<_CharT, _Traits>& __os) {
  __os.flush();
  return __os;
}

}


# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_ostream.c" 1
# 26 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_ostream.c"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_num_put.h" 1
# 39 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_num_put.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_iostream_string.h" 1
# 36 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_iostream_string.h"
namespace std {

namespace priv {

template <class _CharT>
class __iostring_allocator : public allocator<_CharT> {
public:
  enum { _STR_SIZE = 256 };

private:
  enum { _BUF_SIZE = _STR_SIZE + 1 };
  typedef allocator<_CharT> _Base;
  _CharT _M_static_buf[_BUF_SIZE];

public:
  typedef typename _Base::size_type size_type;
  typedef typename _Base::pointer pointer;

  template <class _Tp1> struct rebind {

    typedef __iostring_allocator<_Tp1> other;



  };


  _CharT* allocate(size_type __n, const void* __ptr = 0) {
    if (__n > _BUF_SIZE) {
      return _Base::allocate(__n, __ptr);
    }
    return _M_static_buf;
  }
  void deallocate(pointer __p, size_type __n) {
    if (__p != _M_static_buf) _Base::deallocate(__p, __n);
  }
};
# 96 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_iostream_string.h"
template <class _CharT>
struct __basic_iostring : public basic_string<_CharT, char_traits<_CharT>, __iostring_allocator<_CharT> > {






  typedef __basic_iostring<_CharT> _Self;
  typedef basic_string<_CharT, char_traits<_CharT>, __iostring_allocator<_CharT> > _Base;
  typedef typename _Base::_Reserve_t _Reserve_t;

  __basic_iostring() : _Base(_Reserve_t(), __iostring_allocator<_CharT>::_STR_SIZE)
  {}

  _Self& operator=(const _CharT* __s) {
    _Base::operator=(__s);
    return *this;
  }
};

typedef __basic_iostring<char> __iostring;


typedef __basic_iostring<wchar_t> __iowstring;
# 136 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_iostream_string.h"
}

}
# 40 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_num_put.h" 2






namespace std {




template <class _CharT, class _OutputIter>
class num_put: public locale::facet {
public:
  typedef _CharT char_type;
  typedef _OutputIter iter_type;

  explicit num_put(size_t __refs = 0) : locale::facet(__refs) {}


  iter_type put(iter_type __s, ios_base& __f, char_type __fill,
                bool __val) const {
    return do_put(__s, __f, __fill, __val);
  }

  iter_type put(iter_type __s, ios_base& __f, char_type __fill,
               long __val) const {
    return do_put(__s, __f, __fill, __val);
  }

  iter_type put(iter_type __s, ios_base& __f, char_type __fill,
                unsigned long __val) const {
    return do_put(__s, __f, __fill, __val);
  }


  iter_type put(iter_type __s, ios_base& __f, char_type __fill,
                long long __val) const {
    return do_put(__s, __f, __fill, __val);
  }

  iter_type put(iter_type __s, ios_base& __f, char_type __fill,
                unsigned long long __val) const {
    return do_put(__s, __f, __fill, __val);
  }


  iter_type put(iter_type __s, ios_base& __f, char_type __fill,
                double __val) const {
    return do_put(__s, __f, __fill, (double)__val);
  }


  iter_type put(iter_type __s, ios_base& __f, char_type __fill,
                long double __val) const {
    return do_put(__s, __f, __fill, __val);
  }


  iter_type put(iter_type __s, ios_base& __f, char_type __fill,
                const void * __val) const {
    return do_put(__s, __f, __fill, __val);
  }

  static locale::id id;

protected:
  ~num_put() {}

  virtual _OutputIter do_put(_OutputIter __s, ios_base& __f, _CharT __fill, bool __val) const;

  virtual _OutputIter do_put(_OutputIter __s, ios_base& __f, _CharT __fill, long __val) const;
  virtual _OutputIter do_put(_OutputIter __s, ios_base& __f, _CharT __fill, unsigned long __val) const;
  virtual _OutputIter do_put(_OutputIter __s, ios_base& __f, _CharT __fill, double __val) const;

  virtual _OutputIter do_put(_OutputIter __s, ios_base& __f, _CharT __fill, long double __val) const;



  virtual _OutputIter do_put(_OutputIter __s, ios_base& __f, _CharT __fill, long long __val) const;
  virtual _OutputIter do_put(_OutputIter __s, ios_base& __f, _CharT __fill,
                           unsigned long long __val) const ;

  virtual _OutputIter do_put(_OutputIter __s, ios_base& __f, _CharT __fill, const void* __val) const;
};
# 135 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_num_put.h"
namespace priv {

template <class _Integer>
char*
__write_integer_backward(char* __buf, ios_base::fmtflags __flags, _Integer __x);





extern size_t __write_float(__iostring&, ios_base::fmtflags, int, double);

extern size_t __write_float(__iostring&, ios_base::fmtflags, int, long double);





void __get_floor_digits(__iostring&, long double);

template <class _CharT>
void __get_money_digits(::std::priv:: __basic_iostring<_CharT>&, ios_base&, long double);


extern void __convert_float_buffer(__iostring const&, __iowstring&, const ctype<wchar_t>&, wchar_t, bool = true);

extern void __adjust_float_buffer(__iostring&, char);

extern char*
__write_integer(char* buf, ios_base::fmtflags flags, long x);

extern ptrdiff_t __insert_grouping(char* first, char* last, const string&, char, char, char, int);
extern void __insert_grouping(__iostring&, size_t, const string&, char, char, char, int);

extern ptrdiff_t __insert_grouping(wchar_t*, wchar_t*, const string&, wchar_t, wchar_t, wchar_t, int);
extern void __insert_grouping(__iowstring&, size_t, const string&, wchar_t, wchar_t, wchar_t, int);


}



}


# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_num_put.c" 1
# 26 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_num_put.c"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_limits.h" 1
# 32 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_limits.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/cfloat" 1
# 33 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/cfloat"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/float.h" 1
# 32 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/float.h"
# 1 "/home/petya/download/android-ndk-r8b/toolchains/arm-linux-androideabi-4.4.3/prebuilt/linux-x86/bin/../lib/gcc/arm-linux-androideabi/4.4.3/include/../include/float.h" 1 3 4
# 33 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/float.h" 2
# 34 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/cfloat" 2
# 33 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_limits.h" 2






namespace std {

enum float_round_style {
  round_indeterminate = -1,
  round_toward_zero = 0,
  round_to_nearest = 1,
  round_toward_infinity = 2,
  round_toward_neg_infinity = 3
};

enum float_denorm_style {
  denorm_indeterminate = -1,
  denorm_absent = 0,
  denorm_present = 1
};

namespace priv {


template <class __number>
class _Numeric_limits_base {
public:

  static __number ( min)() { return __number(); }
  static __number ( max)() { return __number(); }

  static const int digits = 0;
  static const int digits10 = 0;
  static const int radix = 0;
  static const int min_exponent = 0;
  static const int min_exponent10 = 0;
  static const int max_exponent = 0;
  static const int max_exponent10 = 0;

  static const float_denorm_style has_denorm = denorm_absent;
  static const float_round_style round_style = round_toward_zero;

  static const bool is_specialized = false;
  static const bool is_signed = false;
  static const bool is_integer = false;
  static const bool is_exact = false;
  static const bool has_infinity = false;
  static const bool has_quiet_NaN = false;
  static const bool has_signaling_NaN = false;
  static const bool has_denorm_loss = false;
  static const bool is_iec559 = false;
  static const bool is_bounded = false;
  static const bool is_modulo = false;
  static const bool traps = false;
  static const bool tinyness_before = false;

  static __number epsilon() { return __number(); }
  static __number round_error() { return __number(); }

  static __number infinity() { return __number(); }
  static __number quiet_NaN() { return __number(); }
  static __number signaling_NaN() { return __number(); }
  static __number denorm_min() { return __number(); }
};
# 114 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_limits.h"
template <class _Int,
          _Int __imin,
          _Int __imax,
          int __idigits, bool __ismod>
class _Integer_limits : public _Numeric_limits_base<_Int> {
public:

  static _Int ( min) () { return (_Int)__imin; }
  static _Int ( max) () { return (_Int)__imax; }

  static const int digits = (__idigits < 0) ? ((int)((sizeof(_Int) * (8))) - ((__imin == 0) ? 0 : 1)) : (__idigits);
  static const int digits10 = (digits * 301UL) / 1000;
  static const int radix = 2;
  static const bool is_specialized = true;
  static const bool is_signed = (__imin != 0);
  static const bool is_integer = true;
  static const bool is_exact = true;
  static const bool is_bounded = true;
  static const bool is_modulo = __ismod;
};


template <class __number,
         int __Digits, int __Digits10,
         int __MinExp, int __MaxExp,
         int __MinExp10, int __MaxExp10,
         bool __IsIEC559,
         float_denorm_style __DenormStyle,
         float_round_style __RoundStyle>
class _Floating_limits : public _Numeric_limits_base<__number> {
public:

  static const int digits = __Digits;
  static const int digits10 = __Digits10;
  static const int radix = 2;
  static const int min_exponent = __MinExp;
  static const int max_exponent = __MaxExp;
  static const int min_exponent10 = __MinExp10;
  static const int max_exponent10 = __MaxExp10;

  static const float_denorm_style has_denorm = __DenormStyle;
  static const float_round_style round_style = __RoundStyle;

  static const bool is_specialized = true;
  static const bool is_signed = true;

  static const bool has_infinity = true;



  static const bool has_quiet_NaN = true;
  static const bool has_signaling_NaN = true;





  static const bool is_iec559 = __IsIEC559 && has_infinity && has_quiet_NaN && has_signaling_NaN && (has_denorm == denorm_present);
  static const bool has_denorm_loss = false;
  static const bool is_bounded = true;
  static const bool traps = true;
  static const bool tinyness_before = false;
};

}





template<class _Tp>
class numeric_limits : public ::std::priv:: _Numeric_limits_base<_Tp> {};




template<>
class numeric_limits<bool>
  : public ::std::priv:: _Integer_limits<bool, false, true, 1, false>
{};


template<>
class numeric_limits<char>
  : public ::std::priv:: _Integer_limits<char, 0, 0xff, -1, true>
{};


template<>
class numeric_limits<signed char>
  : public ::std::priv:: _Integer_limits<signed char, (-0x7f-1), 0x7f, -1, true>
{};


template<>
class numeric_limits<unsigned char>
  : public ::std::priv:: _Integer_limits<unsigned char, 0, 0xffU, -1, true>
{};



template<>
class numeric_limits<wchar_t>
  : public ::std::priv:: _Integer_limits<wchar_t, 0, 255, -1, true>
{};



template<>
class numeric_limits<short>
  : public ::std::priv:: _Integer_limits<short, (-0x7fff-1), 0x7fff, -1, true>
{};

template<>
class numeric_limits<unsigned short>
  : public ::std::priv:: _Integer_limits<unsigned short, 0, 0xffffU, -1, true>
{};






template<>
class numeric_limits<int>
  : public ::std::priv:: _Integer_limits<int, (-0x7fffffff-1), 0x7fffffff, -1, true>
{};

template<>
class numeric_limits<unsigned int>
  : public ::std::priv:: _Integer_limits<unsigned int, 0, 0xffffffffU, -1, true>
{};

template<>
class numeric_limits<long>
  : public ::std::priv:: _Integer_limits<long, (-0x7fffffffL-1), 0x7fffffffL, -1, true>
{};

template<>
class numeric_limits<unsigned long>
  : public ::std::priv:: _Integer_limits<unsigned long, 0, 0xffffffffUL, -1, true>
{};
# 277 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_limits.h"
template<>
class numeric_limits<long long>
  : public ::std::priv:: _Integer_limits<long long, (-9223372036854775807LL-1), 9223372036854775807LL, -1, true>
{};

template<>
class numeric_limits<unsigned long long>
  : public ::std::priv:: _Integer_limits<unsigned long long, 0, 18446744073709551615ULL, -1, true>
{};
# 337 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_limits.h"
namespace priv {


template <class __dummy>
class _LimG {
public:
  static float get_F_inf();
  static float get_F_qNaN();
  static float get_F_sNaN();
  static float get_F_denormMin();
  static double get_D_inf();
  static double get_D_qNaN();
  static double get_D_sNaN();
  static double get_D_denormMin();


  static long double get_LD_inf();
  static long double get_LD_qNaN();
  static long double get_LD_sNaN();
  static long double get_LD_denormMin();

};
# 397 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_limits.h"
}

template<>
class numeric_limits<float>
  : public ::std::priv:: _Floating_limits<float,
                                       24,
                                       6,
                                       (-125),
                                       128,
                                       (-37),
                                       38,
                                       true,
                                       denorm_present,
                                       round_to_nearest> {
public:
  static float ( min) () { return 1.17549435e-38F; }
  static float denorm_min()

  { return 1.40129846e-45F; }



  static float ( max) () { return 3.40282347e+38F; }
  static float epsilon() { return 1.19209290e-7F; }
  static float round_error() { return 0.5f; }
  static float infinity() { return ::std::priv:: _LimG<bool>::get_F_inf(); }
  static float quiet_NaN() { return ::std::priv:: _LimG<bool>::get_F_qNaN(); }
  static float signaling_NaN() { return ::std::priv:: _LimG<bool>::get_F_sNaN(); }
};




template<>
class numeric_limits<double>
  : public ::std::priv:: _Floating_limits<double,
                                       53,
                                       15,
                                       (-1021),
                                       1024,
                                       (-307),
                                       308,
                                       true,
                                       denorm_present,
                                       round_to_nearest> {
public:
  static double ( min)() { return 2.2250738585072014e-308; }
  static double denorm_min()

  { return 4.9406564584124654e-324; }



  static double ( max)() { return 1.7976931348623157e+308; }
  static double epsilon() { return 2.2204460492503131e-16; }
  static double round_error() { return 0.5; }
  static double infinity() { return ::std::priv:: _LimG<bool>::get_D_inf(); }
  static double quiet_NaN() { return ::std::priv:: _LimG<bool>::get_D_qNaN(); }
  static double signaling_NaN() { return ::std::priv:: _LimG<bool>::get_D_sNaN(); }
};



template<>
class numeric_limits<long double>
  : public ::std::priv:: _Floating_limits<long double,
                                       53,
                                       15,
                                       (-1021),
                                       1024,
                                       (-307),
                                       308,
                                       false,
                                       denorm_present,
                                       round_to_nearest> {
public:
  static long double ( min) () { return 2.2250738585072014e-308L; }
  static long double denorm_min()

  { return 4.9406564584124654e-324L; }



  static const bool is_iec559 = false;
  static long double ( max) () { return 1.7976931348623157e+308L; }
  static long double epsilon() { return 2.2204460492503131e-16L; }
  static long double round_error() { return 0.5l; }
  static long double infinity()


  { return ::std::priv:: _LimG<bool>::get_LD_inf(); }



  static long double quiet_NaN()

  { return ::std::priv:: _LimG<bool>::get_LD_qNaN(); }



  static long double signaling_NaN()

  { return ::std::priv:: _LimG<bool>::get_LD_sNaN(); }



};





}


# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_limits.c" 1
# 30 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_limits.c"
namespace std {

namespace priv {







template <class __number> const bool _Numeric_limits_base<__number>:: is_specialized;
template <class __number> const int _Numeric_limits_base<__number>:: digits;
template <class __number> const int _Numeric_limits_base<__number>:: digits10;
template <class __number> const bool _Numeric_limits_base<__number>:: is_signed;
template <class __number> const bool _Numeric_limits_base<__number>:: is_integer;
template <class __number> const bool _Numeric_limits_base<__number>:: is_exact;
template <class __number> const int _Numeric_limits_base<__number>:: radix;
template <class __number> const int _Numeric_limits_base<__number>:: min_exponent;
template <class __number> const int _Numeric_limits_base<__number>:: max_exponent;
template <class __number> const int _Numeric_limits_base<__number>:: min_exponent10;
template <class __number> const int _Numeric_limits_base<__number>:: max_exponent10;
template <class __number> const bool _Numeric_limits_base<__number>:: has_infinity;
template <class __number> const bool _Numeric_limits_base<__number>:: has_quiet_NaN;
template <class __number> const bool _Numeric_limits_base<__number>:: has_signaling_NaN;
template <class __number> const float_denorm_style _Numeric_limits_base<__number>:: has_denorm;
template <class __number> const bool _Numeric_limits_base<__number>:: has_denorm_loss;
template <class __number> const bool _Numeric_limits_base<__number>:: is_iec559;
template <class __number> const bool _Numeric_limits_base<__number>:: is_bounded;
template <class __number> const bool _Numeric_limits_base<__number>:: is_modulo;
template <class __number> const bool _Numeric_limits_base<__number>:: traps;
template <class __number> const bool _Numeric_limits_base<__number>:: tinyness_before;
template <class __number> const float_round_style _Numeric_limits_base<__number>:: round_style;







template <class _Int, _Int __imin, _Int __imax, int __idigits, bool __ismod> const bool _Integer_limits<_Int, __imin, __imax, __idigits, __ismod>:: is_specialized;
template <class _Int, _Int __imin, _Int __imax, int __idigits, bool __ismod> const int _Integer_limits<_Int, __imin, __imax, __idigits, __ismod>:: digits;
template <class _Int, _Int __imin, _Int __imax, int __idigits, bool __ismod> const int _Integer_limits<_Int, __imin, __imax, __idigits, __ismod>:: digits10;
template <class _Int, _Int __imin, _Int __imax, int __idigits, bool __ismod> const bool _Integer_limits<_Int, __imin, __imax, __idigits, __ismod>:: is_signed;
template <class _Int, _Int __imin, _Int __imax, int __idigits, bool __ismod> const bool _Integer_limits<_Int, __imin, __imax, __idigits, __ismod>:: is_integer;
template <class _Int, _Int __imin, _Int __imax, int __idigits, bool __ismod> const bool _Integer_limits<_Int, __imin, __imax, __idigits, __ismod>:: is_exact;
template <class _Int, _Int __imin, _Int __imax, int __idigits, bool __ismod> const int _Integer_limits<_Int, __imin, __imax, __idigits, __ismod>:: radix;
template <class _Int, _Int __imin, _Int __imax, int __idigits, bool __ismod> const bool _Integer_limits<_Int, __imin, __imax, __idigits, __ismod>:: is_bounded;
template <class _Int, _Int __imin, _Int __imax, int __idigits, bool __ismod> const bool _Integer_limits<_Int, __imin, __imax, __idigits, __ismod>:: is_modulo;
# 115 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_limits.c"
template <class __number, int __Digits, int __Digits10, int __MinExp, int __MaxExp, int __MinExp10, int __MaxExp10, bool __IsIEC559, float_denorm_style __DenormStyle, float_round_style __RoundStyle> const bool _Floating_limits< __number, __Digits, __Digits10, __MinExp, __MaxExp, __MinExp10, __MaxExp10, __IsIEC559, __DenormStyle, __RoundStyle>:: is_specialized;
template <class __number, int __Digits, int __Digits10, int __MinExp, int __MaxExp, int __MinExp10, int __MaxExp10, bool __IsIEC559, float_denorm_style __DenormStyle, float_round_style __RoundStyle> const int _Floating_limits< __number, __Digits, __Digits10, __MinExp, __MaxExp, __MinExp10, __MaxExp10, __IsIEC559, __DenormStyle, __RoundStyle>:: digits;
template <class __number, int __Digits, int __Digits10, int __MinExp, int __MaxExp, int __MinExp10, int __MaxExp10, bool __IsIEC559, float_denorm_style __DenormStyle, float_round_style __RoundStyle> const int _Floating_limits< __number, __Digits, __Digits10, __MinExp, __MaxExp, __MinExp10, __MaxExp10, __IsIEC559, __DenormStyle, __RoundStyle>:: digits10;
template <class __number, int __Digits, int __Digits10, int __MinExp, int __MaxExp, int __MinExp10, int __MaxExp10, bool __IsIEC559, float_denorm_style __DenormStyle, float_round_style __RoundStyle> const bool _Floating_limits< __number, __Digits, __Digits10, __MinExp, __MaxExp, __MinExp10, __MaxExp10, __IsIEC559, __DenormStyle, __RoundStyle>:: is_signed;
template <class __number, int __Digits, int __Digits10, int __MinExp, int __MaxExp, int __MinExp10, int __MaxExp10, bool __IsIEC559, float_denorm_style __DenormStyle, float_round_style __RoundStyle> const int _Floating_limits< __number, __Digits, __Digits10, __MinExp, __MaxExp, __MinExp10, __MaxExp10, __IsIEC559, __DenormStyle, __RoundStyle>:: radix;
template <class __number, int __Digits, int __Digits10, int __MinExp, int __MaxExp, int __MinExp10, int __MaxExp10, bool __IsIEC559, float_denorm_style __DenormStyle, float_round_style __RoundStyle> const int _Floating_limits< __number, __Digits, __Digits10, __MinExp, __MaxExp, __MinExp10, __MaxExp10, __IsIEC559, __DenormStyle, __RoundStyle>:: min_exponent;
template <class __number, int __Digits, int __Digits10, int __MinExp, int __MaxExp, int __MinExp10, int __MaxExp10, bool __IsIEC559, float_denorm_style __DenormStyle, float_round_style __RoundStyle> const int _Floating_limits< __number, __Digits, __Digits10, __MinExp, __MaxExp, __MinExp10, __MaxExp10, __IsIEC559, __DenormStyle, __RoundStyle>:: max_exponent;
template <class __number, int __Digits, int __Digits10, int __MinExp, int __MaxExp, int __MinExp10, int __MaxExp10, bool __IsIEC559, float_denorm_style __DenormStyle, float_round_style __RoundStyle> const int _Floating_limits< __number, __Digits, __Digits10, __MinExp, __MaxExp, __MinExp10, __MaxExp10, __IsIEC559, __DenormStyle, __RoundStyle>:: min_exponent10;
template <class __number, int __Digits, int __Digits10, int __MinExp, int __MaxExp, int __MinExp10, int __MaxExp10, bool __IsIEC559, float_denorm_style __DenormStyle, float_round_style __RoundStyle> const int _Floating_limits< __number, __Digits, __Digits10, __MinExp, __MaxExp, __MinExp10, __MaxExp10, __IsIEC559, __DenormStyle, __RoundStyle>:: max_exponent10;
template <class __number, int __Digits, int __Digits10, int __MinExp, int __MaxExp, int __MinExp10, int __MaxExp10, bool __IsIEC559, float_denorm_style __DenormStyle, float_round_style __RoundStyle> const bool _Floating_limits< __number, __Digits, __Digits10, __MinExp, __MaxExp, __MinExp10, __MaxExp10, __IsIEC559, __DenormStyle, __RoundStyle>:: has_infinity;
template <class __number, int __Digits, int __Digits10, int __MinExp, int __MaxExp, int __MinExp10, int __MaxExp10, bool __IsIEC559, float_denorm_style __DenormStyle, float_round_style __RoundStyle> const bool _Floating_limits< __number, __Digits, __Digits10, __MinExp, __MaxExp, __MinExp10, __MaxExp10, __IsIEC559, __DenormStyle, __RoundStyle>:: has_quiet_NaN;
template <class __number, int __Digits, int __Digits10, int __MinExp, int __MaxExp, int __MinExp10, int __MaxExp10, bool __IsIEC559, float_denorm_style __DenormStyle, float_round_style __RoundStyle> const bool _Floating_limits< __number, __Digits, __Digits10, __MinExp, __MaxExp, __MinExp10, __MaxExp10, __IsIEC559, __DenormStyle, __RoundStyle>:: has_signaling_NaN;
template <class __number, int __Digits, int __Digits10, int __MinExp, int __MaxExp, int __MinExp10, int __MaxExp10, bool __IsIEC559, float_denorm_style __DenormStyle, float_round_style __RoundStyle> const float_denorm_style _Floating_limits< __number, __Digits, __Digits10, __MinExp, __MaxExp, __MinExp10, __MaxExp10, __IsIEC559, __DenormStyle, __RoundStyle>:: has_denorm;
template <class __number, int __Digits, int __Digits10, int __MinExp, int __MaxExp, int __MinExp10, int __MaxExp10, bool __IsIEC559, float_denorm_style __DenormStyle, float_round_style __RoundStyle> const bool _Floating_limits< __number, __Digits, __Digits10, __MinExp, __MaxExp, __MinExp10, __MaxExp10, __IsIEC559, __DenormStyle, __RoundStyle>:: has_denorm_loss;
template <class __number, int __Digits, int __Digits10, int __MinExp, int __MaxExp, int __MinExp10, int __MaxExp10, bool __IsIEC559, float_denorm_style __DenormStyle, float_round_style __RoundStyle> const bool _Floating_limits< __number, __Digits, __Digits10, __MinExp, __MaxExp, __MinExp10, __MaxExp10, __IsIEC559, __DenormStyle, __RoundStyle>:: is_iec559;
template <class __number, int __Digits, int __Digits10, int __MinExp, int __MaxExp, int __MinExp10, int __MaxExp10, bool __IsIEC559, float_denorm_style __DenormStyle, float_round_style __RoundStyle> const bool _Floating_limits< __number, __Digits, __Digits10, __MinExp, __MaxExp, __MinExp10, __MaxExp10, __IsIEC559, __DenormStyle, __RoundStyle>:: is_bounded;
template <class __number, int __Digits, int __Digits10, int __MinExp, int __MaxExp, int __MinExp10, int __MaxExp10, bool __IsIEC559, float_denorm_style __DenormStyle, float_round_style __RoundStyle> const bool _Floating_limits< __number, __Digits, __Digits10, __MinExp, __MaxExp, __MinExp10, __MaxExp10, __IsIEC559, __DenormStyle, __RoundStyle>:: traps;
template <class __number, int __Digits, int __Digits10, int __MinExp, int __MaxExp, int __MinExp10, int __MaxExp10, bool __IsIEC559, float_denorm_style __DenormStyle, float_round_style __RoundStyle> const bool _Floating_limits< __number, __Digits, __Digits10, __MinExp, __MaxExp, __MinExp10, __MaxExp10, __IsIEC559, __DenormStyle, __RoundStyle>:: tinyness_before;
template <class __number, int __Digits, int __Digits10, int __MinExp, int __MaxExp, int __MinExp10, int __MaxExp10, bool __IsIEC559, float_denorm_style __DenormStyle, float_round_style __RoundStyle> const float_round_style _Floating_limits< __number, __Digits, __Digits10, __MinExp, __MaxExp, __MinExp10, __MaxExp10, __IsIEC559, __DenormStyle, __RoundStyle>:: round_style;
# 154 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_limits.c"
template<class _Number, unsigned short _Word>
struct float_helper {
  union _WordsNumber {
    unsigned short _Words[8];
    _Number _num;
  };
  static _Number get_word_higher() {
    _WordsNumber __tmp = { { _Word, 0, 0, 0, 0, 0, 0, 0 } };
    return __tmp._num;
  }
  static _Number get_word_lower() {
    _WordsNumber __tmp = { { 0, 0, 0, 0, 0, 0, 0, 0 } };
    __tmp._Words[(sizeof(_Number) >= 12 ? 10 : sizeof(_Number)) / sizeof(unsigned short) - 1] = _Word;
    return __tmp._num;
  }
  static _Number get_from_last_word() {



    return get_word_lower();

  }
  static _Number get_from_first_word() {



    return get_word_higher();

  }
};


template<class _Number, unsigned short _Word1, unsigned short _Word2>
struct float_helper2 {
  union _WordsNumber {
    unsigned short _Words[8];
    _Number _num;
  };




  static _Number get_word_lower() {
    _WordsNumber __tmp = { { 0, 0, 0, 0, 0, 0, 0, 0 } };
    __tmp._Words[(sizeof(_Number) >= 12 ? 10 : sizeof(_Number)) / sizeof(unsigned short) - 2] = _Word1;
    __tmp._Words[(sizeof(_Number) >= 12 ? 10 : sizeof(_Number)) / sizeof(unsigned short) - 1] = _Word2;
    return __tmp._num;
  }
  static _Number get_from_last_word() {



    return get_word_lower();

  }
};
# 288 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_limits.c"
template <class __dummy>
float _LimG<__dummy>::get_F_inf() {
  typedef float_helper<float, 0x7f80u> _FloatHelper;
  return _FloatHelper::get_from_last_word();
}
template <class __dummy>
float _LimG<__dummy>::get_F_qNaN() {
  typedef float_helper<float, 0x7f81u> _FloatHelper;
  return _FloatHelper::get_from_last_word();
}
template <class __dummy>
float _LimG<__dummy>::get_F_sNaN() {
  typedef float_helper<float, 0x7fc1u> _FloatHelper;
  return _FloatHelper::get_from_last_word();
}
template <class __dummy>
float _LimG<__dummy>::get_F_denormMin() {
  typedef float_helper<float, 0x0001u> _FloatHelper;
  return _FloatHelper::get_from_first_word();
}

template <int __use_double_limits>
class _NumericLimitsAccess;

template<>
class _NumericLimitsAccess<1> {
public:
  static double get_inf() {
    typedef float_helper<double, 0x7ff0u> _FloatHelper;
    return _FloatHelper::get_from_last_word();
  }
  static double get_qNaN() {
    typedef float_helper<double, 0x7ff1u> _FloatHelper;
    return _FloatHelper::get_from_last_word();
  }
  static double get_sNaN() {
    typedef float_helper<double, 0x7ff9u> _FloatHelper;
    return _FloatHelper::get_from_last_word();
  }
};

template <class __dummy>
double _LimG<__dummy>::get_D_inf()
{ return _NumericLimitsAccess<1>::get_inf(); }
template <class __dummy>
double _LimG<__dummy>::get_D_qNaN()
{ return _NumericLimitsAccess<1>::get_qNaN(); }
template <class __dummy>
double _LimG<__dummy>::get_D_sNaN()
{ return _NumericLimitsAccess<1>::get_sNaN(); }
template <class __dummy>
double _LimG<__dummy>::get_D_denormMin() {
  typedef float_helper<double, 0x0001u> _FloatHelper;
  return _FloatHelper::get_from_first_word();
}


template<>
class _NumericLimitsAccess<0> {
public:
  static long double get_inf() {



    typedef float_helper2<long double, 0x8000u, 0x7fffu> _FloatHelper;

    return _FloatHelper::get_from_last_word();
  }
  static long double get_qNaN() {



    typedef float_helper2<long double, 0xc000u, 0x7fffu> _FloatHelper;

    return _FloatHelper::get_from_last_word();
  }
  static long double get_sNaN() {



    typedef float_helper2<long double, 0x9000u, 0x7fffu> _FloatHelper;

    return _FloatHelper::get_from_last_word();
  }
};

template <class __dummy>
long double _LimG<__dummy>::get_LD_inf() {
  const int __use_double_limits = sizeof(double) == sizeof(long double) ? 1 : 0;
  return _NumericLimitsAccess<__use_double_limits>::get_inf();
}
template <class __dummy>
long double _LimG<__dummy>::get_LD_qNaN() {
  const int __use_double_limits = sizeof(double) == sizeof(long double) ? 1 : 0;
  return _NumericLimitsAccess<__use_double_limits>::get_qNaN();
}
template <class __dummy>
long double _LimG<__dummy>::get_LD_sNaN() {
  const int __use_double_limits = sizeof(double) == sizeof(long double) ? 1 : 0;
  return _NumericLimitsAccess<__use_double_limits>::get_sNaN();
}
template <class __dummy>
long double _LimG<__dummy>::get_LD_denormMin() {
  typedef float_helper<long double, 0x0001u> _FloatHelper;
  return _FloatHelper::get_from_first_word();
}







}

}
# 513 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_limits.h" 2
# 27 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_num_put.c" 2


namespace std {

namespace priv {
# 40 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_num_put.c"
template <class _CharT, class _OutputIter>
_OutputIter
__copy_float_and_fill(const _CharT* __first, const _CharT* __last,
                      _OutputIter __oi,
                      ios_base::fmtflags __flags,
                      streamsize __width, _CharT __fill,
                      _CharT __xplus, _CharT __xminus) {
  if (__width <= __last - __first)
    return ::std::copy(__first, __last, __oi);
  else {
    streamsize __pad = __width - (__last - __first);
    ios_base::fmtflags __dir = __flags & ios_base::adjustfield;

    if (__dir == ios_base::left) {
      __oi = ::std::copy(__first, __last, __oi);
      return ::std::priv:: __fill_n(__oi, __pad, __fill);
    }
    else if (__dir == ios_base::internal && __first != __last &&
             (*__first == __xplus || *__first == __xminus)) {
      *__oi++ = *__first++;
      __oi = ::std::priv:: __fill_n(__oi, __pad, __fill);
      return ::std::copy(__first, __last, __oi);
    }
    else {
      __oi = ::std::priv:: __fill_n(__oi, __pad, __fill);
      return ::std::copy(__first, __last, __oi);
    }
  }
}



template <class _OutputIter>
_OutputIter
__put_float(__iostring &__str, _OutputIter __oi,
            ios_base& __f, wchar_t __fill,
            wchar_t __decimal_point, wchar_t __sep,
            size_t __group_pos, const string& __grouping) {
  const ctype<wchar_t>& __ct = use_facet<ctype<wchar_t> >(__f.getloc());

  __iowstring __wbuf;
  __convert_float_buffer(__str, __wbuf, __ct, __decimal_point);

  if (!__grouping.empty()) {
    __insert_grouping(__wbuf, __group_pos, __grouping,
                      __sep, __ct.widen('+'), __ct.widen('-'), 0);
  }

  return __copy_float_and_fill(__wbuf.data(), __wbuf.data() + __wbuf.size(), __oi,
                               __f.flags(), __f.width(0), __fill, __ct.widen('+'), __ct.widen('-'));
}



template <class _OutputIter>
_OutputIter
__put_float(__iostring &__str, _OutputIter __oi,
            ios_base& __f, char __fill,
            char __decimal_point, char __sep,
            size_t __group_pos, const string& __grouping) {
  if ((__group_pos < __str.size()) && (__str[__group_pos] == '.')) {
    __str[__group_pos] = __decimal_point;
  }

  if (!__grouping.empty()) {
    __insert_grouping(__str, __group_pos,
                      __grouping, __sep, '+', '-', 0);
  }

  return __copy_float_and_fill(__str.data(), __str.data() + __str.size(), __oi,
                               __f.flags(), __f.width(0), __fill, '+', '-');
}

template <class _CharT, class _OutputIter, class _Float>
_OutputIter
__do_put_float(_OutputIter __s, ios_base& __f,
                _CharT __fill, _Float __x) {
  __iostring __buf;

  size_t __group_pos = __write_float(__buf, __f.flags(), (int)__f.precision(), __x);

  const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__f.getloc());
  return __put_float(__buf, __s, __f, __fill,
                     __np.decimal_point(), __np.thousands_sep(),
                     __group_pos, __np.grouping());
}

inline void __get_money_digits_aux (__iostring &__buf, ios_base &, long double __x)
{ __get_floor_digits(__buf, __x); }


inline void __get_money_digits_aux (__iowstring &__wbuf, ios_base &__f, long double __x) {
  __iostring __buf;
  __get_floor_digits(__buf, __x);

  const ctype<wchar_t>& __ct = use_facet<ctype<wchar_t> >(__f.getloc());
  __convert_float_buffer(__buf, __wbuf, __ct, wchar_t(0), false);
}


template <class _CharT>
void __get_money_digits(::std::priv:: __basic_iostring<_CharT> &__buf, ios_base& __f, long double __x)
{ __get_money_digits_aux(__buf, __f, __x); }



template <class _CharT, class _OutputIter>
_OutputIter
__copy_integer_and_fill(const _CharT* __buf, ptrdiff_t __len,
                        _OutputIter __oi,
                        ios_base::fmtflags __flg, streamsize __wid, _CharT __fill,
                        _CharT __xplus, _CharT __xminus) {
  if (__len >= __wid)
    return ::std::copy(__buf, __buf + __len, __oi);
  else {


    typedef char __static_assert[(sizeof(streamsize) > sizeof(ptrdiff_t)) || ((sizeof(streamsize) == sizeof(ptrdiff_t)) && numeric_limits<ptrdiff_t>::is_signed) ? 1 : -1];

    ptrdiff_t __pad = static_cast<ptrdiff_t>((min) (static_cast<streamsize>((numeric_limits<ptrdiff_t>::max)()), static_cast<streamsize>(__wid - __len)));

    ios_base::fmtflags __dir = __flg & ios_base::adjustfield;

    if (__dir == ios_base::left) {
      __oi = ::std::copy(__buf, __buf + __len, __oi);
      return ::std::priv:: __fill_n(__oi, __pad, __fill);
    }
    else if (__dir == ios_base::internal && __len != 0 &&
             (__buf[0] == __xplus || __buf[0] == __xminus)) {
      *__oi++ = __buf[0];
      __oi = __fill_n(__oi, __pad, __fill);
      return ::std::copy(__buf + 1, __buf + __len, __oi);
    }
    else if (__dir == ios_base::internal && __len >= 2 &&
             (__flg & ios_base::showbase) &&
             (__flg & ios_base::basefield) == ios_base::hex) {
      *__oi++ = __buf[0];
      *__oi++ = __buf[1];
      __oi = __fill_n(__oi, __pad, __fill);
      return ::std::copy(__buf + 2, __buf + __len, __oi);
    }
    else {
      __oi = __fill_n(__oi, __pad, __fill);
      return ::std::copy(__buf, __buf + __len, __oi);
    }
  }
}



template <class _OutputIter>
_OutputIter
__put_integer(char* __buf, char* __iend, _OutputIter __s,
              ios_base& __f,
              ios_base::fmtflags __flags, wchar_t __fill) {
  locale __loc = __f.getloc();
  const ctype<wchar_t>& __ct = use_facet<ctype<wchar_t> >(__loc);

  wchar_t __xplus = __ct.widen('+');
  wchar_t __xminus = __ct.widen('-');

  wchar_t __wbuf[64];
  __ct.widen(__buf, __iend, __wbuf);
  ptrdiff_t __len = __iend - __buf;
  wchar_t* __eend = __wbuf + __len;

  const numpunct<wchar_t>& __np = use_facet<numpunct<wchar_t> >(__loc);
  const string& __grouping = __np.grouping();

  if (!__grouping.empty()) {
    int __basechars;
    if (__flags & ios_base::showbase)
      switch (__flags & ios_base::basefield) {
        case ios_base::hex: __basechars = 2; break;
        case ios_base::oct: __basechars = 1; break;
        default: __basechars = 0;
      }
    else
      __basechars = 0;

    __len = __insert_grouping(__wbuf, __eend, __grouping, __np.thousands_sep(),
                              __xplus, __xminus, __basechars);
  }

  return __copy_integer_and_fill((wchar_t*)__wbuf, __len, __s,
                                 __flags, __f.width(0), __fill, __xplus, __xminus);
}



template <class _OutputIter>
_OutputIter
__put_integer(char* __buf, char* __iend, _OutputIter __s,
              ios_base& __f, ios_base::fmtflags __flags, char __fill) {
  char __grpbuf[64];
  ptrdiff_t __len = __iend - __buf;

  const numpunct<char>& __np = use_facet<numpunct<char> >(__f.getloc());
  const string& __grouping = __np.grouping();

  if (!__grouping.empty()) {
    int __basechars;
    if (__flags & ios_base::showbase)
      switch (__flags & ios_base::basefield) {
        case ios_base::hex: __basechars = 2; break;
        case ios_base::oct: __basechars = 1; break;
        default: __basechars = 0;
      }
    else
      __basechars = 0;



    ::std::copy(__buf, __iend, (char *) __grpbuf);
    __buf = __grpbuf;
    __iend = __grpbuf + __len;
    __len = __insert_grouping(__buf, __iend, __grouping, __np.thousands_sep(),
                              '+', '-', __basechars);
  }

  return __copy_integer_and_fill(__buf, __len, __s, __flags, __f.width(0), __fill, '+', '-');
}


typedef long long __max_int_t;
typedef unsigned long long __umax_int_t;





__attribute__((visibility("default"))) const char* __hex_char_table_lo();
__attribute__((visibility("default"))) const char* __hex_char_table_hi();

template <class _Integer>
inline char*
__write_decimal_backward(char* __ptr, _Integer __x, ios_base::fmtflags __flags, const __true_type& ) {
  const bool __negative = __x < 0 ;
  __max_int_t __temp = __x;
  __umax_int_t __utemp = __negative?-__temp:__temp;

  for (; __utemp != 0; __utemp /= 10)
    *--__ptr = (char)((int)(__utemp % 10) + '0');

  if (__negative)
    *--__ptr = '-';
  else if (__flags & ios_base::showpos)
    *--__ptr = '+';
  return __ptr;
}

template <class _Integer>
inline char*
__write_decimal_backward(char* __ptr, _Integer __x, ios_base::fmtflags __flags, const __false_type& ) {
  for (; __x != 0; __x /= 10)
    *--__ptr = (char)((int)(__x % 10) + '0');

  if (__flags & ios_base::showpos)
    *--__ptr = '+';
  return __ptr;
}

template <class _Integer>
char*
__write_integer_backward(char* __buf, ios_base::fmtflags __flags, _Integer __x) {
  char* __ptr = __buf;

  if (__x == 0) {
    *--__ptr = '0';
    if ((__flags & ios_base::showpos) && ((__flags & (ios_base::oct | ios_base::hex)) == 0))
      *--__ptr = '+';

  }
  else {
    switch (__flags & ios_base::basefield) {
      case ios_base::oct:
        {
          __umax_int_t __temp = __x;

          if ( sizeof(__x) < 8 && sizeof(__umax_int_t) >= 8 )
            __temp &= 0xFFFFFFFF;

          for (; __temp != 0; __temp >>=3)
            *--__ptr = (char)((((unsigned)__temp)& 0x7) + '0');


          if (__flags & ios_base::showbase)
            *--__ptr = '0';
        }
        break;
      case ios_base::hex:
        {
          const char* __table_ptr = (__flags & ios_base::uppercase) ?
            __hex_char_table_hi() : __hex_char_table_lo();
          __umax_int_t __temp = __x;

          if ( sizeof(__x) < 8 && sizeof(__umax_int_t) >= 8 )
            __temp &= 0xFFFFFFFF;

          for (; __temp != 0; __temp >>=4)
            *--__ptr = __table_ptr[((unsigned)__temp & 0xF)];

          if (__flags & ios_base::showbase) {
            *--__ptr = __table_ptr[16];
            *--__ptr = '0';
          }
        }
        break;

      default:
        {







          typedef typename __bool2type<numeric_limits<_Integer>::is_signed>::_Ret _IsSigned;
          __ptr = __write_decimal_backward(__ptr, __x, __flags, _IsSigned());

        }
        break;
    }
  }


  return __ptr;
}

template <class _CharT, class _OutputIter, class _Integer>
_OutputIter
__do_put_integer(_OutputIter __s, ios_base& __f, _CharT __fill, _Integer __x) {




  char __buf[sizeof(_Integer) * 3 + 2];
  const ptrdiff_t __buf_size = sizeof(__buf) / sizeof(char);
  ios_base::fmtflags __flags = __f.flags();
  char* __ibeg = __write_integer_backward((char*)__buf + __buf_size, __flags, __x);
  return __put_integer(__ibeg, (char*)__buf + __buf_size, __s, __f, __flags, __fill);
}

template <class _CharT, class _OutputIter>
_OutputIter
__do_put_bool(_OutputIter __s, ios_base& __f, _CharT __fill, bool __x) {
  const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__f.getloc());

  basic_string<_CharT, char_traits<_CharT>, allocator<_CharT> > __str = __x ? __np.truename() : __np.falsename();

  streamsize __wid = __f.width(0);
  if (__str.size() >= static_cast<size_t>(__wid))
    return ::std::copy(__str.begin(), __str.end(), __s);
  else {
    streamsize __pad = __wid - __str.size();
    ios_base::fmtflags __dir = __f.flags() & ios_base::adjustfield;

    if (__dir == ios_base::left) {
      __s = ::std::copy(__str.begin(), __str.end(), __s);
      return __fill_n(__s, __pad, __fill);
    }
    else {
      __s = __fill_n(__s, __pad, __fill);
      return ::std::copy(__str.begin(), __str.end(), __s);
    }
  }
}
}





template <class _CharT, class _OutputIterator>
locale::id num_put<_CharT, _OutputIterator>::id;


template <class _CharT, class _OutputIter>
_OutputIter
num_put<_CharT, _OutputIter>::do_put(_OutputIter __s, ios_base& __f, _CharT __fill,
                                     bool __val) const {
  if (!(__f.flags() & ios_base::boolalpha))

    return do_put(__s, __f, __fill, static_cast<long>(__val));

  return ::std::priv:: __do_put_bool(__s, __f, __fill, __val);
}


template <class _CharT, class _OutputIter>
_OutputIter
num_put<_CharT, _OutputIter>::do_put(_OutputIter __s, ios_base& __f, _CharT __fill,
                                     long __val) const
{ return ::std::priv:: __do_put_integer(__s, __f, __fill, __val); }

template <class _CharT, class _OutputIter>
_OutputIter
num_put<_CharT, _OutputIter>::do_put(_OutputIter __s, ios_base& __f, _CharT __fill,
                                     unsigned long __val) const
{ return ::std::priv:: __do_put_integer(__s, __f, __fill, __val); }

template <class _CharT, class _OutputIter>
_OutputIter
num_put<_CharT, _OutputIter>::do_put(_OutputIter __s, ios_base& __f, _CharT __fill,
                                     double __val) const
{ return ::std::priv:: __do_put_float(__s, __f, __fill, __val); }


template <class _CharT, class _OutputIter>
_OutputIter
num_put<_CharT, _OutputIter>::do_put(_OutputIter __s, ios_base& __f, _CharT __fill,
                                     long double __val) const
{ return ::std::priv:: __do_put_float(__s, __f, __fill, __val); }



template <class _CharT, class _OutputIter>
_OutputIter
num_put<_CharT, _OutputIter>::do_put(_OutputIter __s, ios_base& __f, _CharT __fill,
                                     long long __val) const
{ return ::std::priv:: __do_put_integer(__s, __f, __fill, __val); }

template <class _CharT, class _OutputIter>
_OutputIter
num_put<_CharT, _OutputIter>::do_put(_OutputIter __s, ios_base& __f, _CharT __fill,
                                     unsigned long long __val) const
{ return ::std::priv:: __do_put_integer(__s, __f, __fill, __val); }





template <class _CharT, class _OutputIter>
_OutputIter
num_put<_CharT, _OutputIter>::do_put(_OutputIter __s, ios_base& __f, _CharT ,
                                     const void* __val) const {
  const ctype<_CharT>& __c_type = use_facet<ctype<_CharT> >(__f.getloc());
  ios_base::fmtflags __save_flags = __f.flags();

  __f.setf(ios_base::hex, ios_base::basefield);
  __f.setf(ios_base::showbase);
  __f.setf(ios_base::internal, ios_base::adjustfield);
  __f.width((sizeof(void*) * 2) + 2);
  if ( __val == 0 ) {


    const char* __table_ptr = (__save_flags & ios_base::uppercase) ?
            ::std::priv:: __hex_char_table_hi() : ::std::priv:: __hex_char_table_lo();
    __s++ = __c_type.widen( '0' );
    __s++ = __c_type.widen( __table_ptr[16] );
    __f.width((sizeof(void*) * 2));
  } else {
    __f.width((sizeof(void*) * 2) + 2);
  }




  _OutputIter result =

    ( sizeof(void*) == sizeof(unsigned long) ) ?

    ::std::priv:: __do_put_integer(__s, __f, __c_type.widen('0'), reinterpret_cast<unsigned long>(__val))

      :
    ::std::priv:: __do_put_integer(__s, __f, __c_type.widen('0'), reinterpret_cast<unsigned long long>(__val))

        ;



  __f.flags(__save_flags);
  return result;
}

}
# 181 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_num_put.h" 2
# 27 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_ostream.c" 2


namespace std {






template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>::basic_ostream(basic_streambuf<_CharT, _Traits>* __buf)
    : basic_ios<_CharT, _Traits>() {
  this->init(__buf);
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>::~basic_ostream()
{}


template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(basic_streambuf<_CharT, _Traits>* __from) {
  sentry __sentry(*this);
  if (__sentry) {
    if (__from) {
      bool __any_inserted = __from->gptr() != __from->egptr()
        ? this->_M_copy_buffered(__from, this->rdbuf())
        : this->_M_copy_unbuffered(__from, this->rdbuf());
      if (!__any_inserted)
        this->setstate(ios_base::failbit);
    }
    else
      this->setstate(ios_base::badbit);
  }

  return *this;
}






template <class _CharT, class _Traits>
bool basic_ostream<_CharT, _Traits>
  ::_M_copy_buffered(basic_streambuf<_CharT, _Traits>* __from,
                     basic_streambuf<_CharT, _Traits>* __to) {
  bool __any_inserted = false;

  while (__from->egptr() != __from->gptr()) {
    const ptrdiff_t __avail = __from->egptr() - __from->gptr();

    streamsize __nwritten;
    {
      __nwritten = __to->sputn(__from->gptr(), __avail);
      __from->gbump((int)__nwritten);
    }
    if (false) {
      this->_M_handle_exception(ios_base::badbit);
      return __any_inserted;
    }

    if (__nwritten == __avail) {
      {
        if (this->_S_eof(__from->sgetc()))
          return true;
        else
          __any_inserted = true;
      }
      if (false) {
        this->_M_handle_exception(ios_base::failbit);
        return false;
      }
    }
    else if (__nwritten != 0)
      return true;
    else
      return __any_inserted;
  }



  return __any_inserted || this->_M_copy_unbuffered(__from, __to);
}





template <class _CharT, class _Traits>
struct _SPutBackC {
  typedef basic_streambuf<_CharT, _Traits> _StreamBuf;
  typedef typename _StreamBuf::int_type int_type;
  _SPutBackC(_StreamBuf *pfrom)
    : __pfrom(pfrom), __c(0), __do_guard(false) {}
  ~_SPutBackC() {
    if (__do_guard) {
      __pfrom->sputbackc(_Traits::to_char_type(__c));
    }
  }

  void guard(int_type c) {
    __c = c;
    __do_guard = true;
  }
  void release() {
    __do_guard = false;
  }

private:
  _StreamBuf *__pfrom;
  int_type __c;
  bool __do_guard;
};

template <class _CharT, class _Traits>
bool basic_ostream<_CharT, _Traits>
  ::_M_copy_unbuffered(basic_streambuf<_CharT, _Traits>* __from,
                       basic_streambuf<_CharT, _Traits>* __to) {
  typedef _SPutBackC<_CharT, _Traits> _SPutBackCGuard;
  bool __any_inserted = false;
  int_type __c;

  {
    _SPutBackCGuard __cguard(__from);
    for (;;) {
      {
        __c = __from->sbumpc();
      }
      if (false) {
        this->_M_handle_exception(ios_base::failbit);
        break;
      }

      if (this->_S_eof(__c))
        break;

      __cguard.guard(__c);



      if (this->_S_eof(__to->sputc(_Traits::to_char_type(__c))))
        break;
# 179 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_ostream.c"
      __cguard.release();
      __any_inserted = true;
    }
  }
  if (false) {
    this->_M_handle_exception(ios_base::badbit);
  }
  return __any_inserted;
}

namespace priv {


template <class _CharT, class _Traits, class _Number>
basic_ostream<_CharT, _Traits>&
__put_num(basic_ostream<_CharT, _Traits>& __os, _Number __x) {
  typedef typename basic_ostream<_CharT, _Traits>::sentry _Sentry;
  _Sentry __sentry(__os);
  bool __failed = true;

  if (__sentry) {
    {
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> > _NumPut;
      __failed = (use_facet<_NumPut>(__os.getloc())).put(ostreambuf_iterator<_CharT, _Traits>(__os.rdbuf()),
                                                         __os, __os.fill(),
                                                         __x).failed();
    }
    if (false) {
      __os._M_handle_exception(ios_base::badbit);
    }
  }
  if (__failed)
    __os.setstate(ios_base::badbit);
  return __os;
}

}





template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>& basic_ostream<_CharT, _Traits>::operator<<(short __x) {
  typedef char __static_assert[sizeof(short) <= sizeof(long) ? 1 : -1];
  long __tmp = ((this->flags() & _Basic_ios::basefield) != ios_base::dec) ?
                  static_cast<long>(static_cast<unsigned short>(__x)): __x;
  return ::std::priv:: __put_num(*this, __tmp);
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>& basic_ostream<_CharT, _Traits>::operator<<(unsigned short __x) {
  typedef char __static_assert[sizeof(unsigned short) <= sizeof(unsigned long) ? 1 : -1];
  return ::std::priv:: __put_num(*this, static_cast<unsigned long>(__x));
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>& basic_ostream<_CharT, _Traits>::operator<<(int __x) {
  typedef char __static_assert[sizeof(int) <= sizeof(long) ? 1 : -1];
  long __tmp = ((this->flags() & _Basic_ios::basefield) != ios_base::dec) ?
                  static_cast<long>(static_cast<unsigned int>(__x)): __x;
  return ::std::priv:: __put_num(*this, __tmp);
}

template <class _CharT, class _Traits>

basic_ostream<_CharT, _Traits>& basic_ostream<_CharT, _Traits>::operator<<(unsigned int __x) {
  typedef char __static_assert[sizeof(unsigned int) <= sizeof(unsigned long) ? 1 : -1];







  return ::std::priv:: __put_num(*this, static_cast<unsigned long>(__x));
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>& basic_ostream<_CharT, _Traits>::operator<<(long __x)
{ return ::std::priv:: __put_num(*this, __x); }

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>& basic_ostream<_CharT, _Traits>::operator<<(unsigned long __x)
{ return ::std::priv:: __put_num(*this, __x); }


template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>& basic_ostream<_CharT, _Traits>::operator<< (long long __x)
{ return ::std::priv:: __put_num(*this, __x); }

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>& basic_ostream<_CharT, _Traits>::operator<< (unsigned long long __x)
{ return ::std::priv:: __put_num(*this, __x); }


template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>& basic_ostream<_CharT, _Traits>::operator<<(float __x)
{ return ::std::priv:: __put_num(*this, static_cast<double>(__x)); }

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>& basic_ostream<_CharT, _Traits>::operator<<(double __x)
{ return ::std::priv:: __put_num(*this, __x); }


template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>& basic_ostream<_CharT, _Traits>::operator<<(long double __x)
{ return ::std::priv:: __put_num(*this, __x); }


template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>& basic_ostream<_CharT, _Traits>::operator<<(const void* __x)
{ return ::std::priv:: __put_num(*this, __x); }


template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>& basic_ostream<_CharT, _Traits>::operator<<(bool __x)
{ return ::std::priv:: __put_num(*this, __x); }


template <class _CharT, class _Traits>
void basic_ostream<_CharT, _Traits>::_M_put_char(_CharT __c) {
  sentry __sentry(*this);
  if (__sentry) {
    bool __failed = true;
    {
      streamsize __npad = this->width() > 0 ? this->width() - 1 : 0;

      if (__npad == 0)
        __failed = this->_S_eof(this->rdbuf()->sputc(__c));
      else if ((this->flags() & ios_base::adjustfield) == ios_base::left) {
        __failed = this->_S_eof(this->rdbuf()->sputc(__c));
        __failed = __failed ||
                   this->rdbuf()->_M_sputnc(this->fill(), __npad) != __npad;
      }
      else {
        __failed = this->rdbuf()->_M_sputnc(this->fill(), __npad) != __npad;
        __failed = __failed || this->_S_eof(this->rdbuf()->sputc(__c));
      }

      this->width(0);
    }
    if (false) {
      this->_M_handle_exception(ios_base::badbit);
    }

    if (__failed)
      this->setstate(ios_base::badbit);
  }
}

template <class _CharT, class _Traits>
void basic_ostream<_CharT, _Traits>::_M_put_nowiden(const _CharT* __s) {
  sentry __sentry(*this);
  if (__sentry) {
    bool __failed = true;
    streamsize __n = _Traits::length(__s);
    streamsize __npad = this->width() > __n ? this->width() - __n : 0;

    {
      if (__npad == 0)
        __failed = this->rdbuf()->sputn(__s, __n) != __n;
      else if ((this->flags() & ios_base::adjustfield) == ios_base::left) {
        __failed = this->rdbuf()->sputn(__s, __n) != __n;
        __failed = __failed ||
                   this->rdbuf()->_M_sputnc(this->fill(), __npad) != __npad;
      }
      else {
        __failed = this->rdbuf()->_M_sputnc(this->fill(), __npad) != __npad;
        __failed = __failed || this->rdbuf()->sputn(__s, __n) != __n;
      }

      this->width(0);
    }
    if (false) {
      this->_M_handle_exception(ios_base::badbit);
    }

    if (__failed)
      this->setstate(ios_base::failbit);
  }
}

template <class _CharT, class _Traits>
void basic_ostream<_CharT, _Traits>::_M_put_widen(const char* __s) {
  sentry __sentry(*this);
  if (__sentry) {
    bool __failed = true;
    streamsize __n = char_traits<char>::length(__s);
    streamsize __npad = this->width() > __n ? this->width() - __n : 0;

    {
      if (__npad == 0)
        __failed = !this->_M_put_widen_aux(__s, __n);
      else if ((this->flags() & ios_base::adjustfield) == ios_base::left) {
        __failed = !this->_M_put_widen_aux(__s, __n);
        __failed = __failed ||
                   this->rdbuf()->_M_sputnc(this->fill(), __npad) != __npad;
      }
      else {
        __failed = this->rdbuf()->_M_sputnc(this->fill(), __npad) != __npad;
        __failed = __failed || !this->_M_put_widen_aux(__s, __n);
      }

      this->width(0);
    }
    if (false) {
      this->_M_handle_exception(ios_base::badbit);
    }

    if (__failed)
      this->setstate(ios_base::failbit);
  }
}

template <class _CharT, class _Traits>
bool basic_ostream<_CharT, _Traits>::_M_put_widen_aux(const char* __s,
                                                      streamsize __n) {
  basic_streambuf<_CharT, _Traits>* __buf = this->rdbuf();

  for ( ; __n > 0 ; --__n)
    if (this->_S_eof(__buf->sputc(this->widen(*__s++))))
      return false;
  return true;
}


template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::put(char_type __c) {
  sentry __sentry(*this);
  bool __failed = true;

  if (__sentry) {
    {
      __failed = this->_S_eof(this->rdbuf()->sputc(__c));
    }
    if (false) {
      this->_M_handle_exception(ios_base::badbit);
    }
  }

  if (__failed)
    this->setstate(ios_base::badbit);

  return *this;
}


template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::write(const char_type* __s, streamsize __n) {
  sentry __sentry(*this);
  bool __failed = true;

  if (__sentry) {
    {
      __failed = this->rdbuf()->sputn(__s, __n) != __n;
    }
    if (false) {
      this->_M_handle_exception(ios_base::badbit);
    }
  }

  if (__failed)
    this->setstate(ios_base::badbit);

  return *this;
}

}
# 381 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_ostream.h" 2
# 24 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_string_io.h" 2



# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_istream.h" 1
# 35 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_istream.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_istreambuf_iterator.h" 1
# 34 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_istreambuf_iterator.h"
namespace std {


template <class _CharT, class _Traits>
extern basic_streambuf<_CharT, _Traits>* _M_get_istreambuf(basic_istream<_CharT, _Traits>& ) ;





template<class _CharT, class _Traits>
class istreambuf_iterator :
  public iterator<input_iterator_tag, _CharT, typename _Traits::off_type, _CharT*, _CharT&>
{
public:
  typedef _CharT char_type;
  typedef _Traits traits_type;
  typedef typename _Traits::int_type int_type;
  typedef basic_streambuf<_CharT, _Traits> streambuf_type;
  typedef basic_istream<_CharT, _Traits> istream_type;

  typedef input_iterator_tag iterator_category;
  typedef _CharT value_type;
  typedef typename _Traits::off_type difference_type;
  typedef const _CharT* pointer;
  typedef const _CharT& reference;

public:
  istreambuf_iterator(streambuf_type* __p = 0) { this->_M_init(__p); }

  inline istreambuf_iterator(basic_istream<_CharT, _Traits>& __is);

  char_type operator*() const { this->_M_getc(); return _M_c; }
  istreambuf_iterator<_CharT, _Traits>& operator++() {
    _M_buf->sbumpc();
    _M_have_c = false;
    return *this;
  }
  istreambuf_iterator<_CharT, _Traits> operator++(int);

  bool equal(const istreambuf_iterator<_CharT, _Traits>& __i) const {
    if (this->_M_buf)
      this->_M_getc();
    if (__i._M_buf)
      __i._M_getc();
    return this->_M_eof == __i._M_eof;
  }

private:
  void _M_init(streambuf_type* __p) {
    _M_buf = __p;
    _M_eof = (__p == 0);
    _M_have_c = false;
  }

  void _M_getc() const {
    if (_M_have_c)
      return;
    int_type __c = _M_buf->sgetc();
    _M_c = traits_type::to_char_type(__c);
    _M_eof = traits_type::eq_int_type(__c, traits_type::eof());
    _M_have_c = true;
  }

private:
  streambuf_type* _M_buf;
  mutable _CharT _M_c;
  mutable bool _M_eof;
  mutable bool _M_have_c;
};

template<class _CharT, class _Traits>
inline istreambuf_iterator<_CharT, _Traits>::istreambuf_iterator(basic_istream<_CharT, _Traits>& __is)
{ this->_M_init(_M_get_istreambuf(__is)); }

template<class _CharT, class _Traits>
inline bool operator==(const istreambuf_iterator<_CharT, _Traits>& __x,
                                  const istreambuf_iterator<_CharT, _Traits>& __y) {
  return __x.equal(__y);
}



template<class _CharT, class _Traits>
inline bool operator!=(const istreambuf_iterator<_CharT, _Traits>& __x,
                                  const istreambuf_iterator<_CharT, _Traits>& __y) {
  return !__x.equal(__y);
}
# 142 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_istreambuf_iterator.h"
template <class _CharT, class _Traits>
istreambuf_iterator<_CharT, _Traits>
istreambuf_iterator<_CharT, _Traits>::operator++(int) {
  _M_getc();


  istreambuf_iterator<_CharT, _Traits> __tmp = *this;
  _M_buf->sbumpc();
  _M_have_c = false;
  return __tmp;
}

}
# 36 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_istream.h" 2




namespace std {






struct _No_Skip_WS {};

template <class _CharT, class _Traits>
bool _M_init_skip(basic_istream<_CharT, _Traits>& __istr);
template <class _CharT, class _Traits>
bool _M_init_noskip(basic_istream<_CharT, _Traits>& __istr);
# 62 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_istream.h"
template <class _CharT, class _Traits>
class basic_istream : virtual public basic_ios<_CharT, _Traits> {
  typedef basic_istream<_CharT, _Traits> _Self;







public:

  typedef _CharT char_type;
  typedef typename _Traits::int_type int_type;
  typedef typename _Traits::pos_type pos_type;
  typedef typename _Traits::off_type off_type;
  typedef _Traits traits_type;
  typedef basic_ios<_CharT, _Traits> _Basic_ios;

  typedef basic_ios<_CharT, _Traits>& ( *__ios_fn)(basic_ios<_CharT, _Traits>&);
  typedef ios_base& ( *__ios_base_fn)(ios_base&);
  typedef _Self& ( *__istream_fn)(_Self&);

public:
  explicit basic_istream(basic_streambuf<_CharT, _Traits>* __buf) :
    basic_ios<_CharT, _Traits>(), _M_gcount(0) {
    this->init(__buf);
  }
  ~basic_istream() {};

public:

public:

  _Self& operator>> (__istream_fn __f) { return __f(*this); }
  _Self& operator>> (__ios_fn __f) { __f(*this); return *this; }
  _Self& operator>> (__ios_base_fn __f) { __f(*this); return *this; }

public:
  _Self& operator>> (short& __val);
  _Self& operator>> (int& __val);
  _Self& operator>> (unsigned short& __val);
  _Self& operator>> (unsigned int& __val);
  _Self& operator>> (long& __val);
  _Self& operator>> (unsigned long& __val);

  _Self& operator>> (long long& __val);
  _Self& operator>> (unsigned long long& __val);

  _Self& operator>> (float& __val);
  _Self& operator>> (double& __val);

  _Self& operator>> (long double& __val);


  _Self& operator>> (bool& __val);

  _Self& operator>> (void*& __val);

public:
  _Self& operator>>(basic_streambuf<_CharT, _Traits>*);

public:
  streamsize gcount() const { return _M_gcount; }
  int_type peek();

public:
  int_type get();
  _Self& get(char_type& __c);

public:
  _Self& get(char_type* __s, streamsize __n, char_type __delim);
  _Self& get(char_type* __s, streamsize __n)
    { return get(__s, __n, this->widen('\n')); }

public:
  _Self& get(basic_streambuf<_CharT, _Traits>& __buf,
                     char_type __delim);
  _Self& get(basic_streambuf<_CharT, _Traits>& __buf)
    { return get(__buf, this->widen('\n')); }

public:
  _Self& getline(char_type* __s, streamsize __n, char_type delim);
  _Self& getline(char_type* __s, streamsize __n)
    { return getline(__s, __n, this->widen('\n')); }

public:
  _Self& ignore();
  _Self& ignore(streamsize __n);
  _Self& ignore(streamsize __n, int_type __delim);

  _Self& read(char_type* __s, streamsize __n);
  streamsize readsome(char_type* __s, streamsize __n);

public:
  _Self& putback(char_type __c);
  _Self& unget();

public:
  int sync();

  pos_type tellg();
  _Self& seekg(pos_type __pos);
  _Self& seekg(off_type, ios_base::seekdir);

public:
  void _M_formatted_get(_CharT& __c);
  void _M_formatted_get(_CharT* __s);
  void _M_skip_whitespace(bool __set_failbit);

private:
  streamsize _M_gcount;

public:
# 187 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_istream.h"
  class sentry {
    typedef sentry _Self;


  private:
    const bool _M_ok;


  public:
    typedef _Traits traits_type;

    explicit sentry(basic_istream<_CharT, _Traits>& __istr,
                    bool __noskipws = false) :
      _M_ok((__noskipws || !(__istr.flags() & ios_base::skipws)) ? _M_init_noskip(__istr) : _M_init_skip(__istr) )

      {}



    sentry(basic_istream<_CharT, _Traits>& __istr, _No_Skip_WS) :
      _M_ok(_M_init_noskip(__istr)) {}

    ~sentry() {}

    operator bool() const { return _M_ok; }

  private:

    sentry(const _Self&) : _M_ok(false) {}
    _Self& operator=(const _Self&) { return *this; }
  };





};
# 236 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_istream.h"
template <class _CharT, class _Traits>
inline basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __in_str, _CharT& __c) {
  __in_str._M_formatted_get(__c);
  return __in_str;
}

template <class _Traits>
inline basic_istream<char, _Traits>&
operator>>(basic_istream<char, _Traits>& __in_str, unsigned char& __c) {
  __in_str._M_formatted_get(reinterpret_cast<char&>(__c));
  return __in_str;
}

template <class _Traits>
inline basic_istream<char, _Traits>&
operator>>(basic_istream<char, _Traits>& __in_str, signed char& __c) {
  __in_str._M_formatted_get(reinterpret_cast<char&>(__c));
  return __in_str;
}

template <class _CharT, class _Traits>
inline basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __in_str, _CharT* __s) {
  __in_str._M_formatted_get(__s);
  return __in_str;
}

template <class _Traits>
inline basic_istream<char, _Traits>&
operator>>(basic_istream<char, _Traits>& __in_str, unsigned char* __s) {
  __in_str._M_formatted_get(reinterpret_cast<char*>(__s));
  return __in_str;
}

template <class _Traits>
inline basic_istream<char, _Traits>&
operator>>(basic_istream<char, _Traits>& __in_str, signed char* __s) {
  __in_str._M_formatted_get(reinterpret_cast<char*>(__s));
  return __in_str;
}



template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
ws(basic_istream<_CharT, _Traits>& __istr) {
  if (!__istr.eof()) {
    typedef typename basic_istream<_CharT, _Traits>::sentry _Sentry;
    _Sentry __sentry(__istr, _No_Skip_WS());
    if (__sentry)
      __istr._M_skip_whitespace(false);
  }
  return __istr;
}


template <class _CharT, class _Traits>
inline bool _M_init_skip(basic_istream<_CharT, _Traits>& __istr) {
  if (__istr.good()) {
    if (__istr.tie())
      __istr.tie()->flush();

    __istr._M_skip_whitespace(true);
  }

  if (!__istr.good()) {
    __istr.setstate(ios_base::failbit);
    return false;
  } else
    return true;
}

template <class _CharT, class _Traits>
inline bool _M_init_noskip(basic_istream<_CharT, _Traits>& __istr) {
  if (__istr.good()) {
    if (__istr.tie())
      __istr.tie()->flush();

    if (!__istr.rdbuf())
      __istr.setstate(ios_base::badbit);
  }
  else
    __istr.setstate(ios_base::failbit);
  return __istr.good();
}



template <class _CharT, class _Traits>
class basic_iostream
  : public basic_istream<_CharT, _Traits>,
    public basic_ostream<_CharT, _Traits>
{
public:
  typedef basic_ios<_CharT, _Traits> _Basic_ios;

  explicit basic_iostream(basic_streambuf<_CharT, _Traits>* __buf);
  virtual ~basic_iostream();
};
# 345 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_istream.h"
template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>* _M_get_istreambuf(basic_istream<_CharT, _Traits>& __istr)
{ return __istr.rdbuf(); }

}


# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_istream.c" 1
# 30 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_istream.c"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_num_get.h" 1
# 50 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_num_get.h"
namespace std {




template <class _CharT, class _InputIter>
class num_get: public locale::facet {
public:
  typedef _CharT char_type;
  typedef _InputIter iter_type;

  explicit num_get(size_t __refs = 0): locale::facet(__refs) {}


  _InputIter get(_InputIter __ii, _InputIter __end, ios_base& __str,
                 ios_base::iostate& __err, bool& __val) const
  { return do_get(__ii, __end, __str, __err, __val); }
# 79 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_num_get.h"
  _InputIter get(_InputIter __ii, _InputIter __end, ios_base& __str,
                 ios_base::iostate& __err, long& __val) const
  { return do_get(__ii, __end, __str, __err, __val); }

  _InputIter get(_InputIter __ii, _InputIter __end, ios_base& __str,
                 ios_base::iostate& __err, unsigned short& __val) const
  { return do_get(__ii, __end, __str, __err, __val); }

  _InputIter get(_InputIter __ii, _InputIter __end, ios_base& __str,
                 ios_base::iostate& __err, unsigned int& __val) const
  { return do_get(__ii, __end, __str, __err, __val); }

  _InputIter get(_InputIter __ii, _InputIter __end, ios_base& __str,
                 ios_base::iostate& __err, unsigned long& __val) const
  { return do_get(__ii, __end, __str, __err, __val); }


  _InputIter get(_InputIter __ii, _InputIter __end, ios_base& __str,
                 ios_base::iostate& __err, long long& __val) const
  { return do_get(__ii, __end, __str, __err, __val); }

  _InputIter get(_InputIter __ii, _InputIter __end, ios_base& __str,
                 ios_base::iostate& __err, unsigned long long& __val) const
  { return do_get(__ii, __end, __str, __err, __val); }


  _InputIter get(_InputIter __ii, _InputIter __end, ios_base& __str,
                 ios_base::iostate& __err, float& __val) const
  { return do_get(__ii, __end, __str, __err, __val); }

  _InputIter get(_InputIter __ii, _InputIter __end, ios_base& __str,
                 ios_base::iostate& __err, double& __val) const
  { return do_get(__ii, __end, __str, __err, __val); }


  _InputIter get(_InputIter __ii, _InputIter __end, ios_base& __str,
                 ios_base::iostate& __err, long double& __val) const
  { return do_get(__ii, __end, __str, __err, __val); }


  _InputIter get(_InputIter __ii, _InputIter __end, ios_base& __str,
                 ios_base::iostate& __err, void*& __val) const
  { return do_get(__ii, __end, __str, __err, __val); }

  static locale::id id;

protected:
  ~num_get() {}

  typedef string string_type;
  typedef ctype<_CharT> _Ctype;
  typedef numpunct<_CharT> _Numpunct;


  virtual _InputIter do_get(_InputIter __ii, _InputIter __end, ios_base& __str,
                            ios_base::iostate& __err, bool& __val) const;


  virtual _InputIter do_get(_InputIter __ii, _InputIter __end, ios_base& __str,
                            ios_base::iostate& __err, long& __val) const;
  virtual _InputIter do_get(_InputIter __ii, _InputIter __end, ios_base& __str,
                            ios_base::iostate& __err, unsigned short& __val) const;
  virtual _InputIter do_get(_InputIter __ii, _InputIter __end, ios_base& __str,
                            ios_base::iostate& __err, unsigned int& __val) const;
  virtual _InputIter do_get(_InputIter __ii, _InputIter __end, ios_base& __str,
                            ios_base::iostate& __err, unsigned long& __val) const;
# 154 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_num_get.h"
  virtual _InputIter do_get(_InputIter __ii, _InputIter __end, ios_base& __str,
                            ios_base::iostate& __err, float& __val) const;
  virtual _InputIter do_get(_InputIter __ii, _InputIter __end, ios_base& __str,
                            ios_base::iostate& __err, double& __val) const;
  virtual _InputIter do_get(_InputIter __ii, _InputIter __end, ios_base& __str,
                            ios_base::iostate& __err, void*& __p) const;


  virtual _InputIter do_get(_InputIter __ii, _InputIter __end, ios_base& __str,
                            ios_base::iostate& __err, long double& __val) const;



  virtual _InputIter do_get(_InputIter __ii, _InputIter __end, ios_base& __str,
                            ios_base::iostate& __err, long long& __val) const;
  virtual _InputIter do_get(_InputIter __ii, _InputIter __end, ios_base& __str,
                            ios_base::iostate& __err, unsigned long long& __val) const;


};
# 187 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_num_get.h"
namespace priv {

__attribute__((visibility("default"))) bool __valid_grouping(const char*, const char*, const char*, const char*);

template <class _InputIter, class _Integer, class _CharT>
bool
__get_decimal_integer(_InputIter& __first, _InputIter& __last, _Integer& __val, _CharT*);


bool __attribute__((visibility("default"))) __get_fdigit(wchar_t&, const wchar_t*);
bool __attribute__((visibility("default"))) __get_fdigit_or_sep(wchar_t&, wchar_t, const wchar_t*);


inline void
_Initialize_get_float(const ctype<char>&,
                       char& Plus, char& Minus,
                       char& pow_e, char& pow_E,
                       char*) {
  Plus = '+';
  Minus = '-';
  pow_e = 'e';
  pow_E = 'E';
}


void __attribute__((visibility("default"))) _Initialize_get_float(const ctype<wchar_t>&,
                                                     wchar_t&, wchar_t&, wchar_t&, wchar_t&, wchar_t*);

void __attribute__((visibility("default"))) __string_to_float(const __iostring&, float&);
void __attribute__((visibility("default"))) __string_to_float(const __iostring&, double&);

void __attribute__((visibility("default"))) __string_to_float(const __iostring&, long double&);


}




}


# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_num_get.c" 1
# 29 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_num_get.c"
namespace std {

namespace priv {

__attribute__((visibility("default"))) unsigned char __digit_val_table(unsigned);
__attribute__((visibility("default"))) const char* __narrow_atoms();



inline bool __get_fdigit(char __c, const char*)
{ return __c >= '0' && __c <= '9'; }

inline bool __get_fdigit_or_sep(char& __c, char __sep, const char *__digits) {
  if (__c == __sep) {
    __c = ',' ;
    return true ;
  }
  else
    return __get_fdigit(__c, __digits);
}

inline int
__get_digit_from_table(unsigned __index)
{ return (__index > 127 ? 0xFF : __digit_val_table(__index)); }

template <class _InputIter, class _CharT>
int
__get_base_or_zero(_InputIter& __in_ite, _InputIter& __end,
                   ios_base::fmtflags __flags, const ctype<_CharT>& __c_type) {
  _CharT __atoms[5];
  __c_type.widen(__narrow_atoms(), __narrow_atoms() + 5, __atoms);

  bool __negative = false;
  _CharT __c = *__in_ite;

  if (__c == __atoms[1] ) {
    __negative = true;
    ++__in_ite;
  }
  else if (__c == __atoms[0] )
    ++__in_ite;

  int __base;
  int __valid_zero = 0;

  ios_base::fmtflags __basefield = __flags & ios_base::basefield;

  switch (__basefield) {
  case ios_base::oct:
    __base = 8;
    break;
  case ios_base::dec:
    __base = 10;
    break;
  case ios_base::hex:
    __base = 16;
    if (__in_ite != __end && *__in_ite == __atoms[2] ) {
      ++__in_ite;
      if (__in_ite != __end &&
          (*__in_ite == __atoms[3] || *__in_ite == __atoms[4] ))
        ++__in_ite;
      else
        __valid_zero = 1;
    }
    break;
  default:
    if (__in_ite != __end && *__in_ite == __atoms[2] ) {
      ++__in_ite;
      if (__in_ite != __end &&
          (*__in_ite == __atoms[3] || *__in_ite == __atoms[4] )) {
        ++__in_ite;
        __base = 16;
      }
      else
        {
          __base = 8;
          __valid_zero = 1;
        }
    }
    else
      __base = 10;
    break;
  }
  return (__base << 2) | ((int)__negative << 1) | __valid_zero;
}


template <class _InputIter, class _Integer, class _CharT>
bool
__get_integer(_InputIter& __first, _InputIter& __last,
              int __base, _Integer& __val,
              int __got, bool __is_negative, _CharT __separator, const string& __grouping, const __true_type& ) {
  bool __ovflow = false;
  _Integer __result = 0;
  bool __is_group = !__grouping.empty();
  char __group_sizes[64];
  char __current_group_size = 0;
  char* __group_sizes_end = __group_sizes;

  _Integer __over_base = (numeric_limits<_Integer>::min)() / static_cast<_Integer>(__base);

   for ( ; __first != __last ; ++__first) {

     const _CharT __c = *__first;

     if (__is_group && __c == __separator) {
       *__group_sizes_end++ = __current_group_size;
       __current_group_size = 0;
       continue;
     }

     int __n = __get_digit_from_table(__c);

     if (__n >= __base)
       break;

     ++__got;
     ++__current_group_size;

     if (__result < __over_base)
       __ovflow = true;
     else {
       _Integer __next = static_cast<_Integer>(__base * __result - __n);
       if (__result != 0)
         __ovflow = __ovflow || __next >= __result;
       __result = __next;
     }
   }

   if (__is_group && __group_sizes_end != __group_sizes) {
     *__group_sizes_end++ = __current_group_size;
   }


   if (__got > 0) {
       __val = __ovflow ? __is_negative ? (numeric_limits<_Integer>::min)()
                                        : (numeric_limits<_Integer>::max)()
                        : __is_negative ? __result
                                        : static_cast<_Integer>(-__result);
   }

  return ((__got > 0) && !__ovflow) &&
          (__is_group == 0 ||
           __valid_grouping(__group_sizes, __group_sizes_end,
                            __grouping.data(), __grouping.data()+ __grouping.size()));
}

template <class _InputIter, class _Integer, class _CharT>
bool
__get_integer(_InputIter& __first, _InputIter& __last,
              int __base, _Integer& __val,
              int __got, bool __is_negative, _CharT __separator, const string& __grouping, const __false_type& ) {
  bool __ovflow = false;
  _Integer __result = 0;
  bool __is_group = !__grouping.empty();
  char __group_sizes[64];
  char __current_group_size = 0;
  char* __group_sizes_end = __group_sizes;

  _Integer __over_base = (numeric_limits<_Integer>::max)() / static_cast<_Integer>(__base);

  for ( ; __first != __last ; ++__first) {

    const _CharT __c = *__first;

    if (__is_group && __c == __separator) {
      *__group_sizes_end++ = __current_group_size;
      __current_group_size = 0;
      continue;
    }

    int __n = __get_digit_from_table(__c);

    if (__n >= __base)
      break;

    ++__got;
    ++__current_group_size;

    if (__result > __over_base)
      __ovflow = true;
    else {
      _Integer __next = static_cast<_Integer>(__base * __result + __n);
      if (__result != 0)
        __ovflow = __ovflow || __next <= __result;
        __result = __next;
      }
  }

  if (__is_group && __group_sizes_end != __group_sizes) {
      *__group_sizes_end++ = __current_group_size;
  }


  if (__got > 0) {
      __val = __ovflow ? (numeric_limits<_Integer>::max)()
                       : (__is_negative ? static_cast<_Integer>(-__result)
                                        : __result);
  }


  return ((__got > 0) && !__ovflow) &&
          (__is_group == 0 ||
           __valid_grouping(__group_sizes, __group_sizes_end,
                            __grouping.data(), __grouping.data()+ __grouping.size()));
}


template <class _InputIter, class _Integer, class _CharT>
bool
__get_decimal_integer(_InputIter& __first, _InputIter& __last, _Integer& __val, _CharT* ) {
  string __grp;

  return __get_integer(__first, __last, 10, __val, 0, false, _CharT() , __grp, __false_type());
}

template <class _InputIter, class _Integer, class _CharT>
_InputIter
__do_get_integer(_InputIter& __in_ite, _InputIter& __end, ios_base& __str,
                 ios_base::iostate& __err, _Integer& __val, _CharT* ) {
  locale __loc = __str.getloc();
  const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);




  typedef typename __bool2type<numeric_limits<_Integer>::is_signed>::_Ret _IsSigned;


  const int __base_or_zero = __get_base_or_zero(__in_ite, __end, __str.flags(), __ctype);
  int __got = __base_or_zero & 1;

  bool __result;

  if (__in_ite == __end) {

    if (__got > 0) {
      __val = 0;
      __result = true;
    }
    else
      __result = false;
  }
  else {
    const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);
    const bool __negative = (__base_or_zero & 2) != 0;
    const int __base = __base_or_zero >> 2;







    __result = __get_integer(__in_ite, __end, __base, __val, __got, __negative, __np.thousands_sep(), __np.grouping(), _IsSigned());

  }

  __err = static_cast<ios_base::iostate>(__result ? ios_base::goodbit : ios_base::failbit);

  if (__in_ite == __end)
    __err |= ios_base::eofbit;
  return __in_ite;
}


template <class _InputIter, class _CharT>
_InputIter
__copy_sign(_InputIter __first, _InputIter __last, __iostring& __v,
            _CharT __xplus, _CharT __xminus) {
  if (__first != __last) {
    _CharT __c = *__first;
    if (__c == __xplus)
      ++__first;
    else if (__c == __xminus) {
      __v.push_back('-');
      ++__first;
    }
  }
  return __first;
}


template <class _InputIter, class _CharT>
bool
__copy_digits(_InputIter& __first, _InputIter __last,
              __iostring& __v, const _CharT* __digits) {
  bool __ok = false;

  for ( ; __first != __last; ++__first) {
    _CharT __c = *__first;
    if (__get_fdigit(__c, __digits)) {
      __v.push_back((char)__c);
      __ok = true;
    }
    else
      break;
  }
  return __ok;
}

template <class _InputIter, class _CharT>
bool
__copy_grouped_digits(_InputIter& __first, _InputIter __last,
                      __iostring& __v, const _CharT * __digits,
                      _CharT __sep, const string& __grouping,
                      bool& __grouping_ok) {
  bool __ok = false;
  char __group_sizes[64];
  char*__group_sizes_end = __group_sizes;
  char __current_group_size = 0;

  for ( ; __first != __last; ++__first) {
    _CharT __c = *__first;
    bool __tmp = __get_fdigit_or_sep(__c, __sep, __digits);
    if (__tmp) {
      if (__c == ',') {
        *__group_sizes_end++ = __current_group_size;
        __current_group_size = 0;
      }
      else {
        __ok = true;
        __v.push_back((char)__c);
        ++__current_group_size;
      }
    }
    else
      break;
  }

  if (__group_sizes_end != __group_sizes)
    *__group_sizes_end++ = __current_group_size;
  __grouping_ok = __valid_grouping(__group_sizes, __group_sizes_end, __grouping.data(), __grouping.data() + __grouping.size());
  return __ok;
}


template <class _InputIter, class _CharT>
bool
__read_float(__iostring& __buf, _InputIter& __in_ite, _InputIter& __end,
             const ctype<_CharT> &__ct, const numpunct<_CharT> &__numpunct) {



  string __grouping = __numpunct.grouping();
  bool __digits_before_dot ;
  bool __digits_after_dot = false;
  bool __ok;

  bool __grouping_ok = true;

  _CharT __dot = __numpunct.decimal_point();
  _CharT __sep = __numpunct.thousands_sep();

  _CharT __digits[10];
  _CharT __xplus;
  _CharT __xminus;

  _CharT __pow_e;
  _CharT __pow_E;

  _Initialize_get_float(__ct, __xplus, __xminus, __pow_e, __pow_E, __digits);


  __in_ite = __copy_sign(__in_ite, __end, __buf, __xplus, __xminus);


  if (!__grouping.empty())
    __digits_before_dot = __copy_grouped_digits(__in_ite, __end, __buf, __digits,
                                                __sep, __grouping, __grouping_ok);
  else
    __digits_before_dot = __copy_digits(__in_ite, __end, __buf, __digits);


  if (__in_ite != __end && *__in_ite == __dot) {
    __buf.push_back('.');
    ++__in_ite;
    __digits_after_dot = __copy_digits(__in_ite, __end, __buf, __digits);
  }


  __ok = __digits_before_dot || __digits_after_dot;


  if (__ok && __in_ite != __end && (*__in_ite == __pow_e || *__in_ite == __pow_E)) {
    __buf.push_back('e');
    ++__in_ite;
    __in_ite = __copy_sign(__in_ite, __end, __buf, __xplus, __xminus);
    __ok = __copy_digits(__in_ite, __end, __buf, __digits);


  }

  return __ok;
}

template <class _InputIter, class _Float, class _CharT>
_InputIter
__do_get_float(_InputIter& __in_ite, _InputIter& __end, ios_base& __str,
               ios_base::iostate& __err, _Float& __val, _CharT* ) {
  locale __loc = __str.getloc();
  const ctype<_CharT> &__ctype = use_facet<ctype<_CharT> >(__loc);
  const numpunct<_CharT> &__numpunct = use_facet<numpunct<_CharT> >(__loc);

  __iostring __buf ;
  bool __ok = __read_float(__buf, __in_ite, __end, __ctype, __numpunct);
  if (__ok) {
    __string_to_float(__buf, __val);
    __err = ios_base::goodbit;
  }
  else {
    __err = ios_base::failbit;
  }
  if (__in_ite == __end)
    __err |= ios_base::eofbit;
  return __in_ite;
}

template <class _InputIter, class _CharT>
_InputIter
__do_get_alphabool(_InputIter& __in_ite, _InputIter& __end, ios_base& __str,
                   ios_base::iostate& __err, bool& __x, _CharT* ) {
  const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__str.getloc());
  const basic_string<_CharT, char_traits<_CharT>, allocator<_CharT> > __truename = __np.truename();
  const basic_string<_CharT, char_traits<_CharT>, allocator<_CharT> > __falsename = __np.falsename();
  bool __true_ok = true;
  bool __false_ok = true;

  size_t __n = 0;
  for ( ; __in_ite != __end; ++__in_ite) {
    _CharT __c = *__in_ite;
    __true_ok = __true_ok && (__c == __truename[__n]);
    __false_ok = __false_ok && (__c == __falsename[__n]);
    ++__n;

    if ((!__true_ok && !__false_ok) ||
        (__true_ok && __n >= __truename.size()) ||
        (__false_ok && __n >= __falsename.size())) {
      ++__in_ite;
      break;
    }
  }
  if (__true_ok && __n < __truename.size()) __true_ok = false;
  if (__false_ok && __n < __falsename.size()) __false_ok = false;

  if (__true_ok || __false_ok) {
    __err = ios_base::goodbit;
    __x = __true_ok;
  }
  else
    __err = ios_base::failbit;

  if (__in_ite == __end)
    __err |= ios_base::eofbit;

  return __in_ite;
}

}





template <class _CharT, class _InputIterator>
locale::id num_get<_CharT, _InputIterator>::id;


template <class _CharT, class _InputIter>
_InputIter
num_get<_CharT, _InputIter>::do_get(_InputIter __in_ite, _InputIter __end,
                                    ios_base& __s, ios_base::iostate& __err, bool& __x) const {
  if (__s.flags() & ios_base::boolalpha) {
    return ::std::priv:: __do_get_alphabool(__in_ite, __end, __s, __err, __x, (_CharT*)0);
  }
  else {
    long __lx;
    _InputIter __tmp = ::std::priv:: __do_get_integer(__in_ite, __end, __s, __err, __lx, (_CharT*)0 );
    if (!(__err & ios_base::failbit)) {
      if (__lx == 0)
        __x = false;
      else if (__lx == 1)
        __x = true;
      else
        __err |= ios_base::failbit;
    }
    return __tmp;
  }
}
# 535 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_num_get.c"
template <class _CharT, class _InputIter>
_InputIter
num_get<_CharT, _InputIter>::do_get(_InputIter __in_ite, _InputIter __end, ios_base& __str,
                                    ios_base::iostate& __err, long& __val) const
{ return ::std::priv:: __do_get_integer(__in_ite, __end, __str, __err, __val, (_CharT*)0 ); }

template <class _CharT, class _InputIter>
_InputIter
num_get<_CharT, _InputIter>::do_get(_InputIter __in_ite, _InputIter __end, ios_base& __str,
                                    ios_base::iostate& __err,
                                    unsigned short& __val) const
{ return ::std::priv:: __do_get_integer(__in_ite, __end, __str, __err, __val, (_CharT*)0 ); }

template <class _CharT, class _InputIter>
_InputIter
num_get<_CharT, _InputIter>::do_get(_InputIter __in_ite, _InputIter __end, ios_base& __str,
                                    ios_base::iostate& __err,
                                    unsigned int& __val) const
{ return ::std::priv:: __do_get_integer(__in_ite, __end, __str, __err, __val, (_CharT*)0 ); }

template <class _CharT, class _InputIter>
_InputIter
num_get<_CharT, _InputIter>::do_get(_InputIter __in_ite, _InputIter __end, ios_base& __str,
                                    ios_base::iostate& __err,
                                    unsigned long& __val) const
{ return ::std::priv:: __do_get_integer(__in_ite, __end, __str, __err, __val, (_CharT*)0 ); }

template <class _CharT, class _InputIter>
_InputIter
num_get<_CharT, _InputIter>::do_get(_InputIter __in_ite, _InputIter __end, ios_base& __str,
                                    ios_base::iostate& __err,
                                    float& __val) const
{ return ::std::priv:: __do_get_float(__in_ite, __end, __str, __err, __val, (_CharT*)0 ); }

template <class _CharT, class _InputIter>
_InputIter
num_get<_CharT, _InputIter>::do_get(_InputIter __in_ite, _InputIter __end, ios_base& __str,
                                    ios_base::iostate& __err,
                                    double& __val) const
{ return ::std::priv:: __do_get_float(__in_ite, __end, __str, __err, __val, (_CharT*)0 ); }


template <class _CharT, class _InputIter>
_InputIter
num_get<_CharT, _InputIter>::do_get(_InputIter __in_ite, _InputIter __end, ios_base& __str,
                                    ios_base::iostate& __err,
                                    long double& __val) const
{ return ::std::priv:: __do_get_float(__in_ite, __end, __str, __err, __val, (_CharT*)0 ); }


template <class _CharT, class _InputIter>
_InputIter
num_get<_CharT, _InputIter>::do_get(_InputIter __in_ite, _InputIter __end, ios_base& __str,
                                    ios_base::iostate& __err,
                                    void*& __p) const {

  unsigned long long __val;



  iter_type __tmp = ::std::priv:: __do_get_integer(__in_ite, __end, __str, __err, __val, (_CharT*)0 );
  if (!(__err & ios_base::failbit))
    __p = reinterpret_cast<void*>(__val);
  return __tmp;
}


template <class _CharT, class _InputIter>
_InputIter
num_get<_CharT, _InputIter>::do_get(_InputIter __in_ite, _InputIter __end, ios_base& __str,
                                    ios_base::iostate& __err,
                                    long long& __val) const
{ return ::std::priv:: __do_get_integer(__in_ite, __end, __str, __err, __val, (_CharT*)0 ); }

template <class _CharT, class _InputIter>
_InputIter
num_get<_CharT, _InputIter>::do_get(_InputIter __in_ite, _InputIter __end, ios_base& __str,
                                    ios_base::iostate& __err,
                                    unsigned long long& __val) const
{ return ::std::priv:: __do_get_integer(__in_ite, __end, __str, __err, __val, (_CharT*)0 ); }


}
# 230 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_num_get.h" 2
# 31 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_istream.c" 2
# 44 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_istream.c"
namespace std {




namespace priv {

template <class _Traits>
struct _Is_not_wspace {
  typedef typename _Traits::char_type argument_type;
  typedef bool result_type;

  const ctype<argument_type>* _M_ctype;

  _Is_not_wspace(const ctype<argument_type>* __c_type) : _M_ctype(__c_type) {}
  bool operator()(argument_type __c) const
    { return !_M_ctype->is(ctype_base::space, __c); }
};

template <class _Traits>
struct _Is_wspace_null {
  typedef typename _Traits::char_type argument_type;
  typedef bool result_type;

  const ctype<argument_type>* _M_ctype;

  _Is_wspace_null(const ctype<argument_type>* __c_type) : _M_ctype(__c_type) {}
  bool operator()(argument_type __c) const {
    return _Traits::eq(__c, argument_type()) ||
           _M_ctype->is(ctype_base::space, __c);
  }
};

template <class _Traits>
struct _Scan_for_wspace {
  typedef typename _Traits::char_type char_type;
  typedef char_type* first_argument_type;
  typedef char_type* second_argument_type;
  typedef char_type* result_type;

  const ctype<char_type>* _M_ctype;

  _Scan_for_wspace(const ctype<char_type>* __ctype) : _M_ctype(__ctype) {}
  const char_type*
  operator()(const char_type* __first, const char_type* __last) const {
    return _M_ctype->scan_is(ctype_base::space, __first, __last);
  }
};

template <class _Traits>
struct _Scan_wspace_null {
  typedef typename _Traits::char_type char_type;
  typedef char_type* first_argument_type;
  typedef char_type* second_argument_type;
  typedef char_type* result_type;

  const ctype<char_type>* _M_ctype;

  _Scan_wspace_null(const ctype<char_type>* __c_type) : _M_ctype(__c_type) {}
  const char_type*
  operator()(const char_type* __first, const char_type* __last) const {
    __last = find_if(__first, __last,
                     _Eq_char_bound<_Traits>(char_type()));
    return _M_ctype->scan_is(ctype_base::space, __first, __last);
  }
};

template <class _Traits>
struct _Scan_for_not_wspace {
  typedef typename _Traits::char_type char_type;
  typedef char_type* first_argument_type;
  typedef char_type* second_argument_type;
  typedef char_type* result_type;

  const ctype<char_type>* _M_ctype;

  _Scan_for_not_wspace(const ctype<char_type>* __c_type) : _M_ctype(__c_type) {}
  const char_type*
  operator()(const char_type* __first, const char_type* __last) const {
    return _M_ctype->scan_not(ctype_base::space, __first, __last);
  }
};

template <class _Traits>
struct _Scan_for_char_val {
  typedef typename _Traits::char_type char_type;
  typedef char_type* first_argument_type;
  typedef char_type* second_argument_type;
  typedef char_type* result_type;

  char_type _M_val;

  _Scan_for_char_val(char_type __val) : _M_val(__val) {}

  const char_type*
  operator()(const char_type* __first, const char_type* __last) const {
    return find_if(__first, __last, _Eq_char_bound<_Traits>(_M_val));
  }
};

template <class _Traits>
struct _Scan_for_int_val {
  typedef typename _Traits::char_type char_type;
  typedef typename _Traits::int_type int_type;
  typedef char_type* first_argument_type;
  typedef char_type* second_argument_type;
  typedef char_type* result_type;

  int_type _M_val;

  _Scan_for_int_val(int_type __val) : _M_val(__val) {}

  const char_type*
  operator()(const char_type* __first, const char_type* __last) const {
    return find_if(__first, __last,
                   _Eq_int_bound<_Traits>(_M_val));
  }
};




template <class _CharT, class _Traits>
bool
__pushback(basic_streambuf<_CharT, _Traits>* __buf, _CharT __c) {
  bool ret;
  {
    const typename _Traits::int_type __eof = _Traits::eof();
    ret = !_Traits::eq_int_type(__buf->sputbackc(__c), __eof);
  }
  if (false) {
    ret = false;
  }
  return ret;
}





template <class _CharT, class _Traits, class _Number>
ios_base::iostate
__get_num(basic_istream<_CharT, _Traits>& __that, _Number& __val) {
  typedef typename basic_istream<_CharT, _Traits>::sentry _Sentry;
  ios_base::iostate __err = 0;
  _Sentry __sentry( __that );
  if (__sentry) {
    typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> > _Num_get;
    {


      (use_facet<_Num_get>(__that.getloc())).get(istreambuf_iterator<_CharT, _Traits>(__that.rdbuf()),
                                               0, __that, __err, __val);
    }
    if (false) {
      __that._M_handle_exception(ios_base::badbit);
    }
    if (__err) __that.setstate(__err);
  }
  return __err;
}

}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::operator>> (short& __val) {
  long __lval;
  ::std::priv:: __get_num(*this, __lval);
  if ( this->fail() ) {
    return *this;
  }
  short __tmp = static_cast<short>(__lval);
  unsigned short __uval = static_cast<unsigned short>(__lval);


  if ((__tmp != __lval) && ((long)__uval != __lval))
    this->setstate(ios_base::failbit);
  else
    __val = __tmp;
  return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::operator>> (int& __val) {
  long __lval;
  ::std::priv:: __get_num(*this, __lval);
  if ( this->fail() ) {
    return *this;
  }
  int __tmp = __lval;
  unsigned int __uval = __lval;


  if ((__tmp != __lval) && ((long)__uval != __lval))
    this->setstate(ios_base::failbit);
  else
    __val = __tmp;
  return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::operator>> (unsigned short& __val) {
  ::std::priv:: __get_num(*this, __val);
  return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::operator>> (unsigned int& __val) {
  ::std::priv:: __get_num(*this, __val);
  return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::operator>> (long& __val) {
  ::std::priv:: __get_num(*this, __val);
  return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::operator>> (unsigned long& __val) {
  ::std::priv:: __get_num(*this, __val);
  return *this;
}


template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::operator>> (long long& __val) {
  ::std::priv:: __get_num(*this, __val);
  return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::operator>> (unsigned long long& __val) {
  ::std::priv:: __get_num(*this, __val);
  return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::operator>> (float& __val) {
  ::std::priv:: __get_num(*this, __val);
  return *this;
}
template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::operator>> (double& __val) {
  ::std::priv:: __get_num(*this, __val);
  return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::operator>> (long double& __val) {
  ::std::priv:: __get_num(*this, __val);
  return *this;
}


template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::operator>> (bool& __val) {
  ::std::priv:: __get_num(*this, __val);
  return *this;
}


template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::operator>> (void*& __val) {
  ::std::priv:: __get_num(*this, __val);
  return *this;
}



template <class _CharT, class _Traits>
typename basic_istream<_CharT, _Traits>::int_type
basic_istream<_CharT, _Traits>::peek() {
  typename _Traits::int_type __tmp = _Traits::eof();

  this->_M_gcount = 0;
  sentry __sentry(*this, _No_Skip_WS());

  if (__sentry) {
    {
      __tmp = this->rdbuf()->sgetc();
    }
    if (false) {
      this->_M_handle_exception(ios_base::badbit);
    }
    if (this->_S_eof(__tmp))
      this->setstate(ios_base::eofbit);
  }

  return __tmp;
}


template <class _CharT, class _Traits>
typename basic_istream<_CharT, _Traits>::int_type
basic_istream<_CharT, _Traits>::get() {
  typename _Traits::int_type __tmp = _Traits::eof();
  sentry __sentry(*this, _No_Skip_WS());
  this->_M_gcount = 0;

  if (__sentry) {
    {
      __tmp = this->rdbuf()->sbumpc();
    }
    if (false) {
      this->_M_handle_exception(ios_base::badbit);
    }

    if (!this->_S_eof(__tmp))
      this->_M_gcount = 1;
  }

  if (_M_gcount == 0)
    this->setstate(ios_base::eofbit | ios_base::failbit);

  return __tmp;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::get(_CharT& __c) {
  sentry __sentry(*this, _No_Skip_WS());
  this->_M_gcount = 0;

  if (__sentry) {
    typename _Traits::int_type __tmp = _Traits::eof();
    {
      __tmp = this->rdbuf()->sbumpc();
    }
    if (false) {
      this->_M_handle_exception(ios_base::badbit);
    }

    if (!this->_S_eof(__tmp)) {
      this->_M_gcount = 1;
      __c = _Traits::to_char_type(__tmp);
    }
  }

  if (this->_M_gcount == 0)
    this->setstate(ios_base::eofbit | ios_base::failbit);

  return *this;
}






template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::ignore() {
  sentry __sentry(*this, _No_Skip_WS());
  this->_M_gcount = 0;

  if (__sentry) {
    int_type __c;
    {
      __c = this->rdbuf()->sbumpc();
    }
    if (false) {
      this->_M_handle_exception(ios_base::badbit);
      return *this;
    }

    if (!this->_S_eof(__c))
      this->_M_gcount = 1;
    else
      this->setstate(ios_base::eofbit);
  }

  return *this;
}



template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::putback(_CharT __c) {
  this->_M_gcount = 0;
  sentry __sentry(*this, _No_Skip_WS());

  if (__sentry) {
    typename _Traits::int_type __tmp = _Traits::eof();
    basic_streambuf<_CharT, _Traits>* __buf = this->rdbuf();

    if (__buf) {
      {
        __tmp = __buf->sputbackc(__c);
      }
      if (false) {
        this->_M_handle_exception(ios_base::badbit);
      }
    }
    if (this->_S_eof(__tmp))
      this->setstate(ios_base::badbit);
  }
  else
    this->setstate(ios_base::failbit);

  return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::unget() {
  this->_M_gcount = 0;

  sentry __sentry(*this, _No_Skip_WS());

  if (__sentry) {
    basic_streambuf<_CharT, _Traits>* __buf = this->rdbuf();

    if (__buf) {
      {
        if (this->_S_eof(__buf->sungetc()))
          this->setstate(ios_base::badbit);
      }
      if (false) {
        this->_M_handle_exception(ios_base::badbit);
      }
    } else
      this->setstate(ios_base::badbit);
  }
  else
    this->setstate(ios_base::failbit);

  return *this;
}



template <class _CharT, class _Traits>
int basic_istream<_CharT, _Traits>::sync() {
  sentry __sentry(*this, _No_Skip_WS());

  basic_streambuf<_CharT, _Traits>* __buf = this->rdbuf();
  if (__buf) {
    if (__buf->pubsync() == -1) {
      this->setstate(ios_base::badbit);
      return -1;
    }
    else
      return 0;
  }
  else
    return -1;
}

template <class _CharT, class _Traits>
typename basic_istream<_CharT, _Traits>::pos_type
basic_istream<_CharT, _Traits>::tellg() {
  sentry __sentry(*this, _No_Skip_WS());

  basic_streambuf<_CharT, _Traits>* __buf = this->rdbuf();
  return (__buf && !this->fail()) ? __buf->pubseekoff(0, ios_base::cur, ios_base::in)
    : pos_type(-1);
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::seekg(pos_type __pos) {
  sentry __sentry(*this, _No_Skip_WS());

  basic_streambuf<_CharT, _Traits>* __buf = this->rdbuf();
  if (!this->fail() && __buf) {
    if (__buf->pubseekpos(__pos, ios_base::in) == pos_type(-1)) {
      this->setstate(ios_base::failbit);
    }
  }
  return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::seekg(off_type __off, ios_base::seekdir __dir) {
  sentry __sentry(*this, _No_Skip_WS());

  basic_streambuf<_CharT, _Traits>* __buf = this->rdbuf();
  if (!this->fail() && __buf)
    __buf->pubseekoff(__off, __dir, ios_base::in);
  return *this;
}



template <class _CharT, class _Traits>
void basic_istream<_CharT, _Traits>::_M_formatted_get(_CharT& __c) {


  sentry __sentry(*this);

  if (__sentry) {
    typename _Traits::int_type __tmp;

    {
      __tmp = this->rdbuf()->sbumpc();
    }
    if (false) {
      this->_M_handle_exception(ios_base::badbit);
      return;
    }

    if (!this->_S_eof(__tmp))
      __c = _Traits::to_char_type(__tmp);
    else
      this->setstate(ios_base::eofbit | ios_base::failbit);
  }
}
# 575 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_istream.c"
namespace priv {

template < class _CharT, class _Traits, class _Is_Delim>
streamsize
__read_unbuffered(basic_istream<_CharT, _Traits>* __that, basic_streambuf<_CharT, _Traits>* __buf,
                  streamsize _Num, _CharT* __s,
                  _Is_Delim __is_delim,
                  bool __extract_delim, bool __append_null,
                  bool __is_getline)
{
  streamsize __n = 0;
  ios_base::iostate __status = 0;

  typedef typename basic_istream<_CharT, _Traits>::int_type int_type;

  {
    for (;;) {
      if (__n == _Num) {
        if (__is_getline)
          __status |= ios_base::failbit;
        break;
      }
      int_type __c = __buf->sbumpc();

      if (__that->_S_eof(__c)) {
        if (__n < _Num || __is_getline)
          __status |= ios_base::eofbit;
        break;
      } else if (__is_delim(_Traits::to_char_type(__c))) {
        if (__extract_delim) {
          ++__n;
        } else if ( !__pushback(__buf, _Traits::to_char_type(__c)) ) {
          __status |= ios_base::failbit;
        }
        break;
      }

      *__s++ = _Traits::to_char_type(__c);
      ++__n;
    }
  }
  if (false) {
    __that->_M_handle_exception(ios_base::badbit);
    *__s = _CharT();
    return __n;
  }

  if (__append_null)
    *__s = _CharT();
  if (__status)
    __that->setstate(__status);
  return __n;
}





template < class _CharT, class _Traits, class _Is_Delim, class _Scan_Delim>
streamsize
__read_buffered(basic_istream<_CharT, _Traits>* __that, basic_streambuf<_CharT, _Traits>* __buf,
                 streamsize _Num, _CharT* __s,
                 _Is_Delim __is_delim, _Scan_Delim __scan_delim,
                 bool __extract_delim, bool __append_null,
                 bool __is_getline) {
  streamsize __n = 0;
  ios_base::iostate __status = 0;
  bool __done = false;

  {
    while (__buf->_M_egptr() != __buf->_M_gptr() && !__done) {
      const _CharT* __first = __buf->_M_gptr();
      const _CharT* __last = __buf->_M_egptr();


      typedef char __static_assert[(sizeof(streamsize) > sizeof(ptrdiff_t)) || ((sizeof(streamsize) == sizeof(ptrdiff_t)) && numeric_limits<ptrdiff_t>::is_signed) ? 1 : -1];

      ptrdiff_t __request = static_cast<ptrdiff_t>((min) (static_cast<streamsize>((numeric_limits<ptrdiff_t>::max)()), _Num - __n));

      const _CharT* __p = __scan_delim(__first, __last);
      ptrdiff_t __chunk = (min) (ptrdiff_t(__p - __first), __request);
      _Traits::copy(__s, __first, __chunk);
      __s += __chunk;
      __n += __chunk;
      __buf->_M_gbump((int)__chunk);


      if (__p != __last && __p - __first <= __request) {
        if (__extract_delim) {
          __n += 1;
          __buf->_M_gbump(1);
        }
        __done = true;
      }


      else if (__n == _Num) {


        if (__is_getline) {
          if (__chunk == __last - __first) {
            if (__that->_S_eof(__buf->sgetc()))
              __status |= ios_base::eofbit;
          }
          else
            __status |= ios_base::failbit;
        }
        __done = true;
      }



      else {
        if (__that->_S_eof(__buf->sgetc())) {
          __status |= ios_base::eofbit;
          __done = true;
        }
      }
    }
  }
  if (false) {
    __that->_M_handle_exception(ios_base::badbit);
    __done = true;
  }

  if (__done) {
    if (__append_null)
        *__s = _CharT();
    if (__status != 0)
      __that->setstate(__status);
    return __n;
  }






  return __n + __read_unbuffered(__that, __buf, _Num - __n, __s, __is_delim,
                                 __extract_delim,__append_null,__is_getline);
}

}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::get(_CharT* __s, streamsize __n,
                                    _CharT __delim) {
  sentry __sentry(*this, _No_Skip_WS());
  this->_M_gcount = 0;

  if (__sentry) {
    if (__n > 0) {
      basic_streambuf<_CharT, _Traits>* __buf = this->rdbuf();

      if (__buf->egptr() != __buf->gptr())
        this->_M_gcount =
          ::std::priv:: __read_buffered(this, __buf, __n - 1, __s,
                                     ::std::priv:: _Eq_char_bound<_Traits>(__delim),
                                     ::std::priv:: _Scan_for_char_val<_Traits>(__delim),
                                     false, true, false);
      else
        this->_M_gcount =
          ::std::priv:: __read_unbuffered(this, __buf, __n - 1, __s,
                                       ::std::priv:: _Eq_char_bound<_Traits>(__delim),
                                       false, true, false);
    }
  }

  if (this->_M_gcount == 0)
    this->setstate(ios_base::failbit);

  return *this;
}



template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::getline(_CharT* __s, streamsize __n,
                                        _CharT __delim) {
  sentry __sentry(*this, _No_Skip_WS());
  this->_M_gcount = 0;

  if (__sentry) {
    if (__n > 0) {
      basic_streambuf<_CharT, _Traits>* __buf = this->rdbuf();
      this->_M_gcount = __buf->egptr() != __buf->gptr()
        ? ::std::priv:: __read_buffered(this, __buf, __n - 1, __s,
                                     ::std::priv:: _Eq_char_bound<_Traits>(__delim),
                                     ::std::priv:: _Scan_for_char_val<_Traits>(__delim),
                                     true, true, true)
        : ::std::priv:: __read_unbuffered(this, __buf, __n - 1, __s,
                                       ::std::priv:: _Eq_char_bound<_Traits>(__delim),
                                       true, true, true);
    }
  }

  if (this->_M_gcount == 0)
    this->setstate(ios_base::failbit);

  return *this;
}



template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::read(char_type* __s, streamsize __n) {
  sentry __sentry(*this, _No_Skip_WS());
  this->_M_gcount = 0;

  if (__sentry && !this->eof()) {
    basic_streambuf<_CharT, _Traits>*__buf = this->rdbuf();
    if (__buf->gptr() != __buf->egptr())
      _M_gcount
        = ::std::priv:: __read_buffered(this, __buf, __n, __s,
                                     ::std::priv:: _Constant_unary_fun<bool, int_type>(false),
                                     ::std::priv:: _Project2nd<const _CharT*, const _CharT*>(),
                                     false, false, false);
    else
      _M_gcount
        = ::std::priv:: __read_unbuffered(this, __buf, __n, __s,
                                       ::std::priv:: _Constant_unary_fun<bool, int_type>(false),
                                       false, false, false);
  }
  else
    this->setstate(ios_base::failbit);

  if (this->eof())
    this->setstate(ios_base::eofbit | ios_base::failbit);

  return *this;
}




template <class _CharT, class _Traits>
streamsize
basic_istream<_CharT, _Traits>::readsome(char_type* __s, streamsize __nmax) {
  sentry __sentry(*this, _No_Skip_WS());
  this->_M_gcount = 0;

  if (__sentry && !this->eof() && __nmax >= 0) {

    basic_streambuf<_CharT, _Traits>* __buf = this->rdbuf();
    streamsize __avail = __buf->in_avail();


    if (__avail == -1)
      this->_M_setstate_nothrow(ios_base::eofbit);

    else if (__avail != 0) {

      if (__buf->gptr() != __buf->egptr())
        _M_gcount
          = ::std::priv:: __read_buffered(this, __buf, (min) (__avail, __nmax), __s,
                                       ::std::priv:: _Constant_unary_fun<bool, int_type>(false),
                                       ::std::priv:: _Project2nd<const _CharT*, const _CharT*>(),
                                       false, false, false);
      else
        _M_gcount
          = ::std::priv:: __read_unbuffered(this, __buf, (min) (__avail, __nmax), __s,
                                         ::std::priv:: _Constant_unary_fun<bool, int_type>(false),
                                         false, false, false);
    }
  }
  else {

    if (this->eof())
      this->setstate(ios_base::eofbit | ios_base::failbit);
    else
      this->setstate(ios_base::failbit);
  }




  return _M_gcount;
}

template <class _CharT, class _Traits>
void basic_istream<_CharT, _Traits>::_M_formatted_get(_CharT* __s) {
  sentry __sentry(*this);

  if (__sentry) {
    basic_streambuf<_CharT, _Traits>* __buf = this->rdbuf();
    streamsize __nmax = this->width() > 0
      ? this->width() - 1
      : ((numeric_limits<streamsize>::max)() / sizeof(_CharT)) - 1;

    streamsize __n = __buf->gptr() != __buf->egptr()
      ? ::std::priv:: __read_buffered(this, __buf, __nmax, __s,
                                   ::std::priv:: _Is_wspace_null<_Traits>(this->_M_ctype_facet()),
                                   ::std::priv:: _Scan_wspace_null<_Traits>(this->_M_ctype_facet()),
                                   false, true, false)
      : ::std::priv:: __read_unbuffered(this, __buf, __nmax, __s,
                                     ::std::priv:: _Is_wspace_null<_Traits>(this->_M_ctype_facet()),
                                     false, true, false);
    if (__n == 0)
      this->setstate(ios_base::failbit);
  }
  this->width(0);
}






template < class _CharT, class _Traits, class _Is_Delim>
void
_M_ignore_unbuffered(basic_istream<_CharT, _Traits>* __that,
                     basic_streambuf<_CharT, _Traits>* __buf,
                     _Is_Delim __is_delim,
                     bool __extract_delim, bool __set_failbit) {
  bool __done = false;
  ios_base::iostate __status = 0;
  typedef typename basic_istream<_CharT, _Traits>::int_type int_type;

  {
    while (!__done) {
      int_type __c = __buf->sbumpc();

      if (__that->_S_eof(__c)) {
        __done = true;
        __status |= __set_failbit ? ios_base::eofbit | ios_base::failbit
                                  : ios_base::eofbit;
      }

      else if (__is_delim(_Traits::to_char_type(__c))) {
        __done = true;
        if (!__extract_delim)
          if (__that->_S_eof(__buf->sputbackc(_Traits::to_char_type(__c))))
            __status |= ios_base::failbit;
      }
    }
  }
  if (false) {
    __that->_M_handle_exception(ios_base::badbit);
  }

  __that->setstate(__status);
}






template < class _CharT, class _Traits, class _Is_Delim, class _Scan_Delim>
void
_M_ignore_buffered(basic_istream<_CharT, _Traits>* __that,
                   basic_streambuf<_CharT, _Traits>* __buf,
                   _Is_Delim __is_delim, _Scan_Delim __scan_delim,
                   bool __extract_delim, bool __set_failbit) {
  bool __at_eof = false;
  bool __found_delim = false;

  {
    while (__buf->_M_egptr() != __buf->_M_gptr() && !__at_eof && !__found_delim) {
      const _CharT* __p = __scan_delim(__buf->_M_gptr(), __buf->_M_egptr());
      __buf->_M_gbump((int)(__p - __buf->_M_gptr()));

      if (__p != __buf->_M_egptr()) {
        if (__extract_delim)
          __buf->_M_gbump(1);
        __found_delim = true;
      }

      else
        __at_eof = __that->_S_eof(__buf->sgetc());
    }
  }
  if (false) {
    __that->_M_handle_exception(ios_base::badbit);
    return;
  }

  if (__at_eof) {
    __that->setstate(__set_failbit ? ios_base::eofbit | ios_base::failbit
                                   : ios_base::eofbit);
    return;
  }
  if (__found_delim)
    return;





  _M_ignore_unbuffered(__that, __buf, __is_delim, __extract_delim, __set_failbit);
}
# 981 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_istream.c"
template < class _CharT, class _Traits, class _Max_Chars, class _Is_Delim>
streamsize
_M_ignore_unbuffered(basic_istream<_CharT, _Traits>* __that,
                     basic_streambuf<_CharT, _Traits>* __buf,
                     streamsize _Num, _Max_Chars __max_chars,
                     _Is_Delim __is_delim,
                     bool __extract_delim, bool __set_failbit) {
  streamsize __n = 0;
  ios_base::iostate __status = 0;
  typedef typename basic_istream<_CharT, _Traits>::int_type int_type;

  {
    while (__max_chars(_Num, __n) > 0) {
      int_type __c = __buf->sbumpc();

      if (__that->_S_eof(__c)) {
        __status |= __set_failbit ? ios_base::eofbit | ios_base::failbit
                                  : ios_base::eofbit;
        break;
      }

      else if (__is_delim(_Traits::to_char_type(__c))) {
        if (__extract_delim)
          ++__n;
        else if (__that->_S_eof(__buf->sputbackc(_Traits::to_char_type(__c))))
          __status |= ios_base::failbit;

        break;
      }

      ++__n;
    }
  }
  if (false) {
    __that->_M_handle_exception(ios_base::badbit);
  }

  if (__status)
    __that->setstate(__status);
  return __n;
}

template < class _CharT, class _Traits, class _Max_Chars, class _Is_Delim, class _Scan_Delim>
streamsize
_M_ignore_buffered(basic_istream<_CharT, _Traits>* __that,
                   basic_streambuf<_CharT, _Traits>* __buf,
                   streamsize _Num,
                   _Max_Chars __max_chars,
                   _Is_Delim __is_delim, _Scan_Delim __scan_delim,
                   bool __extract_delim, bool __set_failbit) {
  streamsize __n = 0;
  bool __at_eof = false;
  bool __done = false;

  {
    while (__buf->_M_egptr() != __buf->_M_gptr() && !__done) {
      ptrdiff_t __avail = __buf->_M_egptr() - __buf->_M_gptr();
      streamsize __m = __max_chars(_Num, __n);

      if (__avail >= __m) {
        const _CharT* __last = __buf->_M_gptr() + static_cast<ptrdiff_t>(__m);
        const _CharT* __p = __scan_delim(__buf->_M_gptr(), __last);
        ptrdiff_t __chunk = __p - __buf->_M_gptr();
        __n += __chunk;
        __buf->_M_gbump((int)__chunk);

        if (__extract_delim && __p != __last) {
          __n += 1;
          __buf->_M_gbump(1);
        }

        __done = true;
      }

      else {
        const _CharT* __p = __scan_delim(__buf->_M_gptr(), __buf->_M_egptr());
        ptrdiff_t __chunk = __p - __buf->_M_gptr();
        __n += __chunk;
        __buf->_M_gbump((int)__chunk);

        if (__p != __buf->_M_egptr()) {
          if (__extract_delim) {
            __n += 1;
            __buf->_M_gbump(1);
          }

          __done = true;
        }


        else if (__that->_S_eof(__buf->sgetc())) {
          __done = true;
          __at_eof = true;
        }
      }
    }
  }
  if (false) {
    __that->_M_handle_exception(ios_base::badbit);
    return __n;
  }

  if (__at_eof)
    __that->setstate(__set_failbit ? ios_base::eofbit | ios_base::failbit
                                   : ios_base::eofbit);

  if (__done)
    return __n;






  return __n + _M_ignore_unbuffered(__that, __buf, _Num, __max_chars,
                                    __is_delim, __extract_delim, __set_failbit);
}


template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::ignore(streamsize __n) {
  sentry __sentry(*this, _No_Skip_WS());
  this->_M_gcount = 0;

  if (__sentry) {
    basic_streambuf<_CharT, _Traits>* __buf = this->rdbuf();
    typedef ::std::priv:: _Constant_unary_fun<bool, int_type> _Const_bool;
    typedef ::std::priv:: _Constant_binary_fun<streamsize, streamsize, streamsize> _Const_streamsize;
    const streamsize __maxss = (numeric_limits<streamsize>::max)();

    if (__n == (numeric_limits<int>::max)()) {
      if (__buf->gptr() != __buf->egptr())
        _M_gcount = _M_ignore_buffered(this, __buf,
                                       __maxss, _Const_streamsize(__maxss),
                                       _Const_bool(false),
                                       ::std::priv:: _Project2nd<const _CharT*, const _CharT*>(),
                                       false, false);
      else
        _M_gcount = _M_ignore_unbuffered(this, __buf,
                                         __maxss, _Const_streamsize(__maxss),
                                         _Const_bool(false), false, false);
    }
    else {
      if (__buf->gptr() != __buf->egptr())
        _M_gcount = _M_ignore_buffered(this, __buf,
                                       __n, minus<streamsize>(),
                                       _Const_bool(false),
                                       ::std::priv:: _Project2nd<const _CharT*, const _CharT*>(),
                                       false, false);
      else
        _M_gcount = _M_ignore_unbuffered(this, __buf, __n, minus<streamsize>(),
                                         _Const_bool(false), false, false);
    }
  }

  return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::ignore(streamsize __n, int_type __delim) {
  sentry __sentry(*this, _No_Skip_WS());
  this->_M_gcount = 0;

  if (__sentry) {
    basic_streambuf<_CharT, _Traits>* __buf = this->rdbuf();
    typedef ::std::priv:: _Constant_unary_fun<bool, int_type> _Const_bool;
    typedef ::std::priv:: _Constant_binary_fun<streamsize, streamsize, streamsize>
      _Const_streamsize;
    const streamsize __maxss = (numeric_limits<streamsize>::max)();

    if (__n == (numeric_limits<int>::max)()) {
      if (__buf->gptr() != __buf->egptr())
        _M_gcount = _M_ignore_buffered(this, __buf,
                                       __maxss, _Const_streamsize(__maxss),
                                       ::std::priv:: _Eq_int_bound<_Traits>(__delim),
                                       ::std::priv:: _Scan_for_int_val<_Traits>(__delim),
                                       true, false);
      else
        _M_gcount = _M_ignore_unbuffered(this, __buf,
                                         __maxss, _Const_streamsize(__maxss),
                                         ::std::priv:: _Eq_int_bound<_Traits>(__delim),
                                         true, false);
    }
    else {
      if (__buf->gptr() != __buf->egptr())
        _M_gcount = _M_ignore_buffered(this, __buf,
                                       __n, minus<streamsize>(),
                                       ::std::priv:: _Eq_int_bound<_Traits>(__delim),
                                       ::std::priv:: _Scan_for_int_val<_Traits>(__delim),
                                       true, false);
      else
        _M_gcount = _M_ignore_unbuffered(this, __buf, __n, minus<streamsize>(),
                                         ::std::priv:: _Eq_int_bound<_Traits>(__delim),
                                         true, false);
    }
  }

  return *this;
}



template <class _CharT, class _Traits>
void basic_istream<_CharT, _Traits>::_M_skip_whitespace(bool __set_failbit) {
  basic_streambuf<_CharT, _Traits>* __buf = this->rdbuf();
  if (!__buf)
    this->setstate(ios_base::badbit);
  else if (__buf->gptr() != __buf->egptr())
    _M_ignore_buffered(this, __buf,
                       ::std::priv:: _Is_not_wspace<_Traits>(this->_M_ctype_facet()),
                       ::std::priv:: _Scan_for_not_wspace<_Traits>(this->_M_ctype_facet()),
                       false, __set_failbit);
  else
    _M_ignore_unbuffered(this, __buf,
                         ::std::priv:: _Is_not_wspace<_Traits>(this->_M_ctype_facet()),
                         false, __set_failbit);
}
# 1209 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_istream.c"
namespace priv {

template < class _CharT, class _Traits, class _Is_Delim>
streamsize
__copy_unbuffered(basic_istream<_CharT, _Traits>* __that, basic_streambuf<_CharT, _Traits>* __src,
                  basic_streambuf<_CharT, _Traits>* __dest,
                  _Is_Delim __is_delim,
                  bool __extract_delim, bool __rethrow) {
  streamsize __extracted = 0;
  ios_base::iostate __status = 0;
  typedef typename basic_istream<_CharT, _Traits>::int_type int_type;
  int_type __c;

  {
    for (;;) {

      __c = __src->sbumpc();


      if (__that->_S_eof(__c)) {
        __status |= ios_base::eofbit;
        break;
      }

      else if (__is_delim(_Traits::to_char_type(__c))) {
        if (!__extract_delim && !__pushback(__src, _Traits::to_char_type(__c)))
          __status |= ios_base::failbit;
        break;
      }
      else {

        bool __failed = false;
        {
          if (!__that->_S_eof(__dest->sputc(_Traits::to_char_type(__c))))
            ++__extracted;
          else
            __failed = true;
        }
        if (false) {
          __failed = true;
        }



        if (__failed && !__pushback(__src, _Traits::to_char_type(__c)))
          __status |= ios_base::failbit;


        if (__failed)
          break;
      }

    }

  }


  if (false) {

    if (__rethrow && __extracted == 0)
      __that->_M_handle_exception(ios_base::failbit);
  }
  __that->setstate(__status);
  return __extracted;
}






template < class _CharT, class _Traits, class _Is_Delim, class _Scan_Delim>
streamsize
__copy_buffered(basic_istream<_CharT, _Traits>* __that, basic_streambuf<_CharT, _Traits>* __src,
                basic_streambuf<_CharT, _Traits>* __dest,
                _Scan_Delim __scan_delim, _Is_Delim __is_delim,
                bool __extract_delim, bool __rethrow) {
  streamsize __extracted = 0;
  ios_base::iostate __status = 0;
  typedef typename basic_istream<_CharT, _Traits>::int_type int_type;

  int_type __c ;
  _CharT* __first = __src->_M_gptr();
  ptrdiff_t __avail = __src->_M_egptr() - __first;

  bool __do_handle_exceptions = false;

  {
    for (;;) {
      const _CharT* __last = __scan_delim(__first, __src->_M_egptr());


      streamsize __n = __dest->sputn(__first, __extract_delim && __last != __src->_M_egptr()
                                     ? (__last - __first) + 1
                                     : (__last - __first));
      __src->_M_gbump((int)__n);
      __extracted += __n;


      __do_handle_exceptions = true;

      if (__n < __avail)
        break;

      __c = __src->sgetc();



      __first = __src->_M_gptr();
      __avail = __src->_M_egptr() - __first;

      if (__avail > 0)
        {}
      else if (__that->_S_eof(__c)) {
        __status |= ios_base::eofbit;
        break;
      }
      else {
        return __extracted + __copy_unbuffered(__that, __src, __dest, __is_delim,
                                                __extract_delim, __rethrow);
      }

      __do_handle_exceptions = false;
    }
  }

  if (false) {

    if (__rethrow && __do_handle_exceptions && __extracted == 0)
      __that->_M_handle_exception(ios_base::failbit);
  }

  if (__status)
    __that->setstate(__status);
  return __extracted;
}

}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>
  ::get(basic_streambuf<_CharT, _Traits>& __dest, _CharT __delim) {
  sentry __sentry(*this, _No_Skip_WS());
  this->_M_gcount = 0;

  if (__sentry) {
    basic_streambuf<_CharT, _Traits>* __src = this->rdbuf();

    if (__src)
      this->_M_gcount = __src->egptr() != __src->gptr()
        ? ::std::priv:: __copy_buffered(this, __src, &__dest,
                                     ::std::priv:: _Scan_for_char_val<_Traits>(__delim),
                                     ::std::priv:: _Eq_char_bound<_Traits>(__delim),
                                     false, false)
        : ::std::priv:: __copy_unbuffered(this, __src, &__dest,
                                       ::std::priv:: _Eq_char_bound<_Traits>(__delim),
                                       false, false);
  }

  if (this->_M_gcount == 0)
    this->setstate(ios_base::failbit);

  return *this;
}


template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>
  ::operator>>(basic_streambuf<_CharT, _Traits>* __dest) {
  streamsize __n = 0;
  typedef typename basic_istream<_CharT, _Traits>::sentry _Sentry;
  _Sentry __sentry(*this);
  if (__sentry) {
    basic_streambuf<_CharT, _Traits>* __src = this->rdbuf();
    if (__src && __dest)
      __n = __src->egptr() != __src->gptr()
        ? ::std::priv:: __copy_buffered(this, __src, __dest,
                                     ::std::priv:: _Project2nd<const _CharT*, const _CharT*>(),
                                     ::std::priv:: _Constant_unary_fun<bool, int_type>(false),
                                     false, true)
        : ::std::priv:: __copy_unbuffered(this, __src, __dest,
                                       ::std::priv:: _Constant_unary_fun<bool, int_type>(false),
                                       false, true);
  }

  if (__n == 0)
    this->setstate(ios_base::failbit);

  return *this;
}





template <class _CharT, class _Traits>
basic_iostream<_CharT, _Traits>
  ::basic_iostream(basic_streambuf<_CharT, _Traits>* __buf)
    : basic_ios<_CharT, _Traits>(),
      basic_istream<_CharT, _Traits>(__buf),
      basic_ostream<_CharT, _Traits>(__buf) {
  this->init(__buf);
}

template <class _CharT, class _Traits>
basic_iostream<_CharT, _Traits>::~basic_iostream()
{}

}
# 353 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_istream.h" 2
# 28 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_string_io.h" 2



namespace std {

template <class _CharT, class _Traits, class _Alloc>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os,
           const basic_string<_CharT,_Traits,_Alloc>& __s);
# 50 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_string_io.h"
template <class _CharT, class _Traits, class _Alloc>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is,
           basic_string<_CharT,_Traits,_Alloc>& __s);

template <class _CharT, class _Traits, class _Alloc>
basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT,_Traits,_Alloc>& __s,
        _CharT __delim);



template <class _CharT, class _Traits, class _Alloc>
inline basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT,_Traits,_Alloc>& __s) {
  return getline(__is, __s, __is.widen('\n'));
}


}


# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_string_io.c" 1
# 12 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_string_io.c"
namespace std {

template <class _CharT, class _Traits>
bool
__stlp_string_fill(basic_ostream<_CharT, _Traits>& __os,
                   basic_streambuf<_CharT, _Traits>* __buf,
                   streamsize __n) {
  _CharT __f = __os.fill();
  for (streamsize __i = 0; __i < __n; ++__i) {
    if (_Traits::eq_int_type(__buf->sputc(__f), _Traits::eof()))
      return false;
  }
  return true;
}


template <class _CharT, class _Traits, class _Alloc>
basic_ostream<_CharT, _Traits>&
operator << (basic_ostream<_CharT, _Traits>& __os,
             const basic_string<_CharT,_Traits,_Alloc>& __s) {
  typedef basic_ostream<_CharT, _Traits> __ostream;
  typedef typename basic_string<_CharT, _Traits, _Alloc>::size_type size_type;


  typedef char __static_assert[static_cast<size_type>(-1) > 0 ? 1 : -1];

  typename __ostream::sentry __sentry(__os);
  bool __ok = false;

  if (__sentry) {
    __ok = true;
    size_type __n = __s.size();
    const bool __left = (__os.flags() & __ostream::left) != 0;
    const streamsize __w = __os.width(0);
    basic_streambuf<_CharT, _Traits>* __buf = __os.rdbuf();

    const bool __need_pad = (((sizeof(streamsize) > sizeof(size_t)) && (static_cast<streamsize>(__n) < __w)) ||
                             ((sizeof(streamsize) <= sizeof(size_t)) && (__n < static_cast<size_t>(__w))));
    streamsize __pad_len = __need_pad ? __w - __n : 0;

    if (!__left)
      __ok = __stlp_string_fill(__os, __buf, __pad_len);

    __ok = __ok && (__buf->sputn(__s.data(), streamsize(__n)) == streamsize(__n));

    if (__left)
      __ok = __ok && __stlp_string_fill(__os, __buf, __pad_len);
  }

  if (!__ok)
    __os.setstate(__ostream::failbit);

  return __os;
}

template <class _CharT, class _Traits, class _Alloc>
basic_istream<_CharT, _Traits>&
operator >> (basic_istream<_CharT, _Traits>& __is,
             basic_string<_CharT,_Traits, _Alloc>& __s) {
  typedef basic_istream<_CharT, _Traits> __istream;
  typedef typename basic_string<_CharT, _Traits, _Alloc>::size_type size_type;


  typedef char __static_assert[static_cast<size_type>(-1) > 0 ? 1 : -1];

  typename __istream::sentry __sentry(__is);

  if (__sentry) {
    basic_streambuf<_CharT, _Traits>* __buf = __is.rdbuf();
    typedef ctype<_CharT> _C_type;

    const locale& __loc = __is.getloc();
    const _C_type& _Ctype = use_facet<_C_type>(__loc);
    __s.clear();
    streamsize __width = __is.width(0);
    size_type __n;
    if (__width <= 0)
      __n = __s.max_size();




    else if (sizeof(streamsize) > sizeof(size_type) &&
             (__width > static_cast<streamsize>(__s.max_size())))
      __n = 0;
    else {
      __n = static_cast<size_type>(__width);
      __s.reserve(__n);
    }

    while (__n-- > 0) {
      typename _Traits::int_type __c1 = __buf->sbumpc();
      if (_Traits::eq_int_type(__c1, _Traits::eof())) {
        __is.setstate(__istream::eofbit);
        break;
      }
      else {
        _CharT __c = _Traits::to_char_type(__c1);

        if (_Ctype.is(_C_type::space, __c)) {
          if (_Traits::eq_int_type(__buf->sputbackc(__c), _Traits::eof()))
            __is.setstate(__istream::failbit);
          break;
        }
        else
          __s.push_back(__c);
      }
    }


    if (__s.empty())
      __is.setstate(__istream::failbit);
  }
  else
    __is.setstate(__istream::failbit);

  return __is;
}

template <class _CharT, class _Traits, class _Alloc>
basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT,_Traits,_Alloc>& __s,
        _CharT __delim) {
  typedef basic_istream<_CharT, _Traits> __istream;
  typedef typename basic_string<_CharT, _Traits, _Alloc>::size_type size_type;
  size_type __nread = 0;
  typename basic_istream<_CharT, _Traits>::sentry __sentry(__is, true);
  if (__sentry) {
    basic_streambuf<_CharT, _Traits>* __buf = __is.rdbuf();
    __s.clear();

    while (__nread < __s.max_size()) {
      int __c1 = __buf->sbumpc();
      if (_Traits::eq_int_type(__c1, _Traits::eof())) {
        __is.setstate(__istream::eofbit);
        break;
      }
      else {
        ++__nread;
        _CharT __c = _Traits::to_char_type(__c1);
        if (!_Traits::eq(__c, __delim))
          __s.push_back(__c);
        else
          break;
      }
    }
  }
  if (__nread == 0 || __nread >= __s.max_size())
    __is.setstate(__istream::failbit);

  return __is;
}

}
# 75 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_string_io.h" 2
# 38 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/string" 2
# 50 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/string"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_epilog.h" 1
# 19 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_epilog.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_config_compat_post.h" 1
# 20 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_epilog.h" 2
# 51 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/string" 2
# 7 "webkey-2.09/service/kcm.h" 2
# 1 "webkey-2.09/service/ByteOrder.h" 1
# 41 "webkey-2.09/service/ByteOrder.h"
static inline uint32_t android_swap_long(uint32_t v)
{
    return (v<<24) | ((v<<8)&0x00FF0000) | ((v>>8)&0x0000FF00) | (v>>24);
}

static inline uint16_t android_swap_short(uint16_t v)
{
    return (v<<8) | (v>>8);
}
# 8 "webkey-2.09/service/kcm.h" 2

using namespace std;

enum {
    LENDIAN,
    BENDIAN
};
# 24 "webkey-2.09/service/kcm.h"
struct KeyRecord
{
    int lineno;
    int values[(3+4)];
};

struct PropValue
{
    PropValue() { lineno = -1; }
    PropValue(const PropValue& that) { lineno=that.lineno; value=that.value; }
    PropValue(int l, const string& v) { lineno = l; value = v; }

    int lineno;
    string value;
};

static int usage();



static int parse_key_line(const char* filename, int lineno, char* line,
        KeyRecord* out);
static int write_kr(int fd, const KeyRecord& kr);

int g_endian;

int
compile(const char* filename, char* outfilename)
{
    int err;

    int in = open(filename, 00000000);
    if (in == -1) {
        fprintf((&__sF[2]), "kcm: error opening file for read: %s\n", filename);
        return 1;
    }

    off_t size = lseek(in, 0, 2);
    lseek(in, 0, 0);

    char* input = (char*)malloc(size+1);
    read(in, input, size);
    input[size] = '\0';

    close(in);
    in = -1;

    map<string,PropValue> properties;
    map<int,KeyRecord> keys;
    int errorcount = 0;
    int lineno = 1;
    char *thisline = input;
    while (*thisline) {
        KeyRecord kr;
        char *nextline = thisline;

        while (*nextline != '\0' && *nextline != '\n' && *nextline != '\r') {
            nextline++;
        }


        while (*thisline != '\0' && (*thisline == ' ' || *thisline == '\t')) {
            thisline++;
        }


        char lineend = *nextline;
        *nextline = '\0';
        if (lineend == '\r' && nextline[1] == '\n') {
            nextline++;
        }

        if (*thisline == '\0' || *thisline == '\r' || *thisline == '\n'
                 || *thisline == '#') {

        }
        else if (*thisline == '[') {


            char* prop = thisline+1;
            char* end = prop;
            while (*end != '\0' && *end != '=') {
                end++;
            }
            if (*end != '=') {
                fprintf((&__sF[2]), "%s:%d: invalid property line: %s\n",
                        filename, lineno, thisline);
                errorcount++;
            } else {
                *end = '\0';
                char* value = end+1;
                end = nextline;
                while (end > prop && *end != ']') {
                    end--;
                }
                if (*end != ']') {
                    fprintf((&__sF[2]), "%s:%d: property missing closing ]: %s\n",
                            filename, lineno, thisline);
                    errorcount++;
                } else {
                    *end = '\0';
                    properties[prop] = PropValue(lineno, value);
                }
            }
        }
        else {

            err = parse_key_line(filename, lineno, thisline, &kr);
            if (err == 0) {
                kr.lineno = lineno;

                map<int,KeyRecord>::iterator old = keys.find(kr.values[0]);
                if (old != keys.end()) {
                    fprintf((&__sF[2]), "%s:%d: keycode %d already defined\n",
                            filename, lineno, kr.values[0]);
                    fprintf((&__sF[2]), "%s:%d: previously defined here\n",
                            filename, old->second.lineno);
                    errorcount++;
                }

                keys[kr.values[0]] = kr;
            }
            else if (err > 0) {
                errorcount += err;
            }
        }
        lineno++;

        nextline++;
        thisline = nextline;

        if (errorcount > 20) {
            fprintf((&__sF[2]), "%s:%d: too many errors.  stopping.\n", filename,
                    lineno);
            return 1;
        }
    }

    free(input);

    map<string,PropValue>::iterator sit = properties.find("type");
    if (sit == properties.end()) {
        fprintf((&__sF[2]), "key character map must contain type property.\n");
        errorcount++;
    }
    PropValue pv = sit->second;
    unsigned char kbdtype = 0;
    if (pv.value == "NUMERIC") {
        kbdtype = 1;
    }
    else if (pv.value == "Q14") {
        kbdtype = 2;
    }
    else if (pv.value == "QWERTY") {
        kbdtype = 3;
    }
    else {
        fprintf((&__sF[2]), "%s:%d: keyboard type must be one of NUMERIC, Q14 "
                " or QWERTY, not %s\n", filename, pv.lineno, pv.value.c_str());
    }

    if (errorcount != 0) {
        return 1;
    }

    int out = open(outfilename, 00000002|00000100|00001000, 0664);
    if (out == -1) {
        fprintf((&__sF[2]), "kcm: error opening file for write: %s\n", outfilename);
        return 1;
    }

    int count = keys.size();

    map<int,KeyRecord>::iterator it;
    int n;
# 211 "webkey-2.09/service/kcm.h"
    err = write(out, "keychar", 8);
    if (err == -1) goto bad_write;

    n = (0x12345678);
    err = write(out, &n, 4);
    if (err == -1) goto bad_write;

    n = (0x00000002);
    err = write(out, &n, 4);
    if (err == -1) goto bad_write;

    n = (count);
    err = write(out, &n, 4);
    if (err == -1) goto bad_write;

    err = write(out, &kbdtype, 1);
    if (err == -1) goto bad_write;

    char zero[11];
    memset(zero, 0, 11);
    err = write(out, zero, 11);
    if (err == -1) goto bad_write;

    for (it = keys.begin(); it != keys.end(); it++) {
        const KeyRecord& kr = it->second;





        err = write_kr(out, kr);
        if (err == -1) goto bad_write;
    }

    close(out);
    return 0;

bad_write:
    fprintf((&__sF[2]), "kcm: fatal error writing to file: %s\n", outfilename);
    close(out);
    unlink(outfilename);
    return 1;
}

static int usage()
{
    fprintf((&__sF[2]),
            "usage: kcm INPUT OUTPUT\n"
            "\n"
            "INPUT   keycharmap file\n"
            "OUTPUT  compiled keycharmap file\n"
        );
    return 1;
}

static int
is_whitespace(const char* p)
{
    while (*p) {
        if (!isspace(*p)) {
            return 0;
        }
        p++;
    }
    return 1;
}


static int
parse_keycode(const char* filename, int lineno, char* str, int* value)
{
    const KeycodeLabel *list = KEYCODES;
    while (list->literal) {
        if (0 == strcmp(str, list->literal)) {
            *value = list->value;
            return 0;
        }
        list++;
    }

    char* endptr;
    *value = strtol(str, &endptr, 0);
    if (*endptr != '\0') {
        fprintf((&__sF[2]), "%s:%d: expected keycode label or number near: "
                "%s\n", filename, lineno, str);
        return 1;
    }

    if (*value == 0) {
        fprintf((&__sF[2]), "%s:%d: 0 is not a valid keycode.\n",
                filename, lineno);
        return 1;
    }

    return 0;
}

static int
parse_number(const char* filename, int lineno, char* str, int* value)
{
    int len = strlen(str);

    if (len == 3 && str[0] == '\'' && str[2] == '\'') {
        if (str[1] > 0 && str[1] < 127) {
            *value = (int)str[1];
            return 0;
        } else {
            fprintf((&__sF[2]), "%s:%d: only low ascii characters are allowed in"
                    " quotes near: %s\n", filename, lineno, str);
            return 1;
        }
    }

    char* endptr;
    *value = strtol(str, &endptr, 0);
    if (*endptr != '\0') {
        fprintf((&__sF[2]), "%s:%d: expected number or quoted ascii but got: %s\n",
                filename, lineno, str);
        return 1;
    }

    if (*value >= 0xfffe || *value < 0) {
        fprintf((&__sF[2]), "%s:%d: unicode char out of range (no negatives, "
                "nothing larger than 0xfffe): %s\n", filename, lineno, str);
        return 1;
    }

    return 0;
}

static int
parse_key_line(const char* filename, int lineno, char* line, KeyRecord* out)
{
    char* p = line;

    int len = strlen(line);
    char* s[(3+4)];
    for (int i=0; i<(3+4); i++) {
        s[i] = (char*)malloc(len+1);
    }

    for (int i = 0; i < (3+4); i++) {
        while (*p != '\0' && isspace(*p)) {
            p++;
        }

        if (*p == '\0') {
            fprintf((&__sF[2]), "%s:%d: not enough on this line: %s\n", filename,
                    lineno, line);
            return 1;
        }

        char *p1 = p;
        while (*p != '\0' && !isspace(*p)) {
            p++;
        }

        memcpy(s[i], p1, p - p1);
        s[i][p - p1] = '\0';
    }

    while (*p != '\0' && isspace(*p)) {
        *p++;
    }
    if (*p != '\0') {
        fprintf((&__sF[2]), "%s:%d: too much on one line near: %s\n", filename,
                lineno, p);
        fprintf((&__sF[2]), "%s:%d: -->%s<--\n", filename, lineno, line);
        return 1;
    }

    int errorcount = parse_keycode(filename, lineno, s[0], &out->values[0]);
    for (int i=1; i<(3+4) && errorcount == 0; i++) {
        errorcount += parse_number(filename, lineno, s[i], &out->values[i]);
    }

    return errorcount;
}

struct WrittenRecord
{
    unsigned int keycode;
    unsigned short values[(3+4) - 1];

};

static int
write_kr(int fd, const KeyRecord& kr)
{
    WrittenRecord wr;

    wr.keycode = (kr.values[0]);
    for (int i=0; i<(3+4) - 1; i++) {
        wr.values[i] = (kr.values[i+1]);
    }

    return write(fd, &wr, sizeof(WrittenRecord));
}
# 62 "webkey-2.09/service/webkey.cpp" 2

# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/linux/fb.h" 1
# 138 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/linux/fb.h"
struct fb_fix_screeninfo {
 char id[16];
 unsigned long smem_start;

 __u32 smem_len;
 __u32 type;
 __u32 type_aux;
 __u32 visual;
 __u16 xpanstep;
 __u16 ypanstep;
 __u16 ywrapstep;
 __u32 line_length;
 unsigned long mmio_start;

 __u32 mmio_len;
 __u32 accel;

 __u16 reserved[3];
};

struct fb_bitfield {
 __u32 offset;
 __u32 length;
 __u32 msb_right;

};
# 205 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/linux/fb.h"
struct fb_var_screeninfo {
 __u32 xres;
 __u32 yres;
 __u32 xres_virtual;
 __u32 yres_virtual;
 __u32 xoffset;
 __u32 yoffset;

 __u32 bits_per_pixel;
 __u32 grayscale;

 struct fb_bitfield red;
 struct fb_bitfield green;
 struct fb_bitfield blue;
 struct fb_bitfield transp;

 __u32 nonstd;

 __u32 activate;

 __u32 height;
 __u32 width;

 __u32 accel_flags;

 __u32 pixclock;
 __u32 left_margin;
 __u32 right_margin;
 __u32 upper_margin;
 __u32 lower_margin;
 __u32 hsync_len;
 __u32 vsync_len;
 __u32 sync;
 __u32 vmode;
 __u32 rotate;
 __u32 reserved[5];
};

struct fb_cmap {
 __u32 start;
 __u32 len;
 __u16 *red;
 __u16 *green;
 __u16 *blue;
 __u16 *transp;
};

struct fb_con2fbmap {
 __u32 console;
 __u32 framebuffer;
};






enum {

 FB_BLANK_UNBLANK = 0,

 FB_BLANK_NORMAL = 0 + 1,

 FB_BLANK_VSYNC_SUSPEND = 1 + 1,

 FB_BLANK_HSYNC_SUSPEND = 2 + 1,

 FB_BLANK_POWERDOWN = 3 + 1
};
# 285 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/linux/fb.h"
struct fb_vblank {
 __u32 flags;
 __u32 count;
 __u32 vcount;
 __u32 hcount;
 __u32 reserved[4];
};




struct fb_copyarea {
 __u32 dx;
 __u32 dy;
 __u32 width;
 __u32 height;
 __u32 sx;
 __u32 sy;
};

struct fb_fillrect {
 __u32 dx;
 __u32 dy;
 __u32 width;
 __u32 height;
 __u32 color;
 __u32 rop;
};

struct fb_image {
 __u32 dx;
 __u32 dy;
 __u32 width;
 __u32 height;
 __u32 fg_color;
 __u32 bg_color;
 __u8 depth;
 const char *data;
 struct fb_cmap cmap;
};
# 334 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/linux/fb.h"
struct fbcurpos {
 __u16 x, y;
};

struct fb_cursor {
 __u16 set;
 __u16 enable;
 __u16 rop;
 const char *mask;
 struct fbcurpos hot;
 struct fb_image image;
};
# 64 "webkey-2.09/service/webkey.cpp" 2
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/linux/if.h" 1
# 20 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/linux/if.h"
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/linux/hdlc/ioctl.h" 1
# 15 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/linux/hdlc/ioctl.h"
typedef struct {
 unsigned int clock_rate;
 unsigned int clock_type;
 unsigned short loopback;
} sync_serial_settings;

typedef struct {
 unsigned int clock_rate;
 unsigned int clock_type;
 unsigned short loopback;
 unsigned int slot_map;
} te1_settings;

typedef struct {
 unsigned short encoding;
 unsigned short parity;
} raw_hdlc_proto;

typedef struct {
 unsigned int t391;
 unsigned int t392;
 unsigned int n391;
 unsigned int n392;
 unsigned int n393;
 unsigned short lmi;
 unsigned short dce;
} fr_proto;

typedef struct {
 unsigned int dlci;
} fr_proto_pvc;

typedef struct {
 unsigned int dlci;
 char master[16];
}fr_proto_pvc_info;

typedef struct {
 unsigned int interval;
 unsigned int timeout;
} cisco_proto;
# 21 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/linux/if.h" 2
# 78 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/linux/if.h"
enum {
 IF_OPER_UNKNOWN,
 IF_OPER_NOTPRESENT,
 IF_OPER_DOWN,
 IF_OPER_LOWERLAYERDOWN,
 IF_OPER_TESTING,
 IF_OPER_DORMANT,
 IF_OPER_UP,
};

enum {
 IF_LINK_MODE_DEFAULT,
 IF_LINK_MODE_DORMANT,
};

struct ifmap
{
 unsigned long mem_start;
 unsigned long mem_end;
 unsigned short base_addr;
 unsigned char irq;
 unsigned char dma;
 unsigned char port;

};

struct if_settings
{
 unsigned int type;
 unsigned int size;
 union {

 raw_hdlc_proto *raw_hdlc;
 cisco_proto *cisco;
 fr_proto *fr;
 fr_proto_pvc *fr_pvc;
 fr_proto_pvc_info *fr_pvc_info;

 sync_serial_settings *sync;
 te1_settings *te1;
 } ifs_ifsu;
};

struct ifreq
{

 union
 {
 char ifrn_name[16];
 } ifr_ifrn;

 union {
 struct sockaddr ifru_addr;
 struct sockaddr ifru_dstaddr;
 struct sockaddr ifru_broadaddr;
 struct sockaddr ifru_netmask;
 struct sockaddr ifru_hwaddr;
 short ifru_flags;
 int ifru_ivalue;
 int ifru_mtu;
 struct ifmap ifru_map;
 char ifru_slave[16];
 char ifru_newname[16];
 void * ifru_data;
 struct if_settings ifru_settings;
 } ifr_ifru;
};
# 164 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/linux/if.h"
struct ifconf
{
 int ifc_len;
 union
 {
 char *ifcu_buf;
 struct ifreq *ifcu_req;
 } ifc_ifcu;
};
# 65 "webkey-2.09/service/webkey.cpp" 2
# 1 "webkey-2.09/service/png.h" 1
# 434 "webkey-2.09/service/png.h"
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/zlib.h" 1
# 34 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/zlib.h"
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/zconf.h" 1
# 261 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/zconf.h"
typedef unsigned char Byte;

typedef unsigned int uInt;
typedef unsigned long uLong;





   typedef Byte Bytef;

typedef char charf;
typedef int intf;
typedef uInt uIntf;
typedef uLong uLongf;


   typedef void const *voidpc;
   typedef void *voidpf;
   typedef void *voidp;
# 35 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/zlib.h" 2


extern "C" {
# 77 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/zlib.h"
typedef voidpf (*alloc_func) (voidpf opaque, uInt items, uInt size);
typedef void (*free_func) (voidpf opaque, voidpf address);

struct internal_state;

typedef struct z_stream_s {
    Bytef *next_in;
    uInt avail_in;
    uLong total_in;

    Bytef *next_out;
    uInt avail_out;
    uLong total_out;

    char *msg;
    struct internal_state *state;

    alloc_func zalloc;
    free_func zfree;
    voidpf opaque;

    int data_type;
    uLong adler;
    uLong reserved;
} z_stream;

typedef z_stream *z_streamp;





typedef struct gz_header_s {
    int text;
    uLong time;
    int xflags;
    int os;
    Bytef *extra;
    uInt extra_len;
    uInt extra_max;
    Bytef *name;
    uInt name_max;
    Bytef *comment;
    uInt comm_max;
    int hcrc;
    int done;

} gz_header;

typedef gz_header *gz_headerp;
# 212 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/zlib.h"
extern const char * zlibVersion (void);
# 242 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/zlib.h"
extern int deflate (z_streamp strm, int flush);
# 328 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/zlib.h"
extern int deflateEnd (z_streamp strm);
# 363 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/zlib.h"
extern int inflate (z_streamp strm, int flush);
# 462 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/zlib.h"
extern int inflateEnd (z_streamp strm);
# 538 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/zlib.h"
extern int deflateSetDictionary (z_streamp strm, const Bytef *dictionary, uInt dictLength);
# 577 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/zlib.h"
extern int deflateCopy (z_streamp dest, z_streamp source);
# 595 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/zlib.h"
extern int deflateReset (z_streamp strm);
# 606 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/zlib.h"
extern int deflateParams (z_streamp strm, int level, int strategy);
# 627 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/zlib.h"
extern int deflateTune (z_streamp strm, int good_length, int max_lazy, int nice_length, int max_chain);
# 644 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/zlib.h"
extern uLong deflateBound (z_streamp strm, uLong sourceLen);
# 653 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/zlib.h"
extern int deflatePrime (z_streamp strm, int bits, int value);
# 669 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/zlib.h"
extern int deflateSetHeader (z_streamp strm, gz_headerp head);
# 736 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/zlib.h"
extern int inflateSetDictionary (z_streamp strm, const Bytef *dictionary, uInt dictLength);
# 758 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/zlib.h"
extern int inflateSync (z_streamp strm);
# 773 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/zlib.h"
extern int inflateCopy (z_streamp dest, z_streamp source);
# 789 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/zlib.h"
extern int inflateReset (z_streamp strm);
# 799 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/zlib.h"
extern int inflatePrime (z_streamp strm, int bits, int value);
# 815 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/zlib.h"
extern int inflateGetHeader (z_streamp strm, gz_headerp head);
# 877 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/zlib.h"
typedef unsigned (*in_func) (void *, unsigned char * *);
typedef int (*out_func) (void *, unsigned char *, unsigned);

extern int inflateBack (z_streamp strm, in_func in, void *in_desc, out_func out, void *out_desc);
# 949 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/zlib.h"
extern int inflateBackEnd (z_streamp strm);







extern uLong zlibCompileFlags (void);
# 1009 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/zlib.h"
extern int compress (Bytef *dest, uLongf *destLen, const Bytef *source, uLong sourceLen);
# 1024 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/zlib.h"
extern int compress2 (Bytef *dest, uLongf *destLen, const Bytef *source, uLong sourceLen, int level);
# 1040 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/zlib.h"
extern uLong compressBound (uLong sourceLen);






extern int uncompress (Bytef *dest, uLongf *destLen, const Bytef *source, uLong sourceLen);
# 1066 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/zlib.h"
typedef voidp gzFile;

extern gzFile gzopen (const char *path, const char *mode);
# 1085 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/zlib.h"
extern gzFile gzdopen (int fd, const char *mode);
# 1098 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/zlib.h"
extern int gzsetparams (gzFile file, int level, int strategy);







extern int gzread (gzFile file, voidp buf, unsigned len);







extern int gzwrite (gzFile file, voidpc buf, unsigned len);







extern int gzprintf (gzFile file, const char *format, ...);
# 1135 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/zlib.h"
extern int gzputs (gzFile file, const char *s);






extern char * gzgets (gzFile file, char *buf, int len);
# 1151 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/zlib.h"
extern int gzputc (gzFile file, int c);





extern int gzgetc (gzFile file);





extern int gzungetc (int c, gzFile file);
# 1173 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/zlib.h"
extern int gzflush (gzFile file, int flush);
# 1183 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/zlib.h"
extern long gzseek (gzFile file, long offset, int whence);
# 1201 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/zlib.h"
extern int gzrewind (gzFile file);






extern long gztell (gzFile file);
# 1217 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/zlib.h"
extern int gzeof (gzFile file);





extern int gzdirect (gzFile file);





extern int gzclose (gzFile file);






extern const char * gzerror (gzFile file, int *errnum);
# 1245 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/zlib.h"
extern void gzclearerr (gzFile file);
# 1260 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/zlib.h"
extern uLong adler32 (uLong adler, const Bytef *buf, uInt len);
# 1276 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/zlib.h"
extern uLong adler32_combine (uLong adler1, uLong adler2, long len2);
# 1285 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/zlib.h"
extern uLong crc32 (uLong crc, const Bytef *buf, uInt len);
# 1301 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/zlib.h"
extern uLong crc32_combine (uLong crc1, uLong crc2, long len2);
# 1317 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/zlib.h"
extern int deflateInit_ (z_streamp strm, int level, const char *version, int stream_size);

extern int inflateInit_ (z_streamp strm, const char *version, int stream_size);

extern int deflateInit2_ (z_streamp strm, int level, int method, int windowBits, int memLevel, int strategy, const char *version, int stream_size);



extern int inflateInit2_ (z_streamp strm, int windowBits, const char *version, int stream_size);

extern int inflateBackInit_ (z_streamp strm, int windowBits, unsigned char *window, const char *version, int stream_size);
# 1346 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/zlib.h"
    struct internal_state {int dummy;};


extern const char * zError (int);
extern int inflateSyncPoint (z_streamp z);
extern const uLongf * get_crc_table (void);


}
# 435 "webkey-2.09/service/png.h" 2



# 1 "webkey-2.09/service/pngconf.h" 1
# 332 "webkey-2.09/service/pngconf.h"
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/setjmp.h" 1
# 44 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/setjmp.h"
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/machine/setjmp.h" 1
# 45 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/setjmp.h" 2

typedef long sigjmp_buf[64 + 1];
typedef long jmp_buf[64];

extern "C" {

int _setjmp(jmp_buf);
void _longjmp(jmp_buf, int);
void longjmperror(void);

int setjmp(jmp_buf);
void longjmp(jmp_buf, int);

int sigsetjmp(sigjmp_buf, int);
void siglongjmp(sigjmp_buf, int);

}
# 333 "webkey-2.09/service/pngconf.h" 2
# 1116 "webkey-2.09/service/pngconf.h"
typedef unsigned long png_uint_32;
typedef long png_int_32;
typedef unsigned short png_uint_16;
typedef short png_int_16;
typedef unsigned char png_byte;







   typedef size_t png_size_t;
# 1193 "webkey-2.09/service/pngconf.h"
typedef png_int_32 png_fixed_point;


typedef void * png_voidp;
typedef png_byte * png_bytep;
typedef png_uint_32 * png_uint_32p;
typedef png_int_32 * png_int_32p;
typedef png_uint_16 * png_uint_16p;
typedef png_int_16 * png_int_16p;
typedef const char * png_const_charp;
typedef char * png_charp;
typedef png_fixed_point * png_fixed_point_p;





typedef FILE * png_FILE_p;




typedef double * png_doublep;



typedef png_byte * * png_bytepp;
typedef png_uint_32 * * png_uint_32pp;
typedef png_int_32 * * png_int_32pp;
typedef png_uint_16 * * png_uint_16pp;
typedef png_int_16 * * png_int_16pp;
typedef const char * * png_const_charpp;
typedef char * * png_charpp;
typedef png_fixed_point * * png_fixed_point_pp;

typedef double * * png_doublepp;



typedef char * * * png_charppp;
# 1241 "webkey-2.09/service/pngconf.h"
typedef charf * png_zcharp;
typedef charf * * png_zcharpp;
typedef z_stream * png_zstreamp;
# 439 "webkey-2.09/service/png.h" 2
# 469 "webkey-2.09/service/png.h"
extern "C" {
# 518 "webkey-2.09/service/png.h"
extern const char png_libpng_ver[18];
# 527 "webkey-2.09/service/png.h"
extern const int png_pass_start[7];
extern const int png_pass_inc[7];
extern const int png_pass_ystart[7];
extern const int png_pass_yinc[7];
extern const int png_pass_mask[7];
extern const int png_pass_dsp_mask[7];
# 544 "webkey-2.09/service/png.h"
typedef struct png_color_struct
{
   png_byte red;
   png_byte green;
   png_byte blue;
} png_color;
typedef png_color * png_colorp;
typedef png_color * * png_colorpp;

typedef struct png_color_16_struct
{
   png_byte index;
   png_uint_16 red;
   png_uint_16 green;
   png_uint_16 blue;
   png_uint_16 gray;
} png_color_16;
typedef png_color_16 * png_color_16p;
typedef png_color_16 * * png_color_16pp;

typedef struct png_color_8_struct
{
   png_byte red;
   png_byte green;
   png_byte blue;
   png_byte gray;
   png_byte alpha;
} png_color_8;
typedef png_color_8 * png_color_8p;
typedef png_color_8 * * png_color_8pp;





typedef struct png_sPLT_entry_struct
{
   png_uint_16 red;
   png_uint_16 green;
   png_uint_16 blue;
   png_uint_16 alpha;
   png_uint_16 frequency;
} png_sPLT_entry;
typedef png_sPLT_entry * png_sPLT_entryp;
typedef png_sPLT_entry * * png_sPLT_entrypp;






typedef struct png_sPLT_struct
{
   png_charp name;
   png_byte depth;
   png_sPLT_entryp entries;
   png_int_32 nentries;
} png_sPLT_t;
typedef png_sPLT_t * png_sPLT_tp;
typedef png_sPLT_t * * png_sPLT_tpp;
# 614 "webkey-2.09/service/png.h"
typedef struct png_text_struct
{
   int compression;




   png_charp key;
   png_charp text;

   png_size_t text_length;







} png_text;
typedef png_text * png_textp;
typedef png_text * * png_textpp;
# 653 "webkey-2.09/service/png.h"
typedef struct png_time_struct
{
   png_uint_16 year;
   png_byte month;
   png_byte day;
   png_byte hour;
   png_byte minute;
   png_byte second;
} png_time;
typedef png_time * png_timep;
typedef png_time * * png_timepp;
# 672 "webkey-2.09/service/png.h"
typedef struct png_unknown_chunk_t
{
    png_byte name[5];
    png_byte *data;
    png_size_t size;


    png_byte location;
}
png_unknown_chunk;
typedef png_unknown_chunk * png_unknown_chunkp;
typedef png_unknown_chunk * * png_unknown_chunkpp;
# 725 "webkey-2.09/service/png.h"
typedef struct png_info_struct
{

   png_uint_32 width;
   png_uint_32 height;
   png_uint_32 valid;
   png_uint_32 rowbytes;
   png_colorp palette;
   png_uint_16 num_palette;
   png_uint_16 num_trans;
   png_byte bit_depth;
   png_byte color_type;

   png_byte compression_type;
   png_byte filter_type;
   png_byte interlace_type;


   png_byte channels;
   png_byte pixel_depth;
   png_byte spare_byte;
   png_byte signature[8];
# 759 "webkey-2.09/service/png.h"
   float gamma;





   png_byte srgb_intent;
# 777 "webkey-2.09/service/png.h"
   int num_text;
   int max_text;
   png_textp text;






   png_time mod_time;
# 796 "webkey-2.09/service/png.h"
   png_color_8 sig_bit;
# 810 "webkey-2.09/service/png.h"
   png_bytep trans;
   png_color_16 trans_values;
# 821 "webkey-2.09/service/png.h"
   png_color_16 background;
# 830 "webkey-2.09/service/png.h"
   png_int_32 x_offset;
   png_int_32 y_offset;
   png_byte offset_unit_type;







   png_uint_32 x_pixels_per_unit;
   png_uint_32 y_pixels_per_unit;
   png_byte phys_unit_type;
# 852 "webkey-2.09/service/png.h"
   png_uint_16p hist;
# 863 "webkey-2.09/service/png.h"
   float x_white;
   float y_white;
   float x_red;
   float y_red;
   float x_green;
   float y_green;
   float x_blue;
   float y_blue;
# 886 "webkey-2.09/service/png.h"
   png_charp pcal_purpose;
   png_int_32 pcal_X0;
   png_int_32 pcal_X1;
   png_charp pcal_units;
   png_charpp pcal_params;
   png_byte pcal_type;
   png_byte pcal_nparams;




   png_uint_32 free_me;




   png_unknown_chunkp unknown_chunks;
   png_size_t unknown_chunks_num;




   png_charp iccp_name;
   png_charp iccp_profile;

   png_uint_32 iccp_proflen;
   png_byte iccp_compression;




   png_sPLT_tp splt_palettes;
   png_uint_32 splt_palettes_num;
# 929 "webkey-2.09/service/png.h"
   png_byte scal_unit;

   double scal_pixel_width;
   double scal_pixel_height;


   png_charp scal_s_width;
   png_charp scal_s_height;






   png_bytepp row_pointers;



   png_fixed_point int_gamma;



   png_fixed_point int_x_white;
   png_fixed_point int_y_white;
   png_fixed_point int_x_red;
   png_fixed_point int_y_red;
   png_fixed_point int_x_green;
   png_fixed_point int_y_green;
   png_fixed_point int_x_blue;
   png_fixed_point int_y_blue;


} png_info;

typedef png_info * png_infop;
typedef png_info * * png_infopp;
# 1067 "webkey-2.09/service/png.h"
typedef struct png_row_info_struct
{
   png_uint_32 width;
   png_uint_32 rowbytes;
   png_byte color_type;
   png_byte bit_depth;
   png_byte channels;
   png_byte pixel_depth;
} png_row_info;

typedef png_row_info * png_row_infop;
typedef png_row_info * * png_row_infopp;







typedef struct png_struct_def png_struct;
typedef png_struct * png_structp;

typedef void ( *png_error_ptr) (png_structp, png_const_charp);
typedef void ( *png_rw_ptr) (png_structp, png_bytep, png_size_t);
typedef void ( *png_flush_ptr) (png_structp);
typedef void ( *png_read_status_ptr) (png_structp, png_uint_32, int);

typedef void ( *png_write_status_ptr) (png_structp, png_uint_32, int);



typedef void ( *png_progressive_info_ptr) (png_structp, png_infop);
typedef void ( *png_progressive_end_ptr) (png_structp, png_infop);
typedef void ( *png_progressive_row_ptr) (png_structp, png_bytep, png_uint_32, int);






typedef void ( *png_user_transform_ptr) (png_structp, png_row_infop, png_bytep);




typedef int ( *png_user_chunk_ptr) (png_structp, png_unknown_chunkp);


typedef void ( *png_unknown_chunk_ptr) (png_structp);
# 1138 "webkey-2.09/service/png.h"
typedef png_voidp (*png_malloc_ptr) (png_structp, png_size_t);
typedef void (*png_free_ptr) (png_structp, png_voidp);
# 1148 "webkey-2.09/service/png.h"
struct png_struct_def
{

   jmp_buf jmpbuf;

   png_error_ptr error_fn;
   png_error_ptr warning_fn;
   png_voidp error_ptr;
   png_rw_ptr write_data_fn;
   png_rw_ptr read_data_fn;
   png_voidp io_ptr;


   png_user_transform_ptr read_user_transform_fn;



   png_user_transform_ptr write_user_transform_fn;






   png_voidp user_transform_ptr;
   png_byte user_transform_depth;
   png_byte user_transform_channels;



   png_uint_32 mode;
   png_uint_32 flags;
   png_uint_32 transformations;

   z_stream zstream;
   png_bytep zbuf;
   png_size_t zbuf_size;
   int zlib_level;
   int zlib_method;
   int zlib_window_bits;
   int zlib_mem_level;
   int zlib_strategy;

   png_uint_32 width;
   png_uint_32 height;
   png_uint_32 num_rows;
   png_uint_32 usr_width;
   png_uint_32 rowbytes;
   png_uint_32 irowbytes;
   png_uint_32 iwidth;
   png_uint_32 row_number;
   png_bytep prev_row;
   png_bytep row_buf;

   png_bytep sub_row;
   png_bytep up_row;
   png_bytep avg_row;
   png_bytep paeth_row;

   png_row_info row_info;

   png_uint_32 idat_size;
   png_uint_32 crc;
   png_colorp palette;
   png_uint_16 num_palette;
   png_uint_16 num_trans;
   png_byte chunk_name[5];
   png_byte compression;
   png_byte filter;
   png_byte interlaced;
   png_byte pass;
   png_byte do_filter;
   png_byte color_type;
   png_byte bit_depth;
   png_byte usr_bit_depth;
   png_byte pixel_depth;
   png_byte channels;
   png_byte usr_channels;
   png_byte sig_bytes;





   png_uint_16 filler;




   png_byte background_gamma_type;

   float background_gamma;

   png_color_16 background;

   png_color_16 background_1;




   png_flush_ptr output_flush_fn;
   png_uint_32 flush_dist;
   png_uint_32 flush_rows;



   int gamma_shift;

   float gamma;
   float screen_gamma;




   png_bytep gamma_table;
   png_bytep gamma_from_1;
   png_bytep gamma_to_1;
   png_uint_16pp gamma_16_table;
   png_uint_16pp gamma_16_from_1;
   png_uint_16pp gamma_16_to_1;



   png_color_8 sig_bit;



   png_color_8 shift;




   png_bytep trans;
   png_color_16 trans_values;


   png_read_status_ptr read_row_fn;
   png_write_status_ptr write_row_fn;

   png_progressive_info_ptr info_fn;
   png_progressive_row_ptr row_fn;
   png_progressive_end_ptr end_fn;
   png_bytep save_buffer_ptr;
   png_bytep save_buffer;
   png_bytep current_buffer_ptr;
   png_bytep current_buffer;
   png_uint_32 push_length;
   png_uint_32 skip_length;
   png_size_t save_buffer_size;
   png_size_t save_buffer_max;
   png_size_t buffer_size;
   png_size_t current_buffer_size;
   int process_mode;
   int cur_palette;


     png_size_t current_text_size;
     png_size_t current_text_left;
     png_charp current_text;
     png_charp current_text_ptr;
# 1321 "webkey-2.09/service/png.h"
   png_bytep palette_lookup;
   png_bytep dither_index;



   png_uint_16p hist;



   png_byte heuristic_method;
   png_byte num_prev_filters;
   png_bytep prev_filters;
   png_uint_16p filter_weights;
   png_uint_16p inv_filter_weights;
   png_uint_16p filter_costs;
   png_uint_16p inv_filter_costs;



   png_charp time_buffer;





   png_uint_32 free_me;



   png_voidp user_chunk_ptr;
   png_user_chunk_ptr read_user_chunk_fn;



   int num_chunk_list;
   png_bytep chunk_list;




   png_byte rgb_to_gray_status;

   png_uint_16 rgb_to_gray_red_coeff;
   png_uint_16 rgb_to_gray_green_coeff;
   png_uint_16 rgb_to_gray_blue_coeff;
# 1376 "webkey-2.09/service/png.h"
   png_uint_32 mng_features_permitted;





   png_fixed_point int_gamma;




   png_byte filter_type;
# 1399 "webkey-2.09/service/png.h"
   png_byte mmx_bitdepth_threshold;
   png_uint_32 mmx_rowbytes_threshold;

   png_uint_32 asm_flags;





   png_voidp mem_ptr;
   png_malloc_ptr malloc_fn;
   png_free_ptr free_fn;



   png_bytep big_row_buf;



   png_bytep dither_sort;
   png_bytep index_to_palette;

   png_bytep palette_to_index;




   png_byte compression_type;


   png_uint_32 user_width_max;
   png_uint_32 user_height_max;





   png_unknown_chunk unknown_chunk;



  png_uint_32 old_big_row_buf_size, old_prev_row_size;
};





typedef png_structp version_1_2_27;

typedef png_struct * * png_structpp;
# 1458 "webkey-2.09/service/png.h"
extern png_uint_32 png_access_version_number (void);




extern void png_set_sig_bytes (png_structp png_ptr, int num_bytes);







extern int png_sig_cmp (png_bytep sig, png_size_t start, png_size_t num_to_check);





extern int png_check_sig (png_bytep sig, int num);


extern png_structp png_create_read_struct
   (png_const_charp user_png_ver, png_voidp error_ptr, png_error_ptr error_fn, png_error_ptr warn_fn);



extern png_structp png_create_write_struct
   (png_const_charp user_png_ver, png_voidp error_ptr, png_error_ptr error_fn, png_error_ptr warn_fn);



extern png_uint_32 png_get_compression_buffer_size
   (png_structp png_ptr);



extern void png_set_compression_buffer_size
   (png_structp png_ptr, png_uint_32 size);



extern int png_reset_zstream (png_structp png_ptr);



extern png_structp png_create_read_struct_2
   (png_const_charp user_png_ver, png_voidp error_ptr, png_error_ptr error_fn, png_error_ptr warn_fn, png_voidp mem_ptr, png_malloc_ptr malloc_fn, png_free_ptr free_fn);


extern png_structp png_create_write_struct_2
   (png_const_charp user_png_ver, png_voidp error_ptr, png_error_ptr error_fn, png_error_ptr warn_fn, png_voidp mem_ptr, png_malloc_ptr malloc_fn, png_free_ptr free_fn);





extern void png_write_chunk (png_structp png_ptr, png_bytep chunk_name, png_bytep data, png_size_t length);



extern void png_write_chunk_start (png_structp png_ptr, png_bytep chunk_name, png_uint_32 length);



extern void png_write_chunk_data (png_structp png_ptr, png_bytep data, png_size_t length);



extern void png_write_chunk_end (png_structp png_ptr);


extern png_infop png_create_info_struct
   (png_structp png_ptr);



extern void png_info_init (png_infop info_ptr);





extern void png_info_init_3 (png_infopp info_ptr, png_size_t png_info_struct_size);



extern void png_write_info_before_PLTE (png_structp png_ptr, png_infop info_ptr);

extern void png_write_info (png_structp png_ptr, png_infop info_ptr);




extern void png_read_info (png_structp png_ptr, png_infop info_ptr);




extern png_charp png_convert_to_rfc1123
   (png_structp png_ptr, png_timep ptime);






extern void png_convert_from_struct_tm (png_timep ptime, struct tm * ttime);



extern void png_convert_from_time_t (png_timep ptime, time_t ttime);






extern void png_set_expand (png_structp png_ptr);

extern void png_set_expand_gray_1_2_4_to_8 (png_structp png_ptr);


extern void png_set_palette_to_rgb (png_structp png_ptr);
extern void png_set_tRNS_to_alpha (png_structp png_ptr);


extern void png_set_gray_1_2_4_to_8 (png_structp png_ptr);





extern void png_set_bgr (png_structp png_ptr);




extern void png_set_gray_to_rgb (png_structp png_ptr);





extern void png_set_rgb_to_gray (png_structp png_ptr, int error_action, double red, double green );


extern void png_set_rgb_to_gray_fixed (png_structp png_ptr, int error_action, png_fixed_point red, png_fixed_point green );

extern png_byte png_get_rgb_to_gray_status (png_structp png_ptr);



extern void png_build_grayscale_palette (int bit_depth, png_colorp palette);



extern void png_set_strip_alpha (png_structp png_ptr);




extern void png_set_swap_alpha (png_structp png_ptr);




extern void png_set_invert_alpha (png_structp png_ptr);




extern void png_set_filler (png_structp png_ptr, png_uint_32 filler, int flags);






extern void png_set_add_alpha (png_structp png_ptr, png_uint_32 filler, int flags);






extern void png_set_swap (png_structp png_ptr);




extern void png_set_packing (png_structp png_ptr);




extern void png_set_packswap (png_structp png_ptr);




extern void png_set_shift (png_structp png_ptr, png_color_8p true_bits);






extern int png_set_interlace_handling (png_structp png_ptr);




extern void png_set_invert_mono (png_structp png_ptr);





extern void png_set_background (png_structp png_ptr, png_color_16p background_color, int background_gamma_code, int need_expand, double background_gamma);
# 1689 "webkey-2.09/service/png.h"
extern void png_set_strip_16 (png_structp png_ptr);




extern void png_set_dither (png_structp png_ptr, png_colorp palette, int num_palette, int maximum_colors, png_uint_16p histogram, int full_dither);







extern void png_set_gamma (png_structp png_ptr, double screen_gamma, double default_file_gamma);
# 1712 "webkey-2.09/service/png.h"
extern void png_permit_empty_plte (png_structp png_ptr, int empty_plte_permitted);






extern void png_set_flush (png_structp png_ptr, int nrows);

extern void png_write_flush (png_structp png_ptr);



extern void png_start_read_image (png_structp png_ptr);


extern void png_read_update_info (png_structp png_ptr, png_infop info_ptr);




extern void png_read_rows (png_structp png_ptr, png_bytepp row, png_bytepp display_row, png_uint_32 num_rows);





extern void png_read_row (png_structp png_ptr, png_bytep row, png_bytep display_row);






extern void png_read_image (png_structp png_ptr, png_bytepp image);




extern void png_write_row (png_structp png_ptr, png_bytep row);



extern void png_write_rows (png_structp png_ptr, png_bytepp row, png_uint_32 num_rows);



extern void png_write_image (png_structp png_ptr, png_bytepp image);



extern void png_write_end (png_structp png_ptr, png_infop info_ptr);




extern void png_read_end (png_structp png_ptr, png_infop info_ptr);




extern void png_destroy_info_struct (png_structp png_ptr, png_infopp info_ptr_ptr);



extern void png_destroy_read_struct (png_structpp png_ptr_ptr, png_infopp info_ptr_ptr, png_infopp end_info_ptr_ptr);




extern void png_read_destroy (png_structp png_ptr, png_infop info_ptr, png_infop end_info_ptr);



extern void png_destroy_write_struct
   (png_structpp png_ptr_ptr, png_infopp info_ptr_ptr);



extern void png_write_destroy (png_structp png_ptr);


extern void png_set_crc_action (png_structp png_ptr, int crit_action, int ancil_action);
# 1824 "webkey-2.09/service/png.h"
extern void png_set_filter (png_structp png_ptr, int method, int filters);
# 1881 "webkey-2.09/service/png.h"
extern void png_set_filter_heuristics (png_structp png_ptr, int heuristic_method, int num_weights, png_doublep filter_weights, png_doublep filter_costs);
# 1902 "webkey-2.09/service/png.h"
extern void png_set_compression_level (png_structp png_ptr, int level);


extern void png_set_compression_mem_level
   (png_structp png_ptr, int mem_level);

extern void png_set_compression_strategy
   (png_structp png_ptr, int strategy);

extern void png_set_compression_window_bits
   (png_structp png_ptr, int window_bits);

extern void png_set_compression_method (png_structp png_ptr, int method);
# 1928 "webkey-2.09/service/png.h"
extern void png_init_io (png_structp png_ptr, png_FILE_p fp);
# 1939 "webkey-2.09/service/png.h"
extern void png_set_error_fn (png_structp png_ptr, png_voidp error_ptr, png_error_ptr error_fn, png_error_ptr warning_fn);



extern png_voidp png_get_error_ptr (png_structp png_ptr);






extern void png_set_write_fn (png_structp png_ptr, png_voidp io_ptr, png_rw_ptr write_data_fn, png_flush_ptr output_flush_fn);



extern void png_set_read_fn (png_structp png_ptr, png_voidp io_ptr, png_rw_ptr read_data_fn);



extern png_voidp png_get_io_ptr (png_structp png_ptr);

extern void png_set_read_status_fn (png_structp png_ptr, png_read_status_ptr read_row_fn);


extern void png_set_write_status_fn (png_structp png_ptr, png_write_status_ptr write_row_fn);




extern void png_set_mem_fn (png_structp png_ptr, png_voidp mem_ptr, png_malloc_ptr malloc_fn, png_free_ptr free_fn);


extern png_voidp png_get_mem_ptr (png_structp png_ptr);




extern void png_set_read_user_transform_fn (png_structp png_ptr, png_user_transform_ptr read_user_transform_fn);





extern void png_set_write_user_transform_fn (png_structp png_ptr, png_user_transform_ptr write_user_transform_fn);






extern void png_set_user_transform_info (png_structp png_ptr, png_voidp user_transform_ptr, int user_transform_depth, int user_transform_channels);



extern png_voidp png_get_user_transform_ptr
   (png_structp png_ptr);



extern void png_set_read_user_chunk_fn (png_structp png_ptr, png_voidp user_chunk_ptr, png_user_chunk_ptr read_user_chunk_fn);

extern png_voidp png_get_user_chunk_ptr (png_structp png_ptr);







extern void png_set_progressive_read_fn (png_structp png_ptr, png_voidp progressive_ptr, png_progressive_info_ptr info_fn, png_progressive_row_ptr row_fn, png_progressive_end_ptr end_fn);





extern png_voidp png_get_progressive_ptr
   (png_structp png_ptr);


extern void png_process_data (png_structp png_ptr, png_infop info_ptr, png_bytep buffer, png_size_t buffer_size);





extern void png_progressive_combine_row (png_structp png_ptr, png_bytep old_row, png_bytep new_row);



extern png_voidp png_malloc (png_structp png_ptr, png_uint_32 size);






extern png_voidp png_malloc_warn (png_structp png_ptr, png_uint_32 size);




extern void png_free (png_structp png_ptr, png_voidp ptr);
# 2052 "webkey-2.09/service/png.h"
extern void png_free_data (png_structp png_ptr, png_infop info_ptr, png_uint_32 free_me, int num);




extern void png_data_freer (png_structp png_ptr, png_infop info_ptr, int freer, png_uint_32 mask);
# 2080 "webkey-2.09/service/png.h"
extern png_voidp png_malloc_default (png_structp png_ptr, png_uint_32 size);

extern void png_free_default (png_structp png_ptr, png_voidp ptr);



extern png_voidp png_memcpy_check (png_structp png_ptr, png_voidp s1, png_voidp s2, png_uint_32 size);


extern png_voidp png_memset_check (png_structp png_ptr, png_voidp s1, int value, png_uint_32 size);
# 2099 "webkey-2.09/service/png.h"
extern void png_error (png_structp png_ptr, png_const_charp error_message);



extern void png_chunk_error (png_structp png_ptr, png_const_charp error_message);
# 2112 "webkey-2.09/service/png.h"
extern void png_warning (png_structp png_ptr, png_const_charp warning_message);




extern void png_chunk_warning (png_structp png_ptr, png_const_charp warning_message);
# 2135 "webkey-2.09/service/png.h"
extern png_uint_32 png_get_valid (png_structp png_ptr, png_infop info_ptr, png_uint_32 flag);



extern png_uint_32 png_get_rowbytes (png_structp png_ptr, png_infop info_ptr);





extern png_bytepp png_get_rows (png_structp png_ptr, png_infop info_ptr);



extern void png_set_rows (png_structp png_ptr, png_infop info_ptr, png_bytepp row_pointers);




extern png_byte png_get_channels (png_structp png_ptr, png_infop info_ptr);




extern png_uint_32 png_get_image_width (png_structp png_ptr, png_infop info_ptr);



extern png_uint_32 png_get_image_height (png_structp png_ptr, png_infop info_ptr);



extern png_byte png_get_bit_depth (png_structp png_ptr, png_infop info_ptr);



extern png_byte png_get_color_type (png_structp png_ptr, png_infop info_ptr);



extern png_byte png_get_filter_type (png_structp png_ptr, png_infop info_ptr);



extern png_byte png_get_interlace_type (png_structp png_ptr, png_infop info_ptr);



extern png_byte png_get_compression_type (png_structp png_ptr, png_infop info_ptr);



extern png_uint_32 png_get_pixels_per_meter (png_structp png_ptr, png_infop info_ptr);

extern png_uint_32 png_get_x_pixels_per_meter (png_structp png_ptr, png_infop info_ptr);

extern png_uint_32 png_get_y_pixels_per_meter (png_structp png_ptr, png_infop info_ptr);




extern float png_get_pixel_aspect_ratio (png_structp png_ptr, png_infop info_ptr);




extern png_int_32 png_get_x_offset_pixels (png_structp png_ptr, png_infop info_ptr);

extern png_int_32 png_get_y_offset_pixels (png_structp png_ptr, png_infop info_ptr);

extern png_int_32 png_get_x_offset_microns (png_structp png_ptr, png_infop info_ptr);

extern png_int_32 png_get_y_offset_microns (png_structp png_ptr, png_infop info_ptr);





extern png_bytep png_get_signature (png_structp png_ptr, png_infop info_ptr);



extern png_uint_32 png_get_bKGD (png_structp png_ptr, png_infop info_ptr, png_color_16p *background);




extern void png_set_bKGD (png_structp png_ptr, png_infop info_ptr, png_color_16p background);





extern png_uint_32 png_get_cHRM (png_structp png_ptr, png_infop info_ptr, double *white_x, double *white_y, double *red_x, double *red_y, double *green_x, double *green_y, double *blue_x, double *blue_y);





extern png_uint_32 png_get_cHRM_fixed (png_structp png_ptr, png_infop info_ptr, png_fixed_point *int_white_x, png_fixed_point *int_white_y, png_fixed_point *int_red_x, png_fixed_point *int_red_y, png_fixed_point *int_green_x, png_fixed_point *int_green_y, png_fixed_point *int_blue_x, png_fixed_point *int_blue_y);
# 2244 "webkey-2.09/service/png.h"
extern void png_set_cHRM (png_structp png_ptr, png_infop info_ptr, double white_x, double white_y, double red_x, double red_y, double green_x, double green_y, double blue_x, double blue_y);




extern void png_set_cHRM_fixed (png_structp png_ptr, png_infop info_ptr, png_fixed_point int_white_x, png_fixed_point int_white_y, png_fixed_point int_red_x, png_fixed_point int_red_y, png_fixed_point int_green_x, png_fixed_point int_green_y, png_fixed_point int_blue_x, png_fixed_point int_blue_y);
# 2259 "webkey-2.09/service/png.h"
extern png_uint_32 png_get_gAMA (png_structp png_ptr, png_infop info_ptr, double *file_gamma);


extern png_uint_32 png_get_gAMA_fixed (png_structp png_ptr, png_infop info_ptr, png_fixed_point *int_file_gamma);





extern void png_set_gAMA (png_structp png_ptr, png_infop info_ptr, double file_gamma);


extern void png_set_gAMA_fixed (png_structp png_ptr, png_infop info_ptr, png_fixed_point int_file_gamma);




extern png_uint_32 png_get_hIST (png_structp png_ptr, png_infop info_ptr, png_uint_16p *hist);




extern void png_set_hIST (png_structp png_ptr, png_infop info_ptr, png_uint_16p hist);



extern png_uint_32 png_get_IHDR (png_structp png_ptr, png_infop info_ptr, png_uint_32 *width, png_uint_32 *height, int *bit_depth, int *color_type, int *interlace_method, int *compression_method, int *filter_method);




extern void png_set_IHDR (png_structp png_ptr, png_infop info_ptr, png_uint_32 width, png_uint_32 height, int bit_depth, int color_type, int interlace_method, int compression_method, int filter_method);





extern png_uint_32 png_get_oFFs (png_structp png_ptr, png_infop info_ptr, png_int_32 *offset_x, png_int_32 *offset_y, int *unit_type);





extern void png_set_oFFs (png_structp png_ptr, png_infop info_ptr, png_int_32 offset_x, png_int_32 offset_y, int unit_type);





extern png_uint_32 png_get_pCAL (png_structp png_ptr, png_infop info_ptr, png_charp *purpose, png_int_32 *X0, png_int_32 *X1, int *type, int *nparams, png_charp *units, png_charpp *params);





extern void png_set_pCAL (png_structp png_ptr, png_infop info_ptr, png_charp purpose, png_int_32 X0, png_int_32 X1, int type, int nparams, png_charp units, png_charpp params);





extern png_uint_32 png_get_pHYs (png_structp png_ptr, png_infop info_ptr, png_uint_32 *res_x, png_uint_32 *res_y, int *unit_type);




extern void png_set_pHYs (png_structp png_ptr, png_infop info_ptr, png_uint_32 res_x, png_uint_32 res_y, int unit_type);



extern png_uint_32 png_get_PLTE (png_structp png_ptr, png_infop info_ptr, png_colorp *palette, int *num_palette);


extern void png_set_PLTE (png_structp png_ptr, png_infop info_ptr, png_colorp palette, int num_palette);



extern png_uint_32 png_get_sBIT (png_structp png_ptr, png_infop info_ptr, png_color_8p *sig_bit);




extern void png_set_sBIT (png_structp png_ptr, png_infop info_ptr, png_color_8p sig_bit);




extern png_uint_32 png_get_sRGB (png_structp png_ptr, png_infop info_ptr, int *intent);




extern void png_set_sRGB (png_structp png_ptr, png_infop info_ptr, int intent);

extern void png_set_sRGB_gAMA_and_cHRM (png_structp png_ptr, png_infop info_ptr, int intent);




extern png_uint_32 png_get_iCCP (png_structp png_ptr, png_infop info_ptr, png_charpp name, int *compression_type, png_charpp profile, png_uint_32 *proflen);






extern void png_set_iCCP (png_structp png_ptr, png_infop info_ptr, png_charp name, int compression_type, png_charp profile, png_uint_32 proflen);






extern png_uint_32 png_get_sPLT (png_structp png_ptr, png_infop info_ptr, png_sPLT_tpp entries);




extern void png_set_sPLT (png_structp png_ptr, png_infop info_ptr, png_sPLT_tp entries, int nentries);





extern png_uint_32 png_get_text (png_structp png_ptr, png_infop info_ptr, png_textp *text_ptr, int *num_text);
# 2396 "webkey-2.09/service/png.h"
extern void png_set_text (png_structp png_ptr, png_infop info_ptr, png_textp text_ptr, int num_text);




extern png_uint_32 png_get_tIME (png_structp png_ptr, png_infop info_ptr, png_timep *mod_time);




extern void png_set_tIME (png_structp png_ptr, png_infop info_ptr, png_timep mod_time);




extern png_uint_32 png_get_tRNS (png_structp png_ptr, png_infop info_ptr, png_bytep *trans, int *num_trans, png_color_16p *trans_values);





extern void png_set_tRNS (png_structp png_ptr, png_infop info_ptr, png_bytep trans, int num_trans, png_color_16p trans_values);
# 2427 "webkey-2.09/service/png.h"
extern png_uint_32 png_get_sCAL (png_structp png_ptr, png_infop info_ptr, int *unit, double *width, double *height);
# 2439 "webkey-2.09/service/png.h"
extern void png_set_sCAL (png_structp png_ptr, png_infop info_ptr, int unit, double width, double height);
# 2459 "webkey-2.09/service/png.h"
extern void png_set_keep_unknown_chunks (png_structp png_ptr, int keep, png_bytep chunk_list, int num_chunks);

extern void png_set_unknown_chunks (png_structp png_ptr, png_infop info_ptr, png_unknown_chunkp unknowns, int num_unknowns);

extern void png_set_unknown_chunk_location
   (png_structp png_ptr, png_infop info_ptr, int chunk, int location);
extern png_uint_32 png_get_unknown_chunks (png_structp png_ptr, png_infop info_ptr, png_unknown_chunkpp entries);



 int png_handle_as_unknown (png_structp png_ptr, png_bytep chunk_name);






extern void png_set_invalid (png_structp png_ptr, png_infop info_ptr, int mask);




extern void png_read_png (png_structp png_ptr, png_infop info_ptr, int transforms, png_voidp params);



extern void png_write_png (png_structp png_ptr, png_infop info_ptr, int transforms, png_voidp params);
# 2542 "webkey-2.09/service/png.h"
extern png_charp png_get_copyright (png_structp png_ptr);
extern png_charp png_get_header_ver (png_structp png_ptr);
extern png_charp png_get_header_version (png_structp png_ptr);
extern png_charp png_get_libpng_ver (png_structp png_ptr);


extern png_uint_32 png_permit_mng_features (png_structp png_ptr, png_uint_32 mng_features_permitted);
# 2590 "webkey-2.09/service/png.h"
extern png_uint_32 png_get_mmx_flagmask
   (int flag_select, int *compilerID);


extern png_uint_32 png_get_asm_flagmask
   (int flag_select);


extern png_uint_32 png_get_asm_flags
   (png_structp png_ptr);


extern png_byte png_get_mmx_bitdepth_threshold
   (png_structp png_ptr);


extern png_uint_32 png_get_mmx_rowbytes_threshold
   (png_structp png_ptr);


extern void png_set_asm_flags
   (png_structp png_ptr, png_uint_32 asm_flags);


extern void png_set_mmx_thresholds
   (png_structp png_ptr, png_byte mmx_bitdepth_threshold, png_uint_32 mmx_rowbytes_threshold);






extern int png_mmx_support (void);





extern void png_set_strip_error_numbers (png_structp png_ptr, png_uint_32 strip_mode);







extern void png_set_user_limits (png_structp png_ptr, png_uint_32 user_width_max, png_uint_32 user_height_max);

extern png_uint_32 png_get_user_width_max (png_structp png_ptr);

extern png_uint_32 png_get_user_height_max (png_structp png_ptr);
# 2700 "webkey-2.09/service/png.h"
extern png_uint_32 png_get_uint_32 (png_bytep buf);
extern png_uint_16 png_get_uint_16 (png_bytep buf);
extern png_int_32 png_get_int_32 (png_bytep buf);

extern png_uint_32 png_get_uint_31
  (png_structp png_ptr, png_bytep buf);




extern void png_save_uint_32
   (png_bytep buf, png_uint_32 i);
extern void png_save_int_32
   (png_bytep buf, png_int_32 i);





extern void png_save_uint_16
   (png_bytep buf, unsigned int i);
# 3560 "webkey-2.09/service/png.h"
}
# 66 "webkey-2.09/service/webkey.cpp" 2
# 1 "webkey-2.09/service/jpeglib.h" 1
# 17 "webkey-2.09/service/jpeglib.h"
extern "C" {
# 28 "webkey-2.09/service/jpeglib.h"
# 1 "webkey-2.09/service/jconfig.h" 1
# 29 "webkey-2.09/service/jpeglib.h" 2

# 1 "webkey-2.09/service/jmorecfg.h" 1
# 59 "webkey-2.09/service/jmorecfg.h"
typedef unsigned char JSAMPLE;
# 99 "webkey-2.09/service/jmorecfg.h"
typedef short JCOEF;
# 110 "webkey-2.09/service/jmorecfg.h"
typedef unsigned char JOCTET;
# 135 "webkey-2.09/service/jmorecfg.h"
typedef unsigned char UINT8;
# 147 "webkey-2.09/service/jmorecfg.h"
typedef unsigned short UINT16;







typedef short INT16;





typedef long INT32;
# 171 "webkey-2.09/service/jmorecfg.h"
typedef unsigned int JDIMENSION;
# 227 "webkey-2.09/service/jmorecfg.h"
typedef int boolean;
# 31 "webkey-2.09/service/jpeglib.h" 2
# 70 "webkey-2.09/service/jpeglib.h"
typedef JSAMPLE *JSAMPROW;
typedef JSAMPROW *JSAMPARRAY;
typedef JSAMPARRAY *JSAMPIMAGE;

typedef JCOEF JBLOCK[64];
typedef JBLOCK *JBLOCKROW;
typedef JBLOCKROW *JBLOCKARRAY;
typedef JBLOCKARRAY *JBLOCKIMAGE;

typedef JCOEF *JCOEFPTR;







typedef struct {




  UINT16 quantval[64];





  boolean sent_table;
} JQUANT_TBL;




typedef struct {

  UINT8 bits[17];

  UINT8 huffval[256];





  boolean sent_table;
} JHUFF_TBL;




typedef struct {



  int component_id;
  int component_index;
  int h_samp_factor;
  int v_samp_factor;
  int quant_tbl_no;




  int dc_tbl_no;
  int ac_tbl_no;
# 143 "webkey-2.09/service/jpeglib.h"
  JDIMENSION width_in_blocks;
  JDIMENSION height_in_blocks;






  int DCT_scaled_size;






  JDIMENSION downsampled_width;
  JDIMENSION downsampled_height;




  boolean component_needed;



  int MCU_width;
  int MCU_height;
  int MCU_blocks;
  int MCU_sample_width;
  int last_col_width;
  int last_row_height;





  JQUANT_TBL * quant_table;


  void * dct_table;
} jpeg_component_info;




typedef struct {
  int comps_in_scan;
  int component_index[4];
  int Ss, Se;
  int Ah, Al;
} jpeg_scan_info;



typedef struct jpeg_marker_struct * jpeg_saved_marker_ptr;

struct jpeg_marker_struct {
  jpeg_saved_marker_ptr next;
  UINT8 marker;
  unsigned int original_length;
  unsigned int data_length;
  JOCTET * data;

};



typedef enum {
 JCS_UNKNOWN,
 JCS_GRAYSCALE,
 JCS_RGB,
 JCS_YCbCr,
 JCS_CMYK,
 JCS_YCCK
} J_COLOR_SPACE;



typedef enum {
 JDCT_ISLOW,
 JDCT_IFAST,
 JDCT_FLOAT
} J_DCT_METHOD;
# 236 "webkey-2.09/service/jpeglib.h"
typedef enum {
 JDITHER_NONE,
 JDITHER_ORDERED,
 JDITHER_FS
} J_DITHER_MODE;
# 257 "webkey-2.09/service/jpeglib.h"
struct jpeg_common_struct {
  struct jpeg_error_mgr * err; struct jpeg_memory_mgr * mem; struct jpeg_progress_mgr * progress; void * client_data; boolean is_decompressor; int global_state;




};

typedef struct jpeg_common_struct * j_common_ptr;
typedef struct jpeg_compress_struct * j_compress_ptr;
typedef struct jpeg_decompress_struct * j_decompress_ptr;




struct jpeg_compress_struct {
  struct jpeg_error_mgr * err; struct jpeg_memory_mgr * mem; struct jpeg_progress_mgr * progress; void * client_data; boolean is_decompressor; int global_state;


  struct jpeg_destination_mgr * dest;






  JDIMENSION image_width;
  JDIMENSION image_height;
  int input_components;
  J_COLOR_SPACE in_color_space;

  double input_gamma;
# 298 "webkey-2.09/service/jpeglib.h"
  int data_precision;

  int num_components;
  J_COLOR_SPACE jpeg_color_space;

  jpeg_component_info * comp_info;


  JQUANT_TBL * quant_tbl_ptrs[4];


  JHUFF_TBL * dc_huff_tbl_ptrs[4];
  JHUFF_TBL * ac_huff_tbl_ptrs[4];


  UINT8 arith_dc_L[16];
  UINT8 arith_dc_U[16];
  UINT8 arith_ac_K[16];

  int num_scans;
  const jpeg_scan_info * scan_info;





  boolean raw_data_in;
  boolean arith_code;
  boolean optimize_coding;
  boolean CCIR601_sampling;
  int smoothing_factor;
  J_DCT_METHOD dct_method;






  unsigned int restart_interval;
  int restart_in_rows;



  boolean write_JFIF_header;
  UINT8 JFIF_major_version;
  UINT8 JFIF_minor_version;




  UINT8 density_unit;
  UINT16 X_density;
  UINT16 Y_density;
  boolean write_Adobe_marker;






  JDIMENSION next_scanline;
# 367 "webkey-2.09/service/jpeglib.h"
  boolean progressive_mode;
  int max_h_samp_factor;
  int max_v_samp_factor;

  JDIMENSION total_iMCU_rows;
# 382 "webkey-2.09/service/jpeglib.h"
  int comps_in_scan;
  jpeg_component_info * cur_comp_info[4];


  JDIMENSION MCUs_per_row;
  JDIMENSION MCU_rows_in_scan;

  int blocks_in_MCU;
  int MCU_membership[10];



  int Ss, Se, Ah, Al;




  struct jpeg_comp_master * master;
  struct jpeg_c_main_controller * main;
  struct jpeg_c_prep_controller * prep;
  struct jpeg_c_coef_controller * coef;
  struct jpeg_marker_writer * marker;
  struct jpeg_color_converter * cconvert;
  struct jpeg_downsampler * downsample;
  struct jpeg_forward_dct * fdct;
  struct jpeg_entropy_encoder * entropy;
  jpeg_scan_info * script_space;
  int script_space_size;
};




struct jpeg_decompress_struct {
  struct jpeg_error_mgr * err; struct jpeg_memory_mgr * mem; struct jpeg_progress_mgr * progress; void * client_data; boolean is_decompressor; int global_state;


  struct jpeg_source_mgr * src;




  JDIMENSION image_width;
  JDIMENSION image_height;
  int num_components;
  J_COLOR_SPACE jpeg_color_space;






  J_COLOR_SPACE out_color_space;

  unsigned int scale_num, scale_denom;

  double output_gamma;

  boolean buffered_image;
  boolean raw_data_out;

  J_DCT_METHOD dct_method;
  boolean do_fancy_upsampling;
  boolean do_block_smoothing;

  boolean quantize_colors;

  J_DITHER_MODE dither_mode;
  boolean two_pass_quantize;
  int desired_number_of_colors;

  boolean enable_1pass_quant;
  boolean enable_external_quant;
  boolean enable_2pass_quant;







  JDIMENSION output_width;
  JDIMENSION output_height;
  int out_color_components;
  int output_components;



  int rec_outbuf_height;
# 482 "webkey-2.09/service/jpeglib.h"
  int actual_number_of_colors;
  JSAMPARRAY colormap;
# 493 "webkey-2.09/service/jpeglib.h"
  JDIMENSION output_scanline;




  int input_scan_number;
  JDIMENSION input_iMCU_row;





  int output_scan_number;
  JDIMENSION output_iMCU_row;
# 515 "webkey-2.09/service/jpeglib.h"
  int (*coef_bits)[64];
# 526 "webkey-2.09/service/jpeglib.h"
  JQUANT_TBL * quant_tbl_ptrs[4];


  JHUFF_TBL * dc_huff_tbl_ptrs[4];
  JHUFF_TBL * ac_huff_tbl_ptrs[4];






  int data_precision;

  jpeg_component_info * comp_info;


  boolean progressive_mode;
  boolean arith_code;

  UINT8 arith_dc_L[16];
  UINT8 arith_dc_U[16];
  UINT8 arith_ac_K[16];

  unsigned int restart_interval;




  boolean saw_JFIF_marker;

  UINT8 JFIF_major_version;
  UINT8 JFIF_minor_version;
  UINT8 density_unit;
  UINT16 X_density;
  UINT16 Y_density;
  boolean saw_Adobe_marker;
  UINT8 Adobe_transform;

  boolean CCIR601_sampling;





  jpeg_saved_marker_ptr marker_list;
# 579 "webkey-2.09/service/jpeglib.h"
  int max_h_samp_factor;
  int max_v_samp_factor;

  int min_DCT_scaled_size;

  JDIMENSION total_iMCU_rows;
# 593 "webkey-2.09/service/jpeglib.h"
  JSAMPLE * sample_range_limit;






  int comps_in_scan;
  jpeg_component_info * cur_comp_info[4];


  JDIMENSION MCUs_per_row;
  JDIMENSION MCU_rows_in_scan;

  int blocks_in_MCU;
  int MCU_membership[10];



  int Ss, Se, Ah, Al;





  int unread_marker;




  struct jpeg_decomp_master * master;
  struct jpeg_d_main_controller * main;
  struct jpeg_d_coef_controller * coef;
  struct jpeg_d_post_controller * post;
  struct jpeg_input_controller * inputctl;
  struct jpeg_marker_reader * marker;
  struct jpeg_entropy_decoder * entropy;
  struct jpeg_inverse_dct * idct;
  struct jpeg_upsampler * upsample;
  struct jpeg_color_deconverter * cconvert;
  struct jpeg_color_quantizer * cquantize;
};
# 647 "webkey-2.09/service/jpeglib.h"
struct jpeg_error_mgr {

  void (*error_exit) (j_common_ptr cinfo);

  void (*emit_message) (j_common_ptr cinfo, int msg_level);

  void (*output_message) (j_common_ptr cinfo);

  void (*format_message) (j_common_ptr cinfo, char * buffer);


  void (*reset_error_mgr) (j_common_ptr cinfo);




  int msg_code;

  union {
    int i[8];
    char s[80];
  } msg_parm;



  int trace_level;







  long num_warnings;
# 692 "webkey-2.09/service/jpeglib.h"
  const char * const * jpeg_message_table;
  int last_jpeg_message;



  const char * const * addon_message_table;
  int first_addon_message;
  int last_addon_message;
};




struct jpeg_progress_mgr {
  void (*progress_monitor) (j_common_ptr cinfo);

  long pass_counter;
  long pass_limit;
  int completed_passes;
  int total_passes;
};




struct jpeg_destination_mgr {
  JOCTET * next_output_byte;
  size_t free_in_buffer;

  void (*init_destination) (j_compress_ptr cinfo);
  boolean (*empty_output_buffer) (j_compress_ptr cinfo);
  void (*term_destination) (j_compress_ptr cinfo);
};




struct jpeg_source_mgr {
  const JOCTET * next_input_byte;
  size_t bytes_in_buffer;

  void (*init_source) (j_decompress_ptr cinfo);
  boolean (*fill_input_buffer) (j_decompress_ptr cinfo);
  void (*skip_input_data) (j_decompress_ptr cinfo, long num_bytes);
  boolean (*resync_to_restart) (j_decompress_ptr cinfo, int desired);
  void (*term_source) (j_decompress_ptr cinfo);
};
# 756 "webkey-2.09/service/jpeglib.h"
typedef struct jvirt_sarray_control * jvirt_sarray_ptr;
typedef struct jvirt_barray_control * jvirt_barray_ptr;


struct jpeg_memory_mgr {

  void * (*alloc_small) (j_common_ptr cinfo, int pool_id, size_t sizeofobject);

  void * (*alloc_large) (j_common_ptr cinfo, int pool_id, size_t sizeofobject);

  JSAMPARRAY (*alloc_sarray) (j_common_ptr cinfo, int pool_id, JDIMENSION samplesperrow, JDIMENSION numrows);


  JBLOCKARRAY (*alloc_barray) (j_common_ptr cinfo, int pool_id, JDIMENSION blocksperrow, JDIMENSION numrows);


  jvirt_sarray_ptr (*request_virt_sarray) (j_common_ptr cinfo, int pool_id, boolean pre_zero, JDIMENSION samplesperrow, JDIMENSION numrows, JDIMENSION maxaccess);





  jvirt_barray_ptr (*request_virt_barray) (j_common_ptr cinfo, int pool_id, boolean pre_zero, JDIMENSION blocksperrow, JDIMENSION numrows, JDIMENSION maxaccess);





  void (*realize_virt_arrays) (j_common_ptr cinfo);
  JSAMPARRAY (*access_virt_sarray) (j_common_ptr cinfo, jvirt_sarray_ptr ptr, JDIMENSION start_row, JDIMENSION num_rows, boolean writable);




  JBLOCKARRAY (*access_virt_barray) (j_common_ptr cinfo, jvirt_barray_ptr ptr, JDIMENSION start_row, JDIMENSION num_rows, boolean writable);




  void (*free_pool) (j_common_ptr cinfo, int pool_id);
  void (*self_destruct) (j_common_ptr cinfo);






  long max_memory_to_use;


  long max_alloc_chunk;
};





typedef boolean (*jpeg_marker_parser_method) (j_decompress_ptr cinfo);
# 888 "webkey-2.09/service/jpeglib.h"
extern struct jpeg_error_mgr * jpeg_std_error
 (struct jpeg_error_mgr * err);
# 904 "webkey-2.09/service/jpeglib.h"
extern void jpeg_CreateCompress (j_compress_ptr cinfo, int version, size_t structsize);

extern void jpeg_CreateDecompress (j_decompress_ptr cinfo, int version, size_t structsize);


extern void jpeg_destroy_compress (j_compress_ptr cinfo);
extern void jpeg_destroy_decompress (j_decompress_ptr cinfo);



extern void jpeg_stdio_dest (j_compress_ptr cinfo, FILE * outfile);
extern void jpeg_stdio_src (j_decompress_ptr cinfo, FILE * infile);


extern void jpeg_set_defaults (j_compress_ptr cinfo);

extern void jpeg_set_colorspace (j_compress_ptr cinfo, J_COLOR_SPACE colorspace);

extern void jpeg_default_colorspace (j_compress_ptr cinfo);
extern void jpeg_set_quality (j_compress_ptr cinfo, int quality, boolean force_baseline);

extern void jpeg_set_linear_quality (j_compress_ptr cinfo, int scale_factor, boolean force_baseline);


extern void jpeg_add_quant_table (j_compress_ptr cinfo, int which_tbl, const unsigned int *basic_table, int scale_factor, boolean force_baseline);



extern int jpeg_quality_scaling (int quality);
extern void jpeg_simple_progression (j_compress_ptr cinfo);
extern void jpeg_suppress_tables (j_compress_ptr cinfo, boolean suppress);

extern JQUANT_TBL * jpeg_alloc_quant_table (j_common_ptr cinfo);
extern JHUFF_TBL * jpeg_alloc_huff_table (j_common_ptr cinfo);


extern void jpeg_start_compress (j_compress_ptr cinfo, boolean write_all_tables);

extern JDIMENSION jpeg_write_scanlines (j_compress_ptr cinfo, JSAMPARRAY scanlines, JDIMENSION num_lines);


extern void jpeg_finish_compress (j_compress_ptr cinfo);


extern JDIMENSION jpeg_write_raw_data (j_compress_ptr cinfo, JSAMPIMAGE data, JDIMENSION num_lines);




extern void jpeg_write_marker
 (j_compress_ptr cinfo, int marker, const JOCTET * dataptr, unsigned int datalen);


extern void jpeg_write_m_header
 (j_compress_ptr cinfo, int marker, unsigned int datalen);
extern void jpeg_write_m_byte
 (j_compress_ptr cinfo, int val);


extern void jpeg_write_tables (j_compress_ptr cinfo);


extern int jpeg_read_header (j_decompress_ptr cinfo, boolean require_image);
# 979 "webkey-2.09/service/jpeglib.h"
extern boolean jpeg_start_decompress (j_decompress_ptr cinfo);
extern JDIMENSION jpeg_read_scanlines (j_decompress_ptr cinfo, JSAMPARRAY scanlines, JDIMENSION max_lines);


extern boolean jpeg_finish_decompress (j_decompress_ptr cinfo);


extern JDIMENSION jpeg_read_raw_data (j_decompress_ptr cinfo, JSAMPIMAGE data, JDIMENSION max_lines);




extern boolean jpeg_has_multiple_scans (j_decompress_ptr cinfo);
extern boolean jpeg_start_output (j_decompress_ptr cinfo, int scan_number);

extern boolean jpeg_finish_output (j_decompress_ptr cinfo);
extern boolean jpeg_input_complete (j_decompress_ptr cinfo);
extern void jpeg_new_colormap (j_decompress_ptr cinfo);
extern int jpeg_consume_input (j_decompress_ptr cinfo);
# 1006 "webkey-2.09/service/jpeglib.h"
extern void jpeg_calc_output_dimensions (j_decompress_ptr cinfo);


extern void jpeg_save_markers
 (j_decompress_ptr cinfo, int marker_code, unsigned int length_limit);



extern void jpeg_set_marker_processor
 (j_decompress_ptr cinfo, int marker_code, jpeg_marker_parser_method routine);



extern jvirt_barray_ptr * jpeg_read_coefficients (j_decompress_ptr cinfo);
extern void jpeg_write_coefficients (j_compress_ptr cinfo, jvirt_barray_ptr * coef_arrays);

extern void jpeg_copy_critical_parameters (j_decompress_ptr srcinfo, j_compress_ptr dstinfo);
# 1031 "webkey-2.09/service/jpeglib.h"
extern void jpeg_abort_compress (j_compress_ptr cinfo);
extern void jpeg_abort_decompress (j_decompress_ptr cinfo);




extern void jpeg_abort (j_common_ptr cinfo);
extern void jpeg_destroy (j_common_ptr cinfo);


extern boolean jpeg_resync_to_restart (j_decompress_ptr cinfo, int desired);
# 1101 "webkey-2.09/service/jpeglib.h"
}
# 67 "webkey-2.09/service/webkey.cpp" 2







# 1 "webkey-2.09/service/mongoose.h" 1
# 26 "webkey-2.09/service/mongoose.h"
extern "C" {
# 39 "webkey-2.09/service/mongoose.h"
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/system_properties.h" 1
# 34 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/system_properties.h"
extern "C" {

typedef struct prop_info prop_info;
# 47 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/system_properties.h"
int __system_property_get(const char *name, char *value);
# 58 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/system_properties.h"
const prop_info *__system_property_find(const char *name);
# 69 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/system_properties.h"
int __system_property_read(const prop_info *pi, char *name, char *value);
# 81 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/sys/system_properties.h"
const prop_info *__system_property_find_nth(unsigned n);

}
# 40 "webkey-2.09/service/mongoose.h" 2





struct mg_context;
struct mg_connection;

void* backserver(void * a);
void backdecrease();
static int exit_flag;

struct backserver_parameter{
 char** server_username;
 char** server_random;
 bool* server;
 int* server_changes;
 char* server_port;
 mg_context* ctx;
};

int64_t contentlen(mg_connection* conn);



struct mg_request_info {
  char *request_method;
  char *uri;
  char *http_version;
  char *query_string;
  char *remote_user;
  int permissions;
  char language[3];
  char *log_message;
  __u32 remote_ip;
  int remote_port;
  int status_code;
  int is_ssl;
  int num_headers;
  struct mg_header {
    char *name;
    char *value;
  } http_headers[64];
};


enum mg_event {
  MG_NEW_REQUEST,
  MG_HTTP_ERROR,
  MG_EVENT_LOG,
  MG_INIT_SSL,

};
# 110 "webkey-2.09/service/mongoose.h"
typedef void * (*mg_callback_t)(enum mg_event event,
                                struct mg_connection *conn,
                                const struct mg_request_info *request_info);
# 135 "webkey-2.09/service/mongoose.h"
struct mg_context *mg_start(char* upload_r, mg_callback_t callback,
  const char* webkey_dir, const char **options);







void mg_stop(struct mg_context *);
# 153 "webkey-2.09/service/mongoose.h"
const char *mg_get_option(const struct mg_context *ctx, const char *name);





const char **mg_get_valid_option_names(void);
# 174 "webkey-2.09/service/mongoose.h"
int mg_modify_passwords_file(struct mg_context *ctx,
    const char *passwords_file_name, const char *user, const char *password,
    int permissions);


int mg_write(struct mg_connection *, const void *buf, size_t len);
# 188 "webkey-2.09/service/mongoose.h"
int mg_printf(struct mg_connection *, const char *fmt, ...);



int mg_read(struct mg_connection *, void *buf, size_t len);







const char *mg_get_header(const struct mg_connection *, const char *name);
# 219 "webkey-2.09/service/mongoose.h"
int mg_get_var(const char *data, size_t data_len,
    const char *var_name, char *buf, size_t buf_len);
# 233 "webkey-2.09/service/mongoose.h"
int mg_get_cookie(const struct mg_connection *,
    const char *cookie_name, char *buf, size_t buf_len);



const char *mg_version(void);
# 247 "webkey-2.09/service/mongoose.h"
void mg_md5(char *buf, ...);
# 256 "webkey-2.09/service/mongoose.h"
typedef int bool_t;
static size_t
url_decode(const char *src, size_t src_len, char *dst, size_t dst_len,
  bool_t is_form_url_encoded)
{
 size_t i, j;
 int a, b;


 for (i = j = 0; i < src_len && j < dst_len - 1; i++, j++) {
  if (src[i] == '%' &&
      isxdigit(* (unsigned char *) (src + i + 1)) &&
      isxdigit(* (unsigned char *) (src + i + 2))) {
   a = tolower(* (unsigned char *) (src + i + 1));
   b = tolower(* (unsigned char *) (src + i + 2));
   dst[j] = (((isdigit(a) ? a - '0' : a - 'W') << 4) | (isdigit(b) ? b - '0' : b - 'W')) & 0xff;
   i += 2;
  } else if (is_form_url_encoded && src[i] == '+') {
   dst[j] = ' ';
  } else {
   dst[j] = src[i];
  }
 }

 dst[j] = '\0';

 return (j);
}




static void
remove_double_dots_and_double_slashes(char *s)
{
 char *p = s;

 while (*s != '\0') {
  *p++ = *s++;
  if (s[-1] == '/' || s[-1] == '\\') {

   while (*s == '/' || *s == '\\')
    s++;


   while (*s == '.' && s[1] == '.')
    s += 2;
  }
 }
 *p = '\0';
}



static char* convertxml(char* to, const char* from)
{
 int i = 0;
 int j = 0;
 while(from[i] && j < 4096 - 8)
 {
  if(from[i] == '<')
  {
   to[j++] = '&';
   to[j++] = 'l';
   to[j++] = 't';
   to[j++] = ';';
  }
  else if(from[i] == '>')
  {
   to[j++] = '&';
   to[j++] = 'g';
   to[j++] = 't';
   to[j++] = ';';
  }
  else if(from[i] == '&')
  {
   to[j++] = '&';
   to[j++] = 'a';
   to[j++] = 'm';
   to[j++] = 'p';
   to[j++] = ';';
  }
  else if(from[i] == '"')
  {
   to[j++] = '&';
   to[j++] = 'q';
   to[j++] = 'u';
   to[j++] = 'o';
   to[j++] = 't';
   to[j++] = ';';
  }
  else if(from[i] == '\'')
  {
   to[j++] = '&';
   to[j++] = 'a';
   to[j++] = 'p';
   to[j++] = 'o';
   to[j++] = 's';
   to[j++] = ';';
  }
  else
   to[j++] = from[i];
  i++;
 }
 to[j++] = 0;
 return to;
}

void
my_send_directory(struct mg_connection *conn, const char *dir);

}
# 75 "webkey-2.09/service/webkey.cpp" 2
# 1 "webkey-2.09/service/base64.h" 1


std::string base64_encode(unsigned char const* , unsigned int len);
std::string base64_decode(std::string const& s);
# 76 "webkey-2.09/service/webkey.cpp" 2






# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/termios.h" 1
# 35 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/termios.h"
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/linux/termios.h" 1
# 16 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/linux/termios.h"
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/asm/termios.h" 1
# 18 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/asm/termios.h"
struct winsize {
 unsigned short ws_row;
 unsigned short ws_col;
 unsigned short ws_xpixel;
 unsigned short ws_ypixel;
};


struct termio {
 unsigned short c_iflag;
 unsigned short c_oflag;
 unsigned short c_cflag;
 unsigned short c_lflag;
 unsigned char c_line;
 unsigned char c_cc[8];
};
# 17 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/linux/termios.h" 2
# 36 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/termios.h" 2

extern "C" {
# 49 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/termios.h"
static __inline__ int tcgetattr(int fd, struct termios *s)
{
    return ioctl(fd, 0x5401, s);
}

static __inline__ int tcsetattr(int fd, int __opt, const struct termios *s)
{
    return ioctl(fd, __opt, (void *)s);
}

static __inline__ int tcflow(int fd, int action)
{
    return ioctl(fd, 0x540A, (void *)(intptr_t)action);
}

static __inline__ int tcflush(int fd, int __queue)
{
    return ioctl(fd, 0x540B, (void *)(intptr_t)__queue);
}

static __inline__ pid_t tcgetsid(int fd)
{
    pid_t _pid;
    return ioctl(fd, 0x5429, &_pid) ? (pid_t)-1 : _pid;
}

static __inline__ int tcsendbreak(int fd, int __duration)
{
    return ioctl(fd, 0x5425, (void *)(uintptr_t)__duration);
}

static __inline__ speed_t cfgetospeed(const struct termios *s)
{
    return (speed_t)(s->c_cflag & 0010017);
}

static __inline__ int cfsetospeed(struct termios *s, speed_t speed)
{
    s->c_cflag = (s->c_cflag & ~0010017) | (speed & 0010017);
    return 0;
}

static __inline__ speed_t cfgetispeed(const struct termios *s)
{
    return (speed_t)(s->c_cflag & 0010017);
}

static __inline__ int cfsetispeed(struct termios *s, speed_t speed)
{
    s->c_cflag = (s->c_cflag & ~0010017) | (speed & 0010017);
  return 0;
}

static __inline__ void cfmakeraw(struct termios *s)
{
    s->c_iflag &= ~(0000001|0000002|0000010|0000040|0000100|0000200|0000400|0002000);
    s->c_oflag &= ~0000001;
    s->c_lflag &= ~(0000010|0000100|0000002|0000001|0100000);
    s->c_cflag &= ~(0000060|0000400);
    s->c_cflag |= 0000060;
}

}
# 83 "webkey-2.09/service/webkey.cpp" 2
# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/dirent.h" 1
# 34 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/dirent.h"
extern "C" {
# 53 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/dirent.h"
struct dirent {
    uint64_t d_ino;
    int64_t d_off;
    unsigned short d_reclen;
    unsigned char d_type;
    char d_name[256];
};

typedef struct DIR DIR;

extern int getdents(unsigned int, struct dirent*, unsigned int);
extern DIR* opendir(const char* dirpath);
extern DIR* fdopendir(int fd);
extern struct dirent* readdir(DIR* dirp);
extern int readdir_r(DIR* dirp, struct dirent *entry, struct dirent **result);
extern int closedir(DIR* dirp);
extern void rewinddir(DIR *dirp);
extern int dirfd(DIR* dirp);
extern int alphasort(const void *a, const void *b);
extern int scandir(const char *dir, struct dirent ***namelist,
                                 int(*filter)(const struct dirent *),
                                 int(*compar)(const struct dirent **,
                                              const struct dirent **));

}
# 84 "webkey-2.09/service/webkey.cpp" 2

# 1 "webkey-2.09/service/minizip/zip.h" 1
# 44 "webkey-2.09/service/minizip/zip.h"
extern "C" {
# 54 "webkey-2.09/service/minizip/zip.h"
# 1 "webkey-2.09/service/minizip/ioapi.h" 1
# 92 "webkey-2.09/service/minizip/ioapi.h"
typedef unsigned long long int ZPOS64_T;







extern "C" {
# 127 "webkey-2.09/service/minizip/ioapi.h"
typedef voidpf ( *open_file_func) (voidpf opaque, const char* filename, int mode);
typedef uLong ( *read_file_func) (voidpf opaque, voidpf stream, void* buf, uLong size);
typedef uLong ( *write_file_func) (voidpf opaque, voidpf stream, const void* buf, uLong size);
typedef int ( *close_file_func) (voidpf opaque, voidpf stream);
typedef int ( *testerror_file_func) (voidpf opaque, voidpf stream);

typedef long ( *tell_file_func) (voidpf opaque, voidpf stream);
typedef long ( *seek_file_func) (voidpf opaque, voidpf stream, uLong offset, int origin);



typedef struct zlib_filefunc_def_s
{
    open_file_func zopen_file;
    read_file_func zread_file;
    write_file_func zwrite_file;
    tell_file_func ztell_file;
    seek_file_func zseek_file;
    close_file_func zclose_file;
    testerror_file_func zerror_file;
    voidpf opaque;
} zlib_filefunc_def;

typedef ZPOS64_T ( *tell64_file_func) (voidpf opaque, voidpf stream);
typedef long ( *seek64_file_func) (voidpf opaque, voidpf stream, ZPOS64_T offset, int origin);
typedef voidpf ( *open64_file_func) (voidpf opaque, const void* filename, int mode);

typedef struct zlib_filefunc64_def_s
{
    open64_file_func zopen64_file;
    read_file_func zread_file;
    write_file_func zwrite_file;
    tell64_file_func ztell64_file;
    seek64_file_func zseek64_file;
    close_file_func zclose_file;
    testerror_file_func zerror_file;
    voidpf opaque;
} zlib_filefunc64_def;

void fill_fopen64_filefunc (zlib_filefunc64_def* pzlib_filefunc_def);
void fill_fopen_filefunc (zlib_filefunc_def* pzlib_filefunc_def);


typedef struct zlib_filefunc64_32_def_s
{
    zlib_filefunc64_def zfile_func64;
    open_file_func zopen32_file;
    tell_file_func ztell32_file;
    seek_file_func zseek32_file;
} zlib_filefunc64_32_def;
# 186 "webkey-2.09/service/minizip/ioapi.h"
voidpf call_zopen64 (const zlib_filefunc64_32_def* pfilefunc,const void*filename,int mode);
long call_zseek64 (const zlib_filefunc64_32_def* pfilefunc,voidpf filestream, ZPOS64_T offset, int origin);
ZPOS64_T call_ztell64 (const zlib_filefunc64_32_def* pfilefunc,voidpf filestream);

void fill_zlib_filefunc64_32_def_from_filefunc32(zlib_filefunc64_32_def* p_filefunc64_32,const zlib_filefunc_def* p_filefunc32);






}
# 55 "webkey-2.09/service/minizip/zip.h" 2
# 69 "webkey-2.09/service/minizip/zip.h"
typedef voidp zipFile;
# 89 "webkey-2.09/service/minizip/zip.h"
typedef struct tm_zip_s
{
    uInt tm_sec;
    uInt tm_min;
    uInt tm_hour;
    uInt tm_mday;
    uInt tm_mon;
    uInt tm_year;
} tm_zip;

typedef struct
{
    tm_zip tmz_date;
    uLong dosDate;


    uLong internal_fa;
    uLong external_fa;
} zip_fileinfo;

typedef const char* zipcharpc;






extern zipFile zipOpen (const char *pathname, int append);
extern zipFile zipOpen64 (const void *pathname, int append);
# 137 "webkey-2.09/service/minizip/zip.h"
extern zipFile zipOpen2 (const char *pathname, int append, zipcharpc* globalcomment, zlib_filefunc_def* pzlib_filefunc_def);




extern zipFile zipOpen2_64 (const void *pathname, int append, zipcharpc* globalcomment, zlib_filefunc64_def* pzlib_filefunc_def);




extern int zipOpenNewFileInZip (zipFile file, const char* filename, const zip_fileinfo* zipfi, const void* extrafield_local, uInt size_extrafield_local, const void* extrafield_global, uInt size_extrafield_global, const char* comment, int method, int level);
# 158 "webkey-2.09/service/minizip/zip.h"
extern int zipOpenNewFileInZip64 (zipFile file, const char* filename, const zip_fileinfo* zipfi, const void* extrafield_local, uInt size_extrafield_local, const void* extrafield_global, uInt size_extrafield_global, const char* comment, int method, int level, int zip64);
# 187 "webkey-2.09/service/minizip/zip.h"
extern int zipOpenNewFileInZip2 (zipFile file, const char* filename, const zip_fileinfo* zipfi, const void* extrafield_local, uInt size_extrafield_local, const void* extrafield_global, uInt size_extrafield_global, const char* comment, int method, int level, int raw);
# 200 "webkey-2.09/service/minizip/zip.h"
extern int zipOpenNewFileInZip2_64 (zipFile file, const char* filename, const zip_fileinfo* zipfi, const void* extrafield_local, uInt size_extrafield_local, const void* extrafield_global, uInt size_extrafield_global, const char* comment, int method, int level, int raw, int zip64);
# 216 "webkey-2.09/service/minizip/zip.h"
extern int zipOpenNewFileInZip3 (zipFile file, const char* filename, const zip_fileinfo* zipfi, const void* extrafield_local, uInt size_extrafield_local, const void* extrafield_global, uInt size_extrafield_global, const char* comment, int method, int level, int raw, int windowBits, int memLevel, int strategy, const char* password, uLong crcForCrypting);
# 233 "webkey-2.09/service/minizip/zip.h"
extern int zipOpenNewFileInZip3_64 (zipFile file, const char* filename, const zip_fileinfo* zipfi, const void* extrafield_local, uInt size_extrafield_local, const void* extrafield_global, uInt size_extrafield_global, const char* comment, int method, int level, int raw, int windowBits, int memLevel, int strategy, const char* password, uLong crcForCrypting, int zip64 );
# 259 "webkey-2.09/service/minizip/zip.h"
extern int zipOpenNewFileInZip4 (zipFile file, const char* filename, const zip_fileinfo* zipfi, const void* extrafield_local, uInt size_extrafield_local, const void* extrafield_global, uInt size_extrafield_global, const char* comment, int method, int level, int raw, int windowBits, int memLevel, int strategy, const char* password, uLong crcForCrypting, uLong versionMadeBy, uLong flagBase );
# 280 "webkey-2.09/service/minizip/zip.h"
extern int zipOpenNewFileInZip4_64 (zipFile file, const char* filename, const zip_fileinfo* zipfi, const void* extrafield_local, uInt size_extrafield_local, const void* extrafield_global, uInt size_extrafield_global, const char* comment, int method, int level, int raw, int windowBits, int memLevel, int strategy, const char* password, uLong crcForCrypting, uLong versionMadeBy, uLong flagBase, int zip64 );
# 307 "webkey-2.09/service/minizip/zip.h"
extern int zipWriteInFileInZip (zipFile file, const void* buf, unsigned len);






extern int zipCloseFileInZip (zipFile file);




extern int zipCloseFileInZipRaw (zipFile file, uLong uncompressed_size, uLong crc32);



extern int zipCloseFileInZipRaw64 (zipFile file, ZPOS64_T uncompressed_size, uLong crc32);
# 333 "webkey-2.09/service/minizip/zip.h"
extern int zipClose (zipFile file, const char* global_comment);






extern int zipRemoveExtraInfoBlock (char* pData, int* dataLen, short sHeader);
# 359 "webkey-2.09/service/minizip/zip.h"
}
# 86 "webkey-2.09/service/webkey.cpp" 2

# 1 "webkey-2.09/service/sqlite/sqlite3.h" 1
# 35 "webkey-2.09/service/sqlite/sqlite3.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stdarg.h" 1
# 24 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stdarg.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_cprolog.h" 1
# 25 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stdarg.h" 2
# 41 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stdarg.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_epilog.h" 1
# 19 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_epilog.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_config_compat_post.h" 1
# 20 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_epilog.h" 2
# 42 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stdarg.h" 2
# 36 "webkey-2.09/service/sqlite/sqlite3.h" 2





extern "C" {
# 144 "webkey-2.09/service/sqlite/sqlite3.h"
 extern const char sqlite3_version[];
 const char *sqlite3_libversion(void);
 const char *sqlite3_sourceid(void);
 int sqlite3_libversion_number(void);
# 185 "webkey-2.09/service/sqlite/sqlite3.h"
 int sqlite3_threadsafe(void);
# 200 "webkey-2.09/service/sqlite/sqlite3.h"
typedef struct sqlite3 sqlite3;
# 225 "webkey-2.09/service/sqlite/sqlite3.h"
  typedef long long int sqlite_int64;
  typedef unsigned long long int sqlite_uint64;

typedef sqlite_int64 sqlite3_int64;
typedef sqlite_uint64 sqlite3_uint64;
# 263 "webkey-2.09/service/sqlite/sqlite3.h"
 int sqlite3_close(sqlite3 *);






typedef int (*sqlite3_callback)(void*,int,char**, char**);
# 333 "webkey-2.09/service/sqlite/sqlite3.h"
 int sqlite3_exec(
  sqlite3*,
  const char *sql,
  int (*callback)(void*,int,char**,char**),
  void *,
  char **errmsg
);
# 526 "webkey-2.09/service/sqlite/sqlite3.h"
typedef struct sqlite3_file sqlite3_file;
struct sqlite3_file {
  const struct sqlite3_io_methods *pMethods;
};
# 618 "webkey-2.09/service/sqlite/sqlite3.h"
typedef struct sqlite3_io_methods sqlite3_io_methods;
struct sqlite3_io_methods {
  int iVersion;
  int (*xClose)(sqlite3_file*);
  int (*xRead)(sqlite3_file*, void*, int iAmt, sqlite3_int64 iOfst);
  int (*xWrite)(sqlite3_file*, const void*, int iAmt, sqlite3_int64 iOfst);
  int (*xTruncate)(sqlite3_file*, sqlite3_int64 size);
  int (*xSync)(sqlite3_file*, int flags);
  int (*xFileSize)(sqlite3_file*, sqlite3_int64 *pSize);
  int (*xLock)(sqlite3_file*, int);
  int (*xUnlock)(sqlite3_file*, int);
  int (*xCheckReservedLock)(sqlite3_file*, int *pResOut);
  int (*xFileControl)(sqlite3_file*, int op, void *pArg);
  int (*xSectorSize)(sqlite3_file*);
  int (*xDeviceCharacteristics)(sqlite3_file*);

};
# 666 "webkey-2.09/service/sqlite/sqlite3.h"
typedef struct sqlite3_mutex sqlite3_mutex;
# 797 "webkey-2.09/service/sqlite/sqlite3.h"
typedef struct sqlite3_vfs sqlite3_vfs;
struct sqlite3_vfs {
  int iVersion;
  int szOsFile;
  int mxPathname;
  sqlite3_vfs *pNext;
  const char *zName;
  void *pAppData;
  int (*xOpen)(sqlite3_vfs*, const char *zName, sqlite3_file*,
               int flags, int *pOutFlags);
  int (*xDelete)(sqlite3_vfs*, const char *zName, int syncDir);
  int (*xAccess)(sqlite3_vfs*, const char *zName, int flags, int *pResOut);
  int (*xFullPathname)(sqlite3_vfs*, const char *zName, int nOut, char *zOut);
  void *(*xDlOpen)(sqlite3_vfs*, const char *zFilename);
  void (*xDlError)(sqlite3_vfs*, int nByte, char *zErrMsg);
  void (*(*xDlSym)(sqlite3_vfs*,void*, const char *zSymbol))(void);
  void (*xDlClose)(sqlite3_vfs*, void*);
  int (*xRandomness)(sqlite3_vfs*, int nByte, char *zOut);
  int (*xSleep)(sqlite3_vfs*, int microseconds);
  int (*xCurrentTime)(sqlite3_vfs*, double*);
  int (*xGetLastError)(sqlite3_vfs*, int, char *);


};
# 914 "webkey-2.09/service/sqlite/sqlite3.h"
 int sqlite3_initialize(void);
 int sqlite3_shutdown(void);
 int sqlite3_os_init(void);
 int sqlite3_os_end(void);
# 948 "webkey-2.09/service/sqlite/sqlite3.h"
 int sqlite3_config(int, ...);
# 972 "webkey-2.09/service/sqlite/sqlite3.h"
 int sqlite3_db_config(sqlite3*, int op, ...);
# 1044 "webkey-2.09/service/sqlite/sqlite3.h"
typedef struct sqlite3_mem_methods sqlite3_mem_methods;
struct sqlite3_mem_methods {
  void *(*xMalloc)(int);
  void (*xFree)(void*);
  void *(*xRealloc)(void*,int);
  int (*xSize)(void*);
  int (*xRoundup)(int);
  int (*xInit)(void*);
  void (*xShutdown)(void*);
  void *pAppData;
};
# 1306 "webkey-2.09/service/sqlite/sqlite3.h"
 int sqlite3_extended_result_codes(sqlite3*, int onoff);
# 1351 "webkey-2.09/service/sqlite/sqlite3.h"
 sqlite3_int64 sqlite3_last_insert_rowid(sqlite3*);
# 1405 "webkey-2.09/service/sqlite/sqlite3.h"
 int sqlite3_changes(sqlite3*);
# 1431 "webkey-2.09/service/sqlite/sqlite3.h"
 int sqlite3_total_changes(sqlite3*);
# 1470 "webkey-2.09/service/sqlite/sqlite3.h"
 void sqlite3_interrupt(sqlite3*);
# 1505 "webkey-2.09/service/sqlite/sqlite3.h"
 int sqlite3_complete(const char *sql);
 int sqlite3_complete16(const void *sql);
# 1572 "webkey-2.09/service/sqlite/sqlite3.h"
 int sqlite3_busy_handler(sqlite3*, int(*)(void*,int), void*);
# 1592 "webkey-2.09/service/sqlite/sqlite3.h"
 int sqlite3_busy_timeout(sqlite3*, int ms);
# 1663 "webkey-2.09/service/sqlite/sqlite3.h"
 int sqlite3_get_table(
  sqlite3 *db,
  const char *zSql,
  char ***pazResult,
  int *pnRow,
  int *pnColumn,
  char **pzErrmsg
);
 void sqlite3_free_table(char **result);
# 1765 "webkey-2.09/service/sqlite/sqlite3.h"
 char *sqlite3_mprintf(const char*,...);
 char *sqlite3_vmprintf(const char*, va_list);
 char *sqlite3_snprintf(int,char*,const char*, ...);
# 1837 "webkey-2.09/service/sqlite/sqlite3.h"
 void *sqlite3_malloc(int);
 void *sqlite3_realloc(void*, int);
 void sqlite3_free(void*);
# 1864 "webkey-2.09/service/sqlite/sqlite3.h"
 sqlite3_int64 sqlite3_memory_used(void);
 sqlite3_int64 sqlite3_memory_highwater(int resetFlag);
# 1885 "webkey-2.09/service/sqlite/sqlite3.h"
 void sqlite3_randomness(int N, void *P);
# 1967 "webkey-2.09/service/sqlite/sqlite3.h"
 int sqlite3_set_authorizer(
  sqlite3*,
  int (*xAuth)(void*,int,const char*,const char*,const char*,const char*),
  void *pUserData
);
# 2059 "webkey-2.09/service/sqlite/sqlite3.h"
 void *sqlite3_trace(sqlite3*, void(*xTrace)(void*,const char*), void*);
 void *sqlite3_profile(sqlite3*,
   void(*xProfile)(void*,const char*,sqlite3_uint64), void*);
# 2082 "webkey-2.09/service/sqlite/sqlite3.h"
 void sqlite3_progress_handler(sqlite3*, int, int(*)(void*), void*);
# 2173 "webkey-2.09/service/sqlite/sqlite3.h"
 int sqlite3_open(
  const char *filename,
  sqlite3 **ppDb
);
 int sqlite3_open16(
  const void *filename,
  sqlite3 **ppDb
);
 int sqlite3_open_v2(
  const char *filename,
  sqlite3 **ppDb,
  int flags,
  const char *zVfs
);
# 2221 "webkey-2.09/service/sqlite/sqlite3.h"
 int sqlite3_errcode(sqlite3 *db);
 int sqlite3_extended_errcode(sqlite3 *db);
 const char *sqlite3_errmsg(sqlite3*);
 const void *sqlite3_errmsg16(sqlite3*);
# 2250 "webkey-2.09/service/sqlite/sqlite3.h"
typedef struct sqlite3_stmt sqlite3_stmt;
# 2286 "webkey-2.09/service/sqlite/sqlite3.h"
 int sqlite3_limit(sqlite3*, int id, int newVal);
# 2429 "webkey-2.09/service/sqlite/sqlite3.h"
 int sqlite3_prepare(
  sqlite3 *db,
  const char *zSql,
  int nByte,
  sqlite3_stmt **ppStmt,
  const char **pzTail
);
 int sqlite3_prepare_v2(
  sqlite3 *db,
  const char *zSql,
  int nByte,
  sqlite3_stmt **ppStmt,
  const char **pzTail
);
 int sqlite3_prepare16(
  sqlite3 *db,
  const void *zSql,
  int nByte,
  sqlite3_stmt **ppStmt,
  const void **pzTail
);
 int sqlite3_prepare16_v2(
  sqlite3 *db,
  const void *zSql,
  int nByte,
  sqlite3_stmt **ppStmt,
  const void **pzTail
);
# 2465 "webkey-2.09/service/sqlite/sqlite3.h"
 const char *sqlite3_sql(sqlite3_stmt *pStmt);
# 2504 "webkey-2.09/service/sqlite/sqlite3.h"
typedef struct Mem sqlite3_value;
# 2518 "webkey-2.09/service/sqlite/sqlite3.h"
typedef struct sqlite3_context sqlite3_context;
# 2599 "webkey-2.09/service/sqlite/sqlite3.h"
 int sqlite3_bind_blob(sqlite3_stmt*, int, const void*, int n, void(*)(void*));
 int sqlite3_bind_double(sqlite3_stmt*, int, double);
 int sqlite3_bind_int(sqlite3_stmt*, int, int);
 int sqlite3_bind_int64(sqlite3_stmt*, int, sqlite3_int64);
 int sqlite3_bind_null(sqlite3_stmt*, int);
 int sqlite3_bind_text(sqlite3_stmt*, int, const char*, int n, void(*)(void*));
 int sqlite3_bind_text16(sqlite3_stmt*, int, const void*, int, void(*)(void*));
 int sqlite3_bind_value(sqlite3_stmt*, int, const sqlite3_value*);
 int sqlite3_bind_zeroblob(sqlite3_stmt*, int, int n);
# 2627 "webkey-2.09/service/sqlite/sqlite3.h"
 int sqlite3_bind_parameter_count(sqlite3_stmt*);
# 2654 "webkey-2.09/service/sqlite/sqlite3.h"
 const char *sqlite3_bind_parameter_name(sqlite3_stmt*, int);
# 2670 "webkey-2.09/service/sqlite/sqlite3.h"
 int sqlite3_bind_parameter_index(sqlite3_stmt*, const char *zName);
# 2679 "webkey-2.09/service/sqlite/sqlite3.h"
 int sqlite3_clear_bindings(sqlite3_stmt*);
# 2688 "webkey-2.09/service/sqlite/sqlite3.h"
 int sqlite3_column_count(sqlite3_stmt *pStmt);
# 2714 "webkey-2.09/service/sqlite/sqlite3.h"
 const char *sqlite3_column_name(sqlite3_stmt*, int N);
 const void *sqlite3_column_name16(sqlite3_stmt*, int N);
# 2760 "webkey-2.09/service/sqlite/sqlite3.h"
 const char *sqlite3_column_database_name(sqlite3_stmt*,int);
 const void *sqlite3_column_database_name16(sqlite3_stmt*,int);
 const char *sqlite3_column_table_name(sqlite3_stmt*,int);
 const void *sqlite3_column_table_name16(sqlite3_stmt*,int);
 const char *sqlite3_column_origin_name(sqlite3_stmt*,int);
 const void *sqlite3_column_origin_name16(sqlite3_stmt*,int);
# 2796 "webkey-2.09/service/sqlite/sqlite3.h"
 const char *sqlite3_column_decltype(sqlite3_stmt*,int);
 const void *sqlite3_column_decltype16(sqlite3_stmt*,int);
# 2864 "webkey-2.09/service/sqlite/sqlite3.h"
 int sqlite3_step(sqlite3_stmt*);







 int sqlite3_data_count(sqlite3_stmt *pStmt);
# 3060 "webkey-2.09/service/sqlite/sqlite3.h"
 const void *sqlite3_column_blob(sqlite3_stmt*, int iCol);
 int sqlite3_column_bytes(sqlite3_stmt*, int iCol);
 int sqlite3_column_bytes16(sqlite3_stmt*, int iCol);
 double sqlite3_column_double(sqlite3_stmt*, int iCol);
 int sqlite3_column_int(sqlite3_stmt*, int iCol);
 sqlite3_int64 sqlite3_column_int64(sqlite3_stmt*, int iCol);
 const unsigned char *sqlite3_column_text(sqlite3_stmt*, int iCol);
 const void *sqlite3_column_text16(sqlite3_stmt*, int iCol);
 int sqlite3_column_type(sqlite3_stmt*, int iCol);
 sqlite3_value *sqlite3_column_value(sqlite3_stmt*, int iCol);
# 3087 "webkey-2.09/service/sqlite/sqlite3.h"
 int sqlite3_finalize(sqlite3_stmt *pStmt);
# 3113 "webkey-2.09/service/sqlite/sqlite3.h"
 int sqlite3_reset(sqlite3_stmt *pStmt);
# 3195 "webkey-2.09/service/sqlite/sqlite3.h"
 int sqlite3_create_function(
  sqlite3 *db,
  const char *zFunctionName,
  int nArg,
  int eTextRep,
  void *pApp,
  void (*xFunc)(sqlite3_context*,int,sqlite3_value**),
  void (*xStep)(sqlite3_context*,int,sqlite3_value**),
  void (*xFinal)(sqlite3_context*)
);
 int sqlite3_create_function16(
  sqlite3 *db,
  const void *zFunctionName,
  int nArg,
  int eTextRep,
  void *pApp,
  void (*xFunc)(sqlite3_context*,int,sqlite3_value**),
  void (*xStep)(sqlite3_context*,int,sqlite3_value**),
  void (*xFinal)(sqlite3_context*)
);
# 3240 "webkey-2.09/service/sqlite/sqlite3.h"
 int sqlite3_aggregate_count(sqlite3_context*);
 int sqlite3_expired(sqlite3_stmt*);
 int sqlite3_transfer_bindings(sqlite3_stmt*, sqlite3_stmt*);
 int sqlite3_global_recover(void);
 void sqlite3_thread_cleanup(void);
 int sqlite3_memory_alarm(void(*)(void*,sqlite3_int64,int),void*,sqlite3_int64);
# 3293 "webkey-2.09/service/sqlite/sqlite3.h"
 const void *sqlite3_value_blob(sqlite3_value*);
 int sqlite3_value_bytes(sqlite3_value*);
 int sqlite3_value_bytes16(sqlite3_value*);
 double sqlite3_value_double(sqlite3_value*);
 int sqlite3_value_int(sqlite3_value*);
 sqlite3_int64 sqlite3_value_int64(sqlite3_value*);
 const unsigned char *sqlite3_value_text(sqlite3_value*);
 const void *sqlite3_value_text16(sqlite3_value*);
 const void *sqlite3_value_text16le(sqlite3_value*);
 const void *sqlite3_value_text16be(sqlite3_value*);
 int sqlite3_value_type(sqlite3_value*);
 int sqlite3_value_numeric_type(sqlite3_value*);
# 3345 "webkey-2.09/service/sqlite/sqlite3.h"
 void *sqlite3_aggregate_context(sqlite3_context*, int nBytes);
# 3359 "webkey-2.09/service/sqlite/sqlite3.h"
 void *sqlite3_user_data(sqlite3_context*);
# 3370 "webkey-2.09/service/sqlite/sqlite3.h"
 sqlite3 *sqlite3_context_db_handle(sqlite3_context*);
# 3414 "webkey-2.09/service/sqlite/sqlite3.h"
 void *sqlite3_get_auxdata(sqlite3_context*, int N);
 void sqlite3_set_auxdata(sqlite3_context*, int N, void*, void (*)(void*));
# 3432 "webkey-2.09/service/sqlite/sqlite3.h"
typedef void (*sqlite3_destructor_type)(void*);
# 3541 "webkey-2.09/service/sqlite/sqlite3.h"
 void sqlite3_result_blob(sqlite3_context*, const void*, int, void(*)(void*));
 void sqlite3_result_double(sqlite3_context*, double);
 void sqlite3_result_error(sqlite3_context*, const char*, int);
 void sqlite3_result_error16(sqlite3_context*, const void*, int);
 void sqlite3_result_error_toobig(sqlite3_context*);
 void sqlite3_result_error_nomem(sqlite3_context*);
 void sqlite3_result_error_code(sqlite3_context*, int);
 void sqlite3_result_int(sqlite3_context*, int);
 void sqlite3_result_int64(sqlite3_context*, sqlite3_int64);
 void sqlite3_result_null(sqlite3_context*);
 void sqlite3_result_text(sqlite3_context*, const char*, int, void(*)(void*));
 void sqlite3_result_text16(sqlite3_context*, const void*, int, void(*)(void*));
 void sqlite3_result_text16le(sqlite3_context*, const void*, int,void(*)(void*));
 void sqlite3_result_text16be(sqlite3_context*, const void*, int,void(*)(void*));
 void sqlite3_result_value(sqlite3_context*, sqlite3_value*);
 void sqlite3_result_zeroblob(sqlite3_context*, int n);
# 3604 "webkey-2.09/service/sqlite/sqlite3.h"
 int sqlite3_create_collation(
  sqlite3*,
  const char *zName,
  int eTextRep,
  void*,
  int(*xCompare)(void*,int,const void*,int,const void*)
);
 int sqlite3_create_collation_v2(
  sqlite3*,
  const char *zName,
  int eTextRep,
  void*,
  int(*xCompare)(void*,int,const void*,int,const void*),
  void(*xDestroy)(void*)
);
 int sqlite3_create_collation16(
  sqlite3*,
  const void *zName,
  int eTextRep,
  void*,
  int(*xCompare)(void*,int,const void*,int,const void*)
);
# 3653 "webkey-2.09/service/sqlite/sqlite3.h"
 int sqlite3_collation_needed(
  sqlite3*,
  void*,
  void(*)(void*,sqlite3*,int eTextRep,const char*)
);
 int sqlite3_collation_needed16(
  sqlite3*,
  void*,
  void(*)(void*,sqlite3*,int eTextRep,const void*)
);
# 3671 "webkey-2.09/service/sqlite/sqlite3.h"
 int sqlite3_key(
  sqlite3 *db,
  const void *pKey, int nKey
);
# 3684 "webkey-2.09/service/sqlite/sqlite3.h"
 int sqlite3_rekey(
  sqlite3 *db,
  const void *pKey, int nKey
);
# 3703 "webkey-2.09/service/sqlite/sqlite3.h"
 int sqlite3_sleep(int);
# 3734 "webkey-2.09/service/sqlite/sqlite3.h"
 extern char *sqlite3_temp_directory;
# 3757 "webkey-2.09/service/sqlite/sqlite3.h"
 int sqlite3_get_autocommit(sqlite3*);
# 3769 "webkey-2.09/service/sqlite/sqlite3.h"
 sqlite3 *sqlite3_db_handle(sqlite3_stmt*);
# 3784 "webkey-2.09/service/sqlite/sqlite3.h"
 sqlite3_stmt *sqlite3_next_stmt(sqlite3 *pDb, sqlite3_stmt *pStmt);
# 3832 "webkey-2.09/service/sqlite/sqlite3.h"
 void *sqlite3_commit_hook(sqlite3*, int(*)(void*), void*);
 void *sqlite3_rollback_hook(sqlite3*, void(*)(void *), void*);
# 3881 "webkey-2.09/service/sqlite/sqlite3.h"
 void *sqlite3_update_hook(
  sqlite3*,
  void(*)(void *,int ,char const *,char const *,sqlite3_int64),
  void*
);
# 3914 "webkey-2.09/service/sqlite/sqlite3.h"
 int sqlite3_enable_shared_cache(int);
# 3926 "webkey-2.09/service/sqlite/sqlite3.h"
 int sqlite3_release_memory(int);
# 3958 "webkey-2.09/service/sqlite/sqlite3.h"
 void sqlite3_soft_heap_limit(int);
# 4022 "webkey-2.09/service/sqlite/sqlite3.h"
 int sqlite3_table_column_metadata(
  sqlite3 *db,
  const char *zDbName,
  const char *zTableName,
  const char *zColumnName,
  char const **pzDataType,
  char const **pzCollSeq,
  int *pNotNull,
  int *pPrimaryKey,
  int *pAutoinc
);
# 4059 "webkey-2.09/service/sqlite/sqlite3.h"
 int sqlite3_load_extension(
  sqlite3 *db,
  const char *zFile,
  const char *zProc,
  char **pzErrMsg
);
# 4079 "webkey-2.09/service/sqlite/sqlite3.h"
 int sqlite3_enable_load_extension(sqlite3 *db, int onoff);
# 4100 "webkey-2.09/service/sqlite/sqlite3.h"
 int sqlite3_auto_extension(void (*xEntryPoint)(void));
# 4111 "webkey-2.09/service/sqlite/sqlite3.h"
 void sqlite3_reset_auto_extension(void);
# 4127 "webkey-2.09/service/sqlite/sqlite3.h"
typedef struct sqlite3_vtab sqlite3_vtab;
typedef struct sqlite3_index_info sqlite3_index_info;
typedef struct sqlite3_vtab_cursor sqlite3_vtab_cursor;
typedef struct sqlite3_module sqlite3_module;
# 4149 "webkey-2.09/service/sqlite/sqlite3.h"
struct sqlite3_module {
  int iVersion;
  int (*xCreate)(sqlite3*, void *pAux,
               int argc, const char *const*argv,
               sqlite3_vtab **ppVTab, char**);
  int (*xConnect)(sqlite3*, void *pAux,
               int argc, const char *const*argv,
               sqlite3_vtab **ppVTab, char**);
  int (*xBestIndex)(sqlite3_vtab *pVTab, sqlite3_index_info*);
  int (*xDisconnect)(sqlite3_vtab *pVTab);
  int (*xDestroy)(sqlite3_vtab *pVTab);
  int (*xOpen)(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor);
  int (*xClose)(sqlite3_vtab_cursor*);
  int (*xFilter)(sqlite3_vtab_cursor*, int idxNum, const char *idxStr,
                int argc, sqlite3_value **argv);
  int (*xNext)(sqlite3_vtab_cursor*);
  int (*xEof)(sqlite3_vtab_cursor*);
  int (*xColumn)(sqlite3_vtab_cursor*, sqlite3_context*, int);
  int (*xRowid)(sqlite3_vtab_cursor*, sqlite3_int64 *pRowid);
  int (*xUpdate)(sqlite3_vtab *, int, sqlite3_value **, sqlite3_int64 *);
  int (*xBegin)(sqlite3_vtab *pVTab);
  int (*xSync)(sqlite3_vtab *pVTab);
  int (*xCommit)(sqlite3_vtab *pVTab);
  int (*xRollback)(sqlite3_vtab *pVTab);
  int (*xFindFunction)(sqlite3_vtab *pVtab, int nArg, const char *zName,
                       void (**pxFunc)(sqlite3_context*,int,sqlite3_value**),
                       void **ppArg);
  int (*xRename)(sqlite3_vtab *pVtab, const char *zNew);
};
# 4230 "webkey-2.09/service/sqlite/sqlite3.h"
struct sqlite3_index_info {

  int nConstraint;
  struct sqlite3_index_constraint {
     int iColumn;
     unsigned char op;
     unsigned char usable;
     int iTermOffset;
  } *aConstraint;
  int nOrderBy;
  struct sqlite3_index_orderby {
     int iColumn;
     unsigned char desc;
  } *aOrderBy;

  struct sqlite3_index_constraint_usage {
    int argvIndex;
    unsigned char omit;
  } *aConstraintUsage;
  int idxNum;
  char *idxStr;
  int needToFreeIdxStr;
  int orderByConsumed;
  double estimatedCost;
};
# 4286 "webkey-2.09/service/sqlite/sqlite3.h"
 int sqlite3_create_module(
  sqlite3 *db,
  const char *zName,
  const sqlite3_module *p,
  void *pClientData
);
 int sqlite3_create_module_v2(
  sqlite3 *db,
  const char *zName,
  const sqlite3_module *p,
  void *pClientData,
  void(*xDestroy)(void*)
);
# 4319 "webkey-2.09/service/sqlite/sqlite3.h"
struct sqlite3_vtab {
  const sqlite3_module *pModule;
  int nRef;
  char *zErrMsg;

};
# 4344 "webkey-2.09/service/sqlite/sqlite3.h"
struct sqlite3_vtab_cursor {
  sqlite3_vtab *pVtab;

};
# 4358 "webkey-2.09/service/sqlite/sqlite3.h"
 int sqlite3_declare_vtab(sqlite3*, const char *zSQL);
# 4377 "webkey-2.09/service/sqlite/sqlite3.h"
 int sqlite3_overload_function(sqlite3*, const char *zFuncName, int nArg);
# 4403 "webkey-2.09/service/sqlite/sqlite3.h"
typedef struct sqlite3_blob sqlite3_blob;
# 4461 "webkey-2.09/service/sqlite/sqlite3.h"
 int sqlite3_blob_open(
  sqlite3*,
  const char *zDb,
  const char *zTable,
  const char *zColumn,
  sqlite3_int64 iRow,
  int flags,
  sqlite3_blob **ppBlob
);
# 4493 "webkey-2.09/service/sqlite/sqlite3.h"
 int sqlite3_blob_close(sqlite3_blob *);
# 4508 "webkey-2.09/service/sqlite/sqlite3.h"
 int sqlite3_blob_bytes(sqlite3_blob *);
# 4536 "webkey-2.09/service/sqlite/sqlite3.h"
 int sqlite3_blob_read(sqlite3_blob *, void *Z, int N, int iOffset);
# 4574 "webkey-2.09/service/sqlite/sqlite3.h"
 int sqlite3_blob_write(sqlite3_blob *, const void *z, int n, int iOffset);
# 4605 "webkey-2.09/service/sqlite/sqlite3.h"
 sqlite3_vfs *sqlite3_vfs_find(const char *zVfsName);
 int sqlite3_vfs_register(sqlite3_vfs*, int makeDflt);
 int sqlite3_vfs_unregister(sqlite3_vfs*);
# 4723 "webkey-2.09/service/sqlite/sqlite3.h"
 sqlite3_mutex *sqlite3_mutex_alloc(int);
 void sqlite3_mutex_free(sqlite3_mutex*);
 void sqlite3_mutex_enter(sqlite3_mutex*);
 int sqlite3_mutex_try(sqlite3_mutex*);
 void sqlite3_mutex_leave(sqlite3_mutex*);
# 4795 "webkey-2.09/service/sqlite/sqlite3.h"
typedef struct sqlite3_mutex_methods sqlite3_mutex_methods;
struct sqlite3_mutex_methods {
  int (*xMutexInit)(void);
  int (*xMutexEnd)(void);
  sqlite3_mutex *(*xMutexAlloc)(int);
  void (*xMutexFree)(sqlite3_mutex *);
  void (*xMutexEnter)(sqlite3_mutex *);
  int (*xMutexTry)(sqlite3_mutex *);
  void (*xMutexLeave)(sqlite3_mutex *);
  int (*xMutexHeld)(sqlite3_mutex *);
  int (*xMutexNotheld)(sqlite3_mutex *);
};
# 4838 "webkey-2.09/service/sqlite/sqlite3.h"
 int sqlite3_mutex_held(sqlite3_mutex*);
 int sqlite3_mutex_notheld(sqlite3_mutex*);
# 4871 "webkey-2.09/service/sqlite/sqlite3.h"
 sqlite3_mutex *sqlite3_db_mutex(sqlite3*);
# 4899 "webkey-2.09/service/sqlite/sqlite3.h"
 int sqlite3_file_control(sqlite3*, const char *zDbName, int op, void*);
# 4918 "webkey-2.09/service/sqlite/sqlite3.h"
 int sqlite3_test_control(int op, ...);
# 4976 "webkey-2.09/service/sqlite/sqlite3.h"
 int sqlite3_status(int op, int *pCurrent, int *pHighwater, int resetFlag);
# 5084 "webkey-2.09/service/sqlite/sqlite3.h"
 int sqlite3_db_status(sqlite3*, int op, int *pCur, int *pHiwtr, int resetFlg);
# 5132 "webkey-2.09/service/sqlite/sqlite3.h"
 int sqlite3_stmt_status(sqlite3_stmt*, int op,int resetFlg);
# 5171 "webkey-2.09/service/sqlite/sqlite3.h"
typedef struct sqlite3_pcache sqlite3_pcache;
# 5301 "webkey-2.09/service/sqlite/sqlite3.h"
typedef struct sqlite3_pcache_methods sqlite3_pcache_methods;
struct sqlite3_pcache_methods {
  void *pArg;
  int (*xInit)(void*);
  void (*xShutdown)(void*);
  sqlite3_pcache *(*xCreate)(int szPage, int bPurgeable);
  void (*xCachesize)(sqlite3_pcache*, int nCachesize);
  int (*xPagecount)(sqlite3_pcache*);
  void *(*xFetch)(sqlite3_pcache*, unsigned key, int createFlag);
  void (*xUnpin)(sqlite3_pcache*, void*, int discard);
  void (*xRekey)(sqlite3_pcache*, void*, unsigned oldKey, unsigned newKey);
  void (*xTruncate)(sqlite3_pcache*, unsigned iLimit);
  void (*xDestroy)(sqlite3_pcache*);
};
# 5327 "webkey-2.09/service/sqlite/sqlite3.h"
typedef struct sqlite3_backup sqlite3_backup;
# 5506 "webkey-2.09/service/sqlite/sqlite3.h"
 sqlite3_backup *sqlite3_backup_init(
  sqlite3 *pDest,
  const char *zDestName,
  sqlite3 *pSource,
  const char *zSourceName
);
 int sqlite3_backup_step(sqlite3_backup *p, int nPage);
 int sqlite3_backup_finish(sqlite3_backup *p);
 int sqlite3_backup_remaining(sqlite3_backup *p);
 int sqlite3_backup_pagecount(sqlite3_backup *p);
# 5632 "webkey-2.09/service/sqlite/sqlite3.h"
 int sqlite3_unlock_notify(
  sqlite3 *pBlocked,
  void (*xNotify)(void **apArg, int nArg),
  void *pNotifyArg
);
# 5648 "webkey-2.09/service/sqlite/sqlite3.h"
 int sqlite3_strnicmp(const char *, const char *, int);
# 5668 "webkey-2.09/service/sqlite/sqlite3.h"
 void sqlite3_log(int iErrCode, const char *zFormat, ...);
# 5678 "webkey-2.09/service/sqlite/sqlite3.h"
int sqlite3_set_transaction_default_immediate(sqlite3*, int immediate);
# 5689 "webkey-2.09/service/sqlite/sqlite3.h"
}
# 88 "webkey-2.09/service/webkey.cpp" 2


# 1 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/android/log.h" 1
# 70 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/android/log.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stdarg.h" 1
# 24 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stdarg.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_cprolog.h" 1
# 25 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stdarg.h" 2
# 41 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stdarg.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_epilog.h" 1
# 19 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_epilog.h"
# 1 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_config_compat_post.h" 1
# 20 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stl/_epilog.h" 2
# 42 "/home/petya/download/android-ndk-r8b/sources/cxx-stl/stlport/stlport/stdarg.h" 2
# 71 "/home/petya/download/android-ndk-r8b/platforms/android-3/arch-arm/usr/include/android/log.h" 2


extern "C" {





typedef enum android_LogPriority {
    ANDROID_LOG_UNKNOWN = 0,
    ANDROID_LOG_DEFAULT,
    ANDROID_LOG_VERBOSE,
    ANDROID_LOG_DEBUG,
    ANDROID_LOG_INFO,
    ANDROID_LOG_WARN,
    ANDROID_LOG_ERROR,
    ANDROID_LOG_FATAL,
    ANDROID_LOG_SILENT,
} android_LogPriority;




int __android_log_write(int prio, const char *tag, const char *text);




int __android_log_print(int prio, const char *tag, const char *fmt, ...)

    __attribute__ ((format(printf, 3, 4)))

    ;





int __android_log_vprint(int prio, const char *tag,
                         const char *fmt, va_list ap);





void __android_log_assert(const char *cond, const char *tag,
     const char *fmt, ...)

    __attribute__ ((noreturn))
    __attribute__ ((format(printf, 3, 4)))

    ;


}
# 91 "webkey-2.09/service/webkey.cpp" 2





FILE *stderr = stderr;







struct structfilename{
 const char* name;
};

static struct structfilename screencapbinaries[]{
 {"/system/bin/screencap"},
 {"/system/sbin/screencap"},
 {"/vendor/bin/screencap"},
 {"/sbin/screencap"},
 {"/data/data/com.magicandroidapps.bettertermpro/bin/screencap"},
 {"/system/bin/fbread 2>&1"},
 {"/system/sbin/fbread 2>&1"},
 {"/vendor/bin/fbread 2>&1"},
 {"/sbin/fbread 2>&1"},
 {"/data/data/com.magicandroidapps.bettertermpro/bin/fbread 2>&1"},

 {__null}
};






static struct pid {
 struct pid *next;
 FILE *fp;
 pid_t pid;
} *pidlist;

static sqlite3 *db;
struct stat info;


FILE *
mypopen(const char *program, const char *type)
{
 struct pid * volatile cur;
 FILE *iop;
 int pdes[2];
 pid_t pid;

 if ((*type != 'r' && *type != 'w') || type[1] != '\0') {
  (*__errno()) = 22;
  return (__null);
 }

 if ((cur = (struct pid*)malloc(sizeof(struct pid))) == __null)
  return (__null);

 if (pipe(pdes) < 0) {
  free(cur);
  return (__null);
 }

 switch (pid = fork()) {
 case -1:
  (void)close(pdes[0]);
  (void)close(pdes[1]);
  free(cur);
  return (__null);

 case 0:
     {
  struct pid *pcur;




  for (pcur = pidlist; pcur; pcur = pcur->next)
   close(((pcur->fp)->_file));

  if (*type == 'r') {
   int tpdes1 = pdes[1];

   (void) close(pdes[0]);




   if (tpdes1 != 1) {
    (void)dup2(tpdes1, 1);
    (void)close(tpdes1);
    tpdes1 = 1;
   }
  } else {
   (void)close(pdes[1]);
   if (pdes[0] != 0) {
    (void)dup2(pdes[0], 0);
    (void)close(pdes[0]);
   }
  }
  execl("/system/bin/sh", "sh", "-c", program, (char *)__null);
  _exit(127);

     }
 }



 if (*type == 'r') {
  iop = fdopen(pdes[0], type);
  (void)close(pdes[1]);
 } else {
  iop = fdopen(pdes[1], type);
  (void)close(pdes[0]);
 }


 cur->fp = iop;
 cur->pid = pid;
 cur->next = pidlist;
 pidlist = cur;

 return (iop);
}






int
mypclose(FILE *iop)
{
 struct pid *cur, *last;
 int pstat;
 pid_t pid;


 for (last = __null, cur = pidlist; cur; last = cur, cur = cur->next)
  if (cur->fp == iop)
   break;

 if (cur == __null)
  return (-1);

  signal(13,(( __sighandler_t)1));
 (void)fclose(iop);

 do {
  pid = waitpid(cur->pid, &pstat, 0);
 } while (pid == -1 && (*__errno()) == 4);


 if (last == __null)
  pidlist = cur->next;
 else
  last->next = cur->next;
 free(cur);

 return (pid == -1 ? -1 : pstat);
}


struct SESSION
{
 int ptm;
 int oldwidth;
 int oldheight;
 int alive;
 pid_t pid;
 time_t lastused;
 pthread_mutex_t mutex;
};

struct eqstr
{
 bool operator()(const char* s1, const char* s2) const
 {
  return strcmp(s1, s2) == 0;
 }
};


static std::map<std::string, std::string> sl4a_requests;
static std::map<std::string, int> sl4a_requests_rev;

static std::map<std::string, time_t> access_times;
static std::string logfile;

char modelname[92];
char manufacturer[92];

static char deflanguage[92];

static bool has_ssl = false;

volatile static int sl4a_port = 0;
volatile static int sl4a_socket = 0;
static std::string sl4a_uuid;
static pthread_mutex_t sl4amutex;

char* humandate(char* buff, long int epoch, int dateformat, int datesep, int datein, int datetimezone);
static pthread_mutex_t logmutex;
static pthread_mutex_t netmutex;
static pthread_mutex_t initfbmutex;
static void
access_log(const struct mg_request_info *ri, const char* s)
{

 pthread_mutex_lock(&logmutex);
 std::string log;
 if (ri && ri->remote_user)
 {
  log = ri->remote_user;
  log += ": ";
 }
 log += s;
 time_t last = access_times[log];

 struct timeval tv;
 gettimeofday(&tv,0);
 time_t now = tv.tv_sec;
 if (last == 0 || now > last+1800)
 {
  FILE* f = fopen(logfile.c_str(),"a");
  if (f)
  {
   char conv[4096];
   fprintf(f,"[%s] %s\n",humandate(conv,now,0,0,0,0),log.c_str());
   fclose(f);
  }
  access_times[log] = now;


 }
 pthread_mutex_unlock(&logmutex);

}

static void read_post_data(struct mg_connection *conn,
                const struct mg_request_info *ri, char** post_data, int* post_data_len)
{
 int l = contentlen(conn);
 if (l > 65536)
  l = 65536;
 *post_data = new char[l+1];
 *post_data_len = mg_read(conn,*post_data,l);
 (*post_data)[*post_data_len] = 0;

}




static std::vector<std::string> net_iface;
static std::vector<uint64_t> net_usage;

static std::vector<SESSION*> sessions;

static bool samsung = false;
static bool ignore_framebuffer = false;
static bool force_240 = false;
static bool force_544 = false;
static bool flip_touch = false;
static bool rotate_touch = false;
static bool touch_mxt224_ts_input = false;
static bool is_handle_m = false;
static bool is_reverse_colors = false;
static bool disable_mouse_pointer = false;
static bool is_icecreamsandwich = false;
static bool use_generic = false;
static bool run_load_keys = true;
static bool geniatech = false;
static bool use_uinput_mouse = false;

static int pipeforward[2];
static int pipeback[2];
static FILE* pipein;
static FILE* pipeout;

static char* server_username = __null;
static char* server_random = __null;
static bool server;
static int server_changes = 0;

static std::string requested_username;
static std::string requested_password;
static __u32 requested_ip;

static int port=80;
static int sslport=443;
static char upload_random[11];

static std::string dir;
static int dirdepth = 0;
static std::string passfile;

struct mg_context *ctx;
static char position_value[512];
static std::string mimetypes[32];


volatile static bool firstfb = false;


volatile static int position_id = 0;

volatile static bool gps_active = false;
volatile static time_t last_gps_time =0;

volatile static int up = 0;
volatile static int shutdownkey_up = -1;

volatile static bool recording = false;
volatile static int recordingnum = 0;
volatile static int recordingnumfinished = -1;
static void
signal_handler(int sig_num)
{
        if (sig_num == 17)
                while (waitpid(-1, &sig_num, 0x00000001) > 0);
        else
                exit_flag = sig_num;
}

struct MESSAGE
{
 std::string user;
 time_t timestamp;
 std::string message;
};

static time_t chat_random;
static std::vector<MESSAGE> chat_messages;
static std::map<std::string,int> chat_readby;
static std::map<std::string,int> chat_readby_real;
static std::map<std::string,int> chat_readby_count;
static int chat_count;
static pthread_mutex_t chatmutex;
static pthread_cond_t chatcond;


volatile static bool wakelock;
volatile static time_t wakelock_lastused;
static pthread_mutex_t wakelockmutex;

static void lock_wakelock()
{
 pthread_mutex_lock(&wakelockmutex);
 if (!wakelock)
 {
  wakelock = true;
  int fd = open("/sys/power/wake_lock", 00000001);
  if(fd >= 0)
  {
   write(fd, "Webkey\n", 7);
   close(fd);
  }
 }
 struct timeval tv;
 gettimeofday(&tv,0);
 wakelock_lastused = tv.tv_sec;
 pthread_mutex_unlock(&wakelockmutex);
}
static void unlock_wakelock(bool force)
{
 pthread_mutex_lock(&wakelockmutex);
 if (wakelock)
 {
  struct timeval tv;
  gettimeofday(&tv,0);
  if (force || wakelock_lastused +30 < tv.tv_sec)
  {
   int fd = open("/sys/power/wake_unlock", 00000001);
   if(fd >= 0)
   {
    wakelock = false;
    write(fd, "Webkey\n", 7);
    close(fd);
   }
  }
 }
 pthread_mutex_unlock(&wakelockmutex);
}


static int sendit(int timeout_ms)
{
    int nwr, ret, fd;
    char value[20];

    fd = open("/sys/class/timed_output/vibrator/enable", 00000002);
    if(fd < 0)
        return (*__errno());

    nwr = sprintf(value, "%d\n", timeout_ms);
    ret = write(fd, value, nwr);

    close(fd);

    return (ret == nwr) ? 0 : -1;
}

static int vibrator_on(int timeout_ms)
{

    return sendit(timeout_ms);
}

static int vibrator_off()
{
    return sendit(0);
}

static int
write_int(char const* path, int value)
{
    int fd;
    static int already_warned = 0;

    fd = open(path, 00000002);
    if (fd >= 0) {
        char buffer[20];
        int bytes = sprintf(buffer, "%d\n", value);
        int amt = write(fd, buffer, bytes);
        close(fd);
        return amt == -1 ? -(*__errno()) : 0;
    } else {
        if (already_warned == 0) {
            printf("write_int failed to open %s\n", path);
            already_warned = 1;
        }
        return -(*__errno());
    }
}


static void set_blink(bool blink,int onMS,int offMS)
{

 int freq, pwm;
 if (onMS > 0 && offMS > 0) {
  int totalMS = onMS + offMS;



  freq = totalMS / 50;



  pwm = (onMS * 255) / totalMS;


  if (pwm > 0 && pwm < 16)
   pwm = 16;
 } else {
  blink = 0;
  freq = 0;
  pwm = 0;
 }
 write_int("/sys/class/leds/red/device/blink",blink?1:0);
 write_int("/sys/class/leds/red/device/grpfreq",freq);
 write_int("/sys/class/leds/red/device/grppwm",pwm);

}

struct NOTIFY{
 bool smson;
 bool callon;
 int interval;
 bool vibrate;
 std::string vibratepatt;
 bool blink;
 int blinktype;
 int blinkon;
 int blinkoff;
 time_t lastalarm;
 bool smsalarmed;
 bool callalarmed;
 unsigned long lastsmstime;
 unsigned long lastcalltime;
};

static struct NOTIFY notify;

static int fbfd = -1;
static int screencap = -1;
static int screencap_skipbytes = 0;
static void *fbmmap = ((void *)-1);
static int fbmmapsize = 0;
static int bytespp = 0;
static int lowest_offset = 0;
static struct fb_var_screeninfo scrinfo;
static png_byte* pict = __null;
static png_byte** graph = __null;
unsigned int* copyfb = __null;
static int* lastpic = __null;
static bool lastorient = 0;
static bool lastflip = 0;
static bool picchanged = true;
static int touchfd = -1;
static __s32 xmin;
static __s32 xmax;
static __s32 ymin;
static __s32 ymax;
static int newsockfd = -1;

static int max_brightness;

static bool dyndns = false;
static __u32 dyndns_last_updated_ip = 0;
static std::string dyndns_host;
static std::string dyndns_base64;


static pthread_mutex_t pngmutex;
static pthread_mutex_t fbmutex;
static pthread_mutex_t diffmutex;
static pthread_mutex_t popenmutex;
static pthread_mutex_t uinputmutex;

static pthread_cond_t diffcond;
static pthread_cond_t diffstartcond;
volatile static int diffcondWaitCounter = 0;
volatile static int diffcondDiffCounter = 0;
# 634 "webkey-2.09/service/webkey.cpp"
static const char* KCM_BASE[] ={
"A 'A' '2' 'a' 'A'",
"B 'B' '2' 'b' 'B'",
"C 'C' '2' 'c' 'C'",
"D 'D' '3' 'd' 'D'",
"E 'E' '3' 'e' 'E'",
"F 'F' '3' 'f' 'F'",
"G 'G' '4' 'g' 'G'",
"H 'H' '4' 'h' 'H'",
"I 'I' '4' 'i' 'I'",
"J 'J' '5' 'j' 'J'",
"K 'K' '5' 'k' 'K'",
"L 'L' '5' 'l' 'L'",
"M 'M' '6' 'm' 'M'",
"N 'N' '6' 'n' 'N'",
"O 'O' '6' 'o' 'O'",
"P 'P' '7' 'p' 'P'",
"Q 'Q' '7' 'q' 'Q'",
"R 'R' '7' 'r' 'R'",
"S 'S' '7' 's' 'S'",
"T 'T' '8' 't' 'T'",
"U 'U' '8' 'u' 'U'",
"V 'V' '8' 'v' 'V'",
"W 'W' '9' 'w' 'W'",
"X 'X' '9' 'x' 'X'",
"Y 'Y' '9' 'y' 'Y'",
"Z 'Z' '9' 'z' 'Z'",
"COMMA ',' ',' ',' '?'",
"PERIOD '.' '.' '.' '/'",
"AT '@' 0x00 '@' '~'",
"SPACE 0x20 0x20 0x20 0x20",
"ENTER 0xa 0xa 0xa 0xa",
"0 '0' '0' '0' ')'",
"1 '1' '1' '1' '!'",
"2 '2' '2' '2' '@'",
"3 '3' '3' '3' '#'",
"4 '4' '4' '4' '$'",
"5 '5' '5' '5' '%'",
"6 '6' '6' '6' '^'",
"7 '7' '7' '7' '&'",
"8 '8' '8' '8' '*'",
"9 '9' '9' '9' '('",
"TAB 0x9 0x9 0x9 0x9",
"GRAVE '`' '`' '`' '~'",
"MINUS '-' '-' '-' '_'",
"EQUALS '=' '=' '=' '+'",
"LEFT_BRACKET '[' '[' '[' '{'",
"RIGHT_BRACKET ']' ']' ']' '}'",
"BACKSLASH '\\' '\\' '\\' '|'",
"SEMICOLON ';' ';' ';' ':'",
"APOSTROPHE '\'' '\'' '\'' '\"'",
"STAR '*' '*' '*' '<'",
"POUND '#' '#' '#' '>'",
"PLUS '+' '+' '+' '+'",
"SLASH '/' '/' '/' '?'"
};

static const char* KCM_BASE2[] ={
"A 'A' '2' 'a' 'A'",
"B 'B' '2' 'b' 'B'",
"C 'C' '2' 'c' 'C'",
"D 'D' '3' 'd' 'D'",
"E 'E' '3' 'e' 'E'",
"F 'F' '3' 'f' 'F'",
"G 'G' '4' 'g' 'G'",
"H 'H' '4' 'h' 'H'",
"I 'I' '4' 'i' 'I'",
"J 'J' '5' 'j' 'J'",
"K 'K' '5' 'k' 'K'",
"L 'L' '5' 'l' 'L'",
"M 'M' '6' 'm' 'M'",
"N 'N' '6' 'n' 'N'",
"O 'O' '6' 'o' 'O'",
"P 'P' '7' 'p' 'P'",
"Q 'Q' '7' 'q' 'Q'",
"R 'R' '7' 'r' 'R'",
"S 'S' '7' 's' 'S'",
"T 'T' '8' 't' 'T'",
"U 'U' '8' 'u' 'U'",
"V 'V' '8' 'v' 'V'",
"W 'W' '9' 'w' 'W'",
"X 'X' '9' 'x' 'X'",
"Y 'Y' '9' 'y' 'Y'",
"Z 'Z' '9' 'z' 'Z'",
"COMMA ',' ',' ',' '?'",
"PERIOD '.' '.' '.' '/'",
"AT '@' '@' '@' '~'",
"SPACE ' ' ' ' ' ' ' '",
"ENTER '\\n' '\\n' '\\n' '\\n'",
"0 '0' '0' '0' ')'",
"1 '1' '1' '1' '!'",
"2 '2' '2' '2' '@'",
"3 '3' '3' '3' '#'",
"4 '4' '4' '4' '$'",
"5 '5' '5' '5' '%'",
"6 '6' '6' '6' '^'",
"7 '7' '7' '7' '&'",
"8 '8' '8' '8' '*'",
"9 '9' '9' '9' '('",
"TAB '\\t' '\\t' '\\t' '\\t'",
"GRAVE '`' '`' '`' '~'",
"MINUS '-' '-' '-' '_'",
"EQUALS '=' '=' '=' '+'",
"LEFT_BRACKET '[' '[' '[' '{'",
"RIGHT_BRACKET ']' ']' ']' '}'",
"BACKSLASH '\\\\' '\\\\' '\\\\' '|'",
"SEMICOLON ';' ';' ';' ':'",
"APOSTROPHE '\\\'' '\\\'' '\\\'' '\"'",
"STAR '*' '*' '*' '<'",
"POUND '#' '#' '#' '>'",
"PLUS '+' '+' '+' '+'",
"SLASH '/' '/' '/' '?'"
};



int spec1[] = {62,8,75,10,11,12,14,75,16,7,15,70,55,69,56,56,52};
int spec1sh[] = {0,1,1,1,1,1,1,0,1,1,1,1,0,0,0,1};

int spec2[] = {74,74,17,70,18,55,77};
int spec2sh[] = {1,0,1,0,1,1,0};

int spec3[] = {71,73,72,13,69,68};
int spec3sh[] = {0,0,0,1,1,0};

int spec4[] = {71,73,72,68};
int spec4sh[] = {1,1,1,1,0};


struct BIND{
 int ajax;
 int disp;
 int kcm;
 bool kcm_sh;
 bool sms;
};

struct FAST{
 bool show;
 char* name;
 int ajax;
};

struct DEVSPEC{
 int dev;
 int type;
 int code;
};

static std::map<std::string, std::string> device_names;
static std::vector<BIND*> speckeys;
static std::vector<FAST*> fastkeys;

static int uinput_fd = -1;

bool startswith(const char* st, char* patt)
{
 int i = 0;
 while(patt[i])
 {
  if (st[i] == 0 || st[i]-patt[i])
   return false;
  i++;
 }
 return true;
}
bool urlcompare(const char* url, char* patt)
{
 int i = 0;
 while(true)
 {
  if (patt[i] == '*')
   return true;
  if ((!patt[i] && url[i]) || (patt[i] && !url[i]))
   return false;
  if (!patt[i] && !url[i])
   return true;
  if (url[i]-patt[i])
   return false;
  i++;
 }
}
bool cmp(const char* st, char* patt)
{
 int i = 0;
 while(patt[i] && st[i])
 {
  if (st[i]-patt[i])
   return false;
  i++;
 }
 if (st[i]-patt[i])
  return false;
 return true;
}


int contains(const char* st, const char* patt)
{
 int n = strlen(st);
 int m = strlen(patt);
 int i,j;
 for (i = 0; i<n-m+1; i++)
 {
  for (j=0;j<m;j++)
   if (st[i+j]!=patt[j])
    break;
  if (j==m)
   return i;
 }
 return 0;
}

static void init_fb_for_test()
{




}
char* humandur(char* buff, int secs)
{
 if (secs < 60)
  sprintf(buff,"%d secs",secs);
 else
 if (secs < 120)
  sprintf(buff,"1 min %d secs",secs%60);
 else
 if (secs < 3600)
  sprintf(buff,"%d mins %d secs",secs/60,secs%60);
 else
  sprintf(buff,"%d hours %d mins %d secs",secs/3600,(secs/60)%60,secs%60);
 return buff;
};

char* humandate(char* buff, long int epoch, int dateformat, int datesep, int datein, int datetimezone)
{
 if (datein == 1)
 {
  sprintf(buff,"%d",epoch);
  return buff;
 }
 time_t d = epoch + datetimezone*3600;
 struct tm* timeinfo;
 timeinfo = gmtime( &d );
 int a,b,c;
 if (dateformat == 0)
 {
  a = timeinfo->tm_mday; b = timeinfo->tm_mon+1; c = timeinfo->tm_year+1900;
 }
 if (dateformat == 1)
 {
  a = timeinfo->tm_mon+1; b = timeinfo->tm_mday; c = timeinfo->tm_year+1900;
 }
 if (dateformat == 2)
 {
  a = timeinfo->tm_year+1900; b = timeinfo->tm_mon+1; c = timeinfo->tm_mday;
 }
 if (datesep == 0) sprintf(buff,"%.2d/%.2d/%.2d %d:%.2d",a,b,c, timeinfo->tm_hour,timeinfo->tm_min);
 if (datesep == 1) sprintf(buff,"%.2d-%.2d-%.2d %d:%.2d",a,b,c, timeinfo->tm_hour,timeinfo->tm_min);
 if (datesep == 2) sprintf(buff,"%.2d.%.2d.%.2d. %d:%.2d",a,b,c, timeinfo->tm_hour,timeinfo->tm_min);
 return buff;
}


char* itoa(char* buff, int value)
{
 unsigned int i = 0;
 bool neg = false;
 if (value<0)
 {
  neg = true;
  value=-value;
 }
 if (value==0)
  buff[i++] = '0';
 else
  while(value)
  {
   buff[i++] = '0'+(char)(value%10);
   value = value/10;
  }
 if (neg)
  buff[i++] = '-';
 unsigned int j = 0;
 for(j = 0; j < (i>>1); j++)
 {
  char t = buff[j];
  buff[j] = buff[i-j-1];
  buff[i-j-1] = t;
 }
 buff[i++]=0;
 return buff;
}

long int getnum(const char* st)
{
 long int r = 0;
 long int i = 0;
 bool neg = false;
 if (st[i]=='-')
 {
  neg = true;
  i++;
 }
 while ('0'<=st[i] && '9'>=st[i])
 {
  r = r*10+(long int)(st[i]-'0');
  i++;
 }
 if (neg)
  return -r;
 else
  return r;
}
static void syst(const char* cmd)
{



 system(cmd);
}
int getnum(char* st)
{
 int r = 0;
 int i = 0;
 bool neg = false;
 if (st[i]=='-')
 {
  neg = true;
  i++;
 }
 while ('0'<=st[i] && '9'>=st[i])
 {
  r = r*10+(int)(st[i]-'0');
  i++;
 }
 if (neg)
  return -r;
 else
  return r;
}

char* removesemicolon(char* to, const char* from)
{
 int i = 0;
 while(from[i] && i < 4096 - 1)
 {
  if(from[i] == ';')
   to[i] = ',';
  else
   to[i] = from[i];
  i++;
 }
 to[i++] = 0;
 return to;
}

bool check_type(const char* type1, const char* type2)
{
 int i = 0;
 int j = 0;
 while (type1[i] || type2[j])
 {
  while(type1[i] && (type1[i]<'a' || type1[i]>'z') && (type1[i]<'A' || type1[i]>'Z') && (type1[i]<'0' || type1[i]>'9')) i++;
  while(type2[j] && (type2[j]<'a' || type2[j]>'z') && (type2[j]<'A' || type2[j]>'Z') && (type2[j]<'0' || type2[j]>'9')) j++;
  if (!type1[i] && !type2[j])
   return true;
  char n1 = type1[i];
  char n2 = type2[j];
  if (n1 >= 'A' && n1 <= 'Z')
   n1 = n1 - 'A' + 'a';
  if (n2 >= 'A' && n2 <= 'Z')
   n2 = n2 - 'A' + 'a';
  if (n1 != n2)
   return false;
  i++;
  j++;
 }
}

void send_ok(struct mg_connection *conn, const char* extra = __null,int size = 0)

{
 if (size)
 {
  if (extra)
   mg_printf(conn,"HTTP/1.1 200 OK\r\nCache-Control: no-store, no-cache, must-revalidate\r\nCache-Control: post-check=0, pre-check=0\r\nPragma: no-cache\r\nConnection: close\r\nContent-Length: %d\r\n%s\r\n\r\n",size,extra);
  else
   mg_printf(conn,"HTTP/1.1 200 OK\r\nCache-Control: no-store, no-cache, must-revalidate\r\nCache-Control: post-check=0, pre-check=0\r\nPragma: no-cache\r\nConnection: close\r\nContent-Length: %d\r\n\r\n",size);
 }
 else
 {
  if (extra)
   mg_printf(conn,"HTTP/1.1 200 OK\r\nCache-Control: no-store, no-cache, must-revalidate\r\nCache-Control: post-check=0, pre-check=0\r\nPragma: no-cache\r\nConnection: close\r\n%s\r\n\r\n",extra);
  else
   mg_printf(conn,"HTTP/1.1 200 OK\r\nCache-Control: no-store, no-cache, must-revalidate\r\nCache-Control: post-check=0, pre-check=0\r\nPragma: no-cache\r\nConnection: close\r\n\r\n");
 }
}
void clear(bool exit = true)
{
 int i;
 for(i=0; i < speckeys.size(); i++)
  if (speckeys[i])
   delete speckeys[i];
 speckeys.clear();
 for(i=0; i < fastkeys.size(); i++)
  if (fastkeys[i])
  {
   delete[] fastkeys[i]->name;
   delete fastkeys[i];
  }
 fastkeys.clear();
 if (uinput_fd != -1)
 {
  pthread_mutex_lock(&uinputmutex);
  suinput_close(uinput_fd);
  uinput_fd = -1;
  pthread_mutex_unlock(&uinputmutex);
 }
 if (exit)
 {
  if (pict)
   delete[] pict;
  pict = __null;
  if (lastpic)
   delete[] lastpic;
  lastpic = __null;
  if (graph)
   delete[] graph;
  graph = __null;
  if (copyfb)
   delete[] copyfb;
  copyfb = __null;
  if (gps_active)
   syst("/system/bin/am broadcast -a \"webkey.intent.action.GPS.STOP\" -n \"com.webkey/.GPS\"&");
  if (server_username)
   delete[] server_username;
  server_username = __null;
  if (server_random)
   delete[] server_random;
  if (fbmmap != ((void *)-1))
   munmap(fbmmap, fbmmapsize);

  server_random = __null;
  pthread_mutex_lock(&diffmutex);
  pthread_cond_broadcast(&diffstartcond);
  pthread_cond_broadcast(&diffcond);
  pthread_mutex_unlock(&diffmutex);
  sleep(1);
  pthread_mutex_destroy(&diffmutex);
  pthread_mutex_destroy(&popenmutex);
  pthread_mutex_destroy(&logmutex);
  pthread_mutex_destroy(&sl4amutex);
  pthread_mutex_destroy(&netmutex);
  pthread_mutex_destroy(&initfbmutex);
  pthread_mutex_destroy(&uinputmutex);
  pthread_mutex_destroy(&chatmutex);
  pthread_mutex_destroy(&wakelockmutex);
  pthread_cond_destroy(&diffcond);
  pthread_cond_destroy(&chatcond);
  pthread_cond_destroy(&diffstartcond);
  for(i=0; i < sessions.size(); i++)
  {
   pthread_mutex_destroy(&(sessions[i]->mutex));
   if (sessions[i]->alive)
   {
    kill(sessions[i]->pid,9);
    close(sessions[i]->ptm);
   }
   delete sessions[i];
  }
  if (fbfd >= 0)
   close(fbfd);




 }
}

void error(const char *msg,const char *msg2 = __null, const char *msg3=__null, const char * msg4=__null)
{
    perror(msg);

    __android_log_print(ANDROID_LOG_INFO,"Webkey C++","service stoped");

    access_log(__null,msg);
    if (msg2)
    {
     perror(msg2);

     __android_log_print(ANDROID_LOG_ERROR,"Webkey C++",msg2);

     access_log(__null,msg2);
    }
    if (msg3)
    {
     perror(msg3);

     __android_log_print(ANDROID_LOG_ERROR,"Webkey C++",msg3);

     access_log(__null,msg3);
    }
    if (msg4)
    {
 perror(msg4);

     __android_log_print(ANDROID_LOG_ERROR,"Webkey C++",msg4);

     access_log(__null,msg4);
    }
    clear();
    exit(1);
}
FILE* fo(const char* filename, const char* mode)
{
 std::string longname = dir + filename;
 FILE* ret = fopen(longname.c_str(),mode);
 if (!ret)
  printf("Couldn't open %s with mode %s\n",longname.c_str(), mode);


 return ret;
}

void add_key(bool sms, int ajax, int disp)
{
 int i;
 for (i = 0; i < speckeys.size(); i++)
 {
  if (speckeys[i]->ajax == ajax && speckeys[i]->disp == disp && speckeys[i]->sms == sms)
   return;
 }
 BIND* load = new BIND;
 load->ajax = ajax;
 load->disp = disp;
 load->sms = sms;
 load->kcm = 0;
 speckeys.push_back(load);
}

static bool load_keys()
{
 clear(false);
 usleep(10000);
 int i;

 FILE* kl;
 if (is_icecreamsandwich && geniatech == false)
 {
  kl = fopen("/system/usr/keylayout/Webkey.kl","w");
 }
 else
 {
  kl = fopen("/dev/Webkey.kl","w");
 }
 if (!kl)
 {
  printf("Couldn't open Webkey.kl for writing.\n");
  return false;
 }
 printf("Webkey.kl is opened.\n");
 i = 0;
 while (KEYCODES[i].value)
 {
  fprintf(kl,"key %d   %s   WAKE\n",KEYCODES[i].value,KEYCODES[i].literal);
  FAST* load = new FAST;
  load->show = 0;
  load->name = new char[strlen(KEYCODES[i].literal)+1];
  strcpy(load->name,KEYCODES[i].literal);
  load->ajax = 0;
  fastkeys.push_back(load);
  i++;
 }
 fclose(kl);

 FILE* fk = fo("fast_keys.txt","r");
 if (!fk)
  return false;
 int ajax, show, id;
 while(fscanf(fk,"%d %d %d\n",&id,&show,&ajax) == 3)
 {
  if (id-1 < i)
  {
   fastkeys[id-1]->ajax = ajax;
   fastkeys[id-1]->show = show;
  }
 }
 fclose(fk);

 FILE* sk = fo("spec_keys.txt","r");
 if (!sk)
  return false;
 int disp, sms;
 while(fscanf(sk,"%d %d %d\n",&sms,&ajax,&disp) == 3)
 {
  add_key(sms,ajax,disp);
 }
 fclose(sk);

 if (samsung)
 {
  add_key(0,103,103);
  add_key(0,71,71);
  add_key(0,100,100);
  add_key(0,68,68);
 }
 if (is_handle_m)
 {
  add_key(0,109,109);
  add_key(0,77,77);
 }


 FILE* kcm;
 if (is_icecreamsandwich && geniatech == false)
  kcm = fopen("/system/usr/keychars/Webkey.kcm","w");
 else
  kcm = fopen("/dev/Webkey.kcm","w");
 if (!kcm)
 {
  printf("Couldn't open Webkey.kcm for writing.\n");
  return false;
 }

 if (is_icecreamsandwich && geniatech == false)
  fprintf(kcm,"type FULL\n");
 else
  fprintf(kcm,"[type=QWERTY]\n# keycode       display number  base    caps    alt     caps_alt\n");
 if (is_icecreamsandwich && geniatech == false)
 {
  for (int i=0; i<54;i++)
  {
   int j = 0;
   int q = 0;

   char st1[10];
   st1[0] = 0;
   q = 0;
   while (KCM_BASE2[i][j] != ' ' && KCM_BASE2[i][j])
    st1[q++] = KCM_BASE2[i][j++];
   st1[q] = 0;
   if (KCM_BASE2[i][j]) j++;

   char st2[10];
   st2[0] = 0;
   q = 0;
   while (KCM_BASE2[i][j] != ' ' && KCM_BASE2[i][j])
    st2[q++] = KCM_BASE2[i][j++];
   st2[q] = 0;
   if (KCM_BASE2[i][j]) j++;

   char st3[10];
   st3[0] = 0;
   q = 0;
   while (KCM_BASE2[i][j] != ' ' && KCM_BASE2[i][j])
    st3[q++] = KCM_BASE2[i][j++];
   st3[q] = 0;
   if (KCM_BASE2[i][j]) j++;

   char st4[10];
   st4[0] = 0;
   q = 0;
   while (KCM_BASE2[i][j] != ' ' && KCM_BASE2[i][j])
    st4[q++] = KCM_BASE2[i][j++];
   st4[q] = 0;
   if (KCM_BASE2[i][j]) j++;

   char st5[10];
   st5[0] = 0;
   q = 0;
   while (KCM_BASE2[i][j] != ' ' && KCM_BASE2[i][j])
    st5[q++] = KCM_BASE2[i][j++];
   st5[q] = 0;
   if (KCM_BASE2[i][j]) j++;

   if (strcmp(st1,"SPACE") == 0)
   {
    strcpy(st2,"' '");
    strcpy(st3,"' '");
    strcpy(st4,"' '");
    strcpy(st5,"' '");
   }

   fprintf(kcm,"key %s {\n",st1);
   fprintf(kcm," label: %s\n",st2);
   fprintf(kcm," base: %s\n",st4);
   if (i < 26)
    fprintf(kcm," shift, capslock: %s\n",st5);
   else
    fprintf(kcm," shift: %s\n",st5);

   int k = 0;
   if (2*i < speckeys.size())
   {
    k = speckeys[2*i]->disp;
    speckeys[2*i]->kcm_sh = false;
    if (i<28)
     speckeys[2*i]->kcm = 29+i;
    if (28==i)
     speckeys[2*i]->kcm = 77;
    if (29==i)
     speckeys[2*i]->kcm = 62;
    if (30==i)
     speckeys[2*i]->kcm = 66;
    if (30<i && i<41)
     speckeys[2*i]->kcm = i-31+7;
    if (41==i)
     speckeys[2*i]->kcm = 61;
    if (42<=i && i < 50)
     speckeys[2*i]->kcm = i-42+68;
    if (50==i)
     speckeys[2*i]->kcm = 17;
    if (51==i)
     speckeys[2*i]->kcm = 18;
    if (52==i)
     speckeys[2*i]->kcm = 81;
    if (53==i)
     speckeys[2*i]->kcm = 76;
   }
   int l = 0;
   if (2*i+1 < speckeys.size())
   {
    l = speckeys[2*i+1]->disp;
    speckeys[2*i+1]->kcm_sh = true;
    if (i<28)
     speckeys[2*i+1]->kcm = 29+i;
    if (28==i)
     speckeys[2*i+1]->kcm = 77;
    if (29==i)
     speckeys[2*i+1]->kcm = 62;
    if (30==i)
     speckeys[2*i+1]->kcm = 66;
    if (30<i && i<41)
     speckeys[2*i+1]->kcm = i-31+7;
    if (41==i)
     speckeys[2*i+1]->kcm = 61;
    if (42<=i && i < 50)
     speckeys[2*i+1]->kcm = i-42+68;
    if (50==i)
     speckeys[2*i+1]->kcm = 17;
    if (51==i)
     speckeys[2*i+1]->kcm = 18;
    if (52==i)
     speckeys[2*i+1]->kcm = 81;
    if (53==i)
     speckeys[2*i+1]->kcm = 76;
   }
   if (k)
    fprintf(kcm,"alt: '\\u%04X'\n",k);
   if (l)
    fprintf(kcm,"alt+shift: '\\u%04X'\n",l);
   fprintf(kcm,"}\n",l);
  }
 }
 else
 {
  int ii = 0;
  for(i=0; i<54; i++)
  {
   if (samsung && (i == 3 || i == 6))
   {
    fprintf(kcm,"%s %d %d\n",KCM_BASE[i],0,0);
    continue;
   }
   if (is_handle_m && (i == 12))
   {
    fprintf(kcm,"%s %d %d\n",KCM_BASE[i],0,0);
    continue;
   }
   int k = 0;
   if (2*ii < speckeys.size())
   {
    k = speckeys[2*ii]->disp;
    speckeys[2*ii]->kcm_sh = false;
    if (i<28)
     speckeys[2*ii]->kcm = 29+i;
    if (28==i)
     speckeys[2*ii]->kcm = 77;
    if (29==i)
     speckeys[2*ii]->kcm = 62;
    if (30==i)
     speckeys[2*ii]->kcm = 66;
    if (30<i && i<41)
     speckeys[2*ii]->kcm = i-31+7;
    if (41==i)
     speckeys[2*ii]->kcm = 61;
    if (42<=i && i < 50)
     speckeys[2*ii]->kcm = i-42+68;
    if (50==i)
     speckeys[2*ii]->kcm = 17;
    if (51==i)
     speckeys[2*ii]->kcm = 18;
    if (52==i)
     speckeys[2*ii]->kcm = 81;
    if (53==i)
     speckeys[2*ii]->kcm = 76;
   }
   int l = 0;
   if (2*ii+1 < speckeys.size())
   {
    l = speckeys[2*ii+1]->disp;
    speckeys[2*ii+1]->kcm_sh = true;
    if (i<28)
     speckeys[2*ii+1]->kcm = 29+i;
    if (28==i)
     speckeys[2*ii+1]->kcm = 77;
    if (29==i)
     speckeys[2*ii+1]->kcm = 62;
    if (30==i)
     speckeys[2*ii+1]->kcm = 66;
    if (30<i && i<41)
     speckeys[2*ii+1]->kcm = i-31+7;
    if (41==i)
     speckeys[2*ii+1]->kcm = 61;
    if (42<=i && i < 50)
     speckeys[2*ii+1]->kcm = i-42+68;
    if (50==i)
     speckeys[2*ii+1]->kcm = 17;
    if (51==i)
     speckeys[2*ii+1]->kcm = 18;
    if (52==i)
     speckeys[2*ii+1]->kcm = 81;
    if (53==i)
     speckeys[2*ii+1]->kcm = 76;
   }
   fprintf(kcm,"%s %d %d\n",KCM_BASE[i],k,l);
   ii++;
  }
 }
 fclose(kcm);

 if (is_icecreamsandwich == false && compile("/dev/Webkey.kcm","/dev/Webkey.kcm.bin"))
 {
  printf("Couldn't compile kcm to kcm.bin\n");
  return false;
 }
 if (is_icecreamsandwich && geniatech == false)
 {
  chmod("/system/usr/keylayout/Webkey.kl", 00400|00200|00040|00004);
  chmod("/system/usr/keychars/Webkey.kcm", 00400|00200|00040|00004);
 }
 else
 {
  chmod("/dev/Webkey.kl", 00400|00200|00040|00004);
  chmod("/dev/Webkey.kcm", 00400|00200|00040|00004);
  chmod("/dev/Webkey.kcm.bin", 00400|00200|00040|00004);
 }
 return true;
}

static void init_uinput()
{
 bool loaded_keys;
 if (run_load_keys)
 {
  if (is_icecreamsandwich && geniatech == false)
   syst("mount -o remount,rw /system");
  loaded_keys = load_keys();
  if (is_icecreamsandwich && geniatech == false)
  {
   FILE* f = fopen("/system/usr/idc/Webkey.idc","w");
   if (f && loaded_keys)
   {
    fprintf(f,"touch.deviceType = touchScreen\n"
     "touch.orientationAware = 0\n"
     "keyboard.layout = Webkey\n"
     "keyboard.characterMap = Webkey\n"
     "keyboard.orientationAware = 1\n"
     "keyboard.builtIn = 1\n"
     "cursor.mode = navigation\n"
     "cursor.orientationAware = 0\n");
    fclose(f);
   }
   if (f && loaded_keys == false)
   {
    fprintf(f,"touch.deviceType = touchScreen\n"
     "touch.orientationAware = 0\n"
     "keyboard.layout = Generic\n"
     "keyboard.characterMap = Generic\n"
     "keyboard.orientationAware = 1\n"
     "keyboard.builtIn = 1\n"
     "cursor.mode = navigation\n"
     "cursor.orientationAware = 0\n");
    fclose(f);
   }
   chmod("/system/usr/idc/Webkey.idc", 00400|00200|00040|00004);
  }
  if (is_icecreamsandwich && geniatech == false)
   syst("mount -o remount,ro /system");
  printf("loaded_keys = %d\n",loaded_keys);
  use_generic = !loaded_keys;

  if (is_icecreamsandwich)
  {
   mkdir("/data/system/devices",00400|00200|00100);
   mkdir("/data/system/devices/idc",00400|00200|00100);
   FILE* f = fopen("/data/system/devices/idc/Webkey.idc","w");
   if (f && loaded_keys)
   {
    fprintf(f,"touch.deviceType = touchScreen\n"
     "touch.orientationAware = 0\n"
     "keyboard.layout = Webkey\n"
     "keyboard.characterMap = Webkey\n"
     "keyboard.orientationAware = 1\n"
     "keyboard.builtIn = 1\n"
     "cursor.mode = navigation\n"
     "cursor.orientationAware = 0\n");
    fclose(f);
   }
   if (f && loaded_keys == false)
   {
    fprintf(f,"touch.deviceType = touchScreen\n"
     "touch.orientationAware = 0\n"
     "keyboard.layout = Generic\n"
     "keyboard.characterMap = Generic\n"
     "keyboard.orientationAware = 1\n"
     "keyboard.builtIn = 1\n"
     "cursor.mode = navigation\n"
     "cursor.orientationAware = 0\n");
    fclose(f);
   }
  }
 }


 struct input_id uid = {
  0x06,
  1,
  1,
  1
 };

 printf("suinput init...\n");
 pthread_mutex_lock(&uinputmutex);
 usleep(100000);


 if (is_icecreamsandwich)
  uinput_fd = suinput_open("Webkey", &uid, use_uinput_mouse);
 else
  uinput_fd = suinput_open("/../../../dev/Webkey", &uid, use_uinput_mouse);
 if (uinput_fd == -1)
 {


  use_uinput_mouse = false;
 }


 usleep(100000);
 run_load_keys = false;
 pthread_mutex_unlock(&uinputmutex);
# 1672 "webkey-2.09/service/webkey.cpp"
}



static void init_fb(void)
{
 pthread_mutex_lock(&initfbmutex);
 if (pict)
 {
  pthread_mutex_unlock(&initfbmutex);
  return;
 }
        size_t pixels;

        pixels = scrinfo.xres_virtual * scrinfo.yres_virtual;
 if (fbfd < 0)
 {
  if (screencap > -1)
  {
   pict = new png_byte[scrinfo.yres*scrinfo.xres*3];
   lastpic = new int[pixels * bytespp/4/7+1];
   if (scrinfo.yres > scrinfo.xres)
    graph = new png_byte*[scrinfo.yres];
   else
    graph = new png_byte*[scrinfo.xres];
   copyfb = new unsigned int[scrinfo.yres*scrinfo.xres_virtual*bytespp/4];
  }
  pthread_mutex_unlock(&initfbmutex);
  return;
 }

        bytespp = scrinfo.bits_per_pixel / 8;
 if (bytespp == 3)
  bytespp = 4;
 char tmp[1024];
 int size = 0;
 int s = 0;
 close(fbfd);
 fbfd = open("/dev/graphics/fb0", 00000000);
 while ((s = read(fbfd, tmp, 1024)) > 0)
 {
  size += s;
 }
 if (size == 0)
 {
  int q = open("/sys/power/wait_for_fb_wake",00000000);
  if (q > 0)
  {
   read(q, tmp, 1);
   close(q);
  }
  close(fbfd);
  fbfd = open("/dev/graphics/fb0", 00000000);
  while ((s = read(fbfd, tmp, 1024)) > 0)
  {
   size += s;
  }
 }

 printf("size of fb = %d\n", size);
 if (scrinfo.xres == 240 && scrinfo.xres_virtual == 256 &&
   size == 240*scrinfo.yres_virtual*(scrinfo.bits_per_pixel/8))
 {
  scrinfo.xres_virtual = 240;
  force_240 = true;
  printf("forcing 240\n");
 }
 if (size / scrinfo.xres_virtual / (scrinfo.bits_per_pixel/8) < scrinfo.yres_virtual)
 {
  printf("overriding scrinfo.yres_virtual from %d\n", scrinfo.yres_virtual);
  scrinfo.yres_virtual = size / scrinfo.xres_virtual / (scrinfo.bits_per_pixel/8);
 }

 if (pixels < scrinfo.xres_virtual*scrinfo.yoffset+scrinfo.xoffset+scrinfo.xres_virtual*scrinfo.yres )
  pixels = scrinfo.xres_virtual*scrinfo.yoffset+scrinfo.xoffset+scrinfo.xres_virtual*scrinfo.yres;

 if (scrinfo.xres_virtual == 240)
  scrinfo.xres_virtual = 256;
 if (force_240)
  scrinfo.xres_virtual = scrinfo.xres = 240;
 if (force_544)
  scrinfo.xres_virtual = 544;
 init_fb_for_test();

        printf("xres=%d, yres=%d, xresv=%d, yresv=%d, xoffs=%d, yoffs=%d, bpp=%d\n",
          (int)scrinfo.xres, (int)scrinfo.yres,
          (int)scrinfo.xres_virtual, (int)scrinfo.yres_virtual,
          (int)scrinfo.xoffset, (int)scrinfo.yoffset,
          (int)scrinfo.bits_per_pixel);

        pixels = scrinfo.xres_virtual * scrinfo.yres_virtual;





 lowest_offset = scrinfo.xres_virtual*scrinfo.yoffset+scrinfo.xoffset;

 printf("pixels = %d, bytespp = %d\n", pixels, bytespp);
        fbmmap = mmap(__null, pixels * bytespp, 0x1, 0x01, fbfd, 0);
 fbmmapsize = pixels * bytespp;

        if (fbmmap == ((void *)-1))
        {
                perror("mmap");
                exit(1);
        }
 pict = new png_byte[scrinfo.yres*scrinfo.xres*3];
 lastpic = new int[pixels * bytespp/4/7+1];
 if (scrinfo.yres > scrinfo.xres)
  graph = new png_byte*[scrinfo.yres];
 else
  graph = new png_byte*[scrinfo.xres];
 copyfb = new unsigned int[scrinfo.yres*scrinfo.xres_virtual*bytespp/4];
 pthread_mutex_unlock(&initfbmutex);
}

void init_touch()
{
 int i;



 char touch_device[19] = "/dev/input/event0";

 for (i=0; i<50; i++)
 {
  char name[256]="Unknown";
  if (i < 10)
  {
   touch_device[sizeof(touch_device)-3] = '0'+(char)(i);
   touch_device[sizeof(touch_device)-2] = 0;
  }
  else
  {
   touch_device[sizeof(touch_device)-3] = '0'+(char)(i/10);
   touch_device[sizeof(touch_device)-2] = '0'+(char)(i%10);
   touch_device[sizeof(touch_device)-1] = 0;
  }
  struct input_absinfo info;
  if((touchfd = open(touch_device, 00000002)) == -1)
  {
   continue;
  }
  printf("searching for touch device, opening %s ... ",touch_device);
  if (ioctl(touchfd, (((2U) << (((0 +8)+8)+14)) | (('E') << (0 +8)) | ((0x06) << 0) | ((sizeof(name)) << ((0 +8)+8))),name) < 0)
  {
   printf("failed, no name\n");
   close(touchfd);
   touchfd = -1;
   continue;
  }
  device_names[std::string(name)] = touch_device;
  if(use_uinput_mouse)
   continue;
  printf("%s ",name);






  if (contains(name,"touchscreen"))
  {
   printf("There is touchscreen in its name, it must be the right device!\n");
  }
  else
  {
   printf("\n");
   continue;
  }

  if(ioctl(touchfd, (((2U) << (((0 +8)+8)+14)) | ((('E')) << (0 +8)) | (((0x40 + 0x00)) << 0) | (((((sizeof(struct input_absinfo) == sizeof(struct input_absinfo[1]) && sizeof(struct input_absinfo) < (1 << 14)) ? sizeof(struct input_absinfo) : __invalid_size_argument_for_IOC))) << ((0 +8)+8))), &info))
  {
   printf("failed, no ABS_X\n");
   close(touchfd);
   touchfd = -1;
   continue;
  }
  xmin = info.minimum;
  xmax = info.maximum;
  if (xmin == 0 && xmax == 0)
  {
   if(ioctl(touchfd, (((2U) << (((0 +8)+8)+14)) | ((('E')) << (0 +8)) | (((0x40 + 53)) << 0) | (((((sizeof(struct input_absinfo) == sizeof(struct input_absinfo[1]) && sizeof(struct input_absinfo) < (1 << 14)) ? sizeof(struct input_absinfo) : __invalid_size_argument_for_IOC))) << ((0 +8)+8))), &info))
   {
    printf("failed, no ABS_X\n");
    close(touchfd);
    touchfd = -1;
    continue;
   }
   xmin = info.minimum;
   xmax = info.maximum;
  }

  if(ioctl(touchfd, (((2U) << (((0 +8)+8)+14)) | ((('E')) << (0 +8)) | (((0x40 + 0x01)) << 0) | (((((sizeof(struct input_absinfo) == sizeof(struct input_absinfo[1]) && sizeof(struct input_absinfo) < (1 << 14)) ? sizeof(struct input_absinfo) : __invalid_size_argument_for_IOC))) << ((0 +8)+8))), &info)) {
   printf("failed, no ABS_Y\n");
   close(touchfd);
   touchfd = -1;
   continue;
  }
  ymin = info.minimum;
  ymax = info.maximum;
  if (ymin == 0 && ymax == 0)
  {
   if(ioctl(touchfd, (((2U) << (((0 +8)+8)+14)) | ((('E')) << (0 +8)) | (((0x40 + 54)) << 0) | (((((sizeof(struct input_absinfo) == sizeof(struct input_absinfo[1]) && sizeof(struct input_absinfo) < (1 << 14)) ? sizeof(struct input_absinfo) : __invalid_size_argument_for_IOC))) << ((0 +8)+8))), &info))
   {
    printf("failed, no ABS_Y\n");
    close(touchfd);
    touchfd = -1;
    continue;
   }
   ymin = info.minimum;
   ymax = info.maximum;
  }
  if (xmin < 0 || xmin == xmax)
  {
   printf("failed, xmin<0 || xmin==xmax\n");
   close(touchfd);
   touchfd = -1;
   continue;
  }
  printf("success\n");

  __android_log_print(ANDROID_LOG_INFO,"Webkey C++","using touch device: %s",touch_device);

  printf("xmin = %d, xmax = %d, ymin = %d, ymax = %d\n",xmin,xmax,ymin,ymax);
  if (strcmp(name,"mxt224_ts_input")==0)
  {
   touch_mxt224_ts_input = true;
   printf("found mxt224_ts_input\n");
  }
  return;
 }
 if(use_uinput_mouse)
  return;
 for (i=0; i<50; i++)
 {
  char name[256]="Unknown";
  if (i < 10)
  {
   touch_device[sizeof(touch_device)-3] = '0'+(char)(i);
   touch_device[sizeof(touch_device)-2] = 0;
  }
  else
  {
   touch_device[sizeof(touch_device)-3] = '0'+(char)(i/10);
   touch_device[sizeof(touch_device)-2] = '0'+(char)(i%10);
   touch_device[sizeof(touch_device)-1] = 0;
  }
  struct input_absinfo info;
  if((touchfd = open(touch_device, 00000002)) == -1)
  {
   continue;
  }
  printf("searching for touch device, opening %s ... ",touch_device);
  if (ioctl(touchfd, (((2U) << (((0 +8)+8)+14)) | (('E') << (0 +8)) | ((0x06) << 0) | ((sizeof(name)) << ((0 +8)+8))),name) < 0)
  {
   printf("failed, no name\n");
   close(touchfd);
   touchfd = -1;
   continue;
  }
  printf("device name is %s\n",name);

  if(ioctl(touchfd, (((2U) << (((0 +8)+8)+14)) | ((('E')) << (0 +8)) | (((0x40 + 0x00)) << 0) | (((((sizeof(struct input_absinfo) == sizeof(struct input_absinfo[1]) && sizeof(struct input_absinfo) < (1 << 14)) ? sizeof(struct input_absinfo) : __invalid_size_argument_for_IOC))) << ((0 +8)+8))), &info))
  {
   printf("failed, no ABS_X\n");
   close(touchfd);
   touchfd = -1;
   continue;
  }
  xmin = info.minimum;
  xmax = info.maximum;
  if (xmin == 0 && xmax == 0)
  {
   if(ioctl(touchfd, (((2U) << (((0 +8)+8)+14)) | ((('E')) << (0 +8)) | (((0x40 + 53)) << 0) | (((((sizeof(struct input_absinfo) == sizeof(struct input_absinfo[1]) && sizeof(struct input_absinfo) < (1 << 14)) ? sizeof(struct input_absinfo) : __invalid_size_argument_for_IOC))) << ((0 +8)+8))), &info))
   {
    printf("failed, no ABS_X\n");
    close(touchfd);
    touchfd = -1;
    continue;
   }
   xmin = info.minimum;
   xmax = info.maximum;
  }

  if(ioctl(touchfd, (((2U) << (((0 +8)+8)+14)) | ((('E')) << (0 +8)) | (((0x40 + 0x01)) << 0) | (((((sizeof(struct input_absinfo) == sizeof(struct input_absinfo[1]) && sizeof(struct input_absinfo) < (1 << 14)) ? sizeof(struct input_absinfo) : __invalid_size_argument_for_IOC))) << ((0 +8)+8))), &info)) {
   printf("failed, no ABS_Y\n");
   close(touchfd);
   touchfd = -1;
   continue;
  }
  ymin = info.minimum;
  ymax = info.maximum;
  if (ymin == 0 && ymax == 0)
  {
   if(ioctl(touchfd, (((2U) << (((0 +8)+8)+14)) | ((('E')) << (0 +8)) | (((0x40 + 54)) << 0) | (((((sizeof(struct input_absinfo) == sizeof(struct input_absinfo[1]) && sizeof(struct input_absinfo) < (1 << 14)) ? sizeof(struct input_absinfo) : __invalid_size_argument_for_IOC))) << ((0 +8)+8))), &info))
   {
    printf("failed, no ABS_Y\n");
    close(touchfd);
    touchfd = -1;
    continue;
   }
   ymin = info.minimum;
   ymax = info.maximum;
  }
  bool t = contains(name,"touch");
  bool tk = contains(name,"touchkey");
  if (t && !tk)
   printf("there is \"touch\", but not \"touchkey\" in the name\n");
  if (!(t && !tk) && (xmin < 0 || xmin == xmax))
  {
   printf("failed, xmin<0 || xmin==xmax\n");
   close(touchfd);
   touchfd = -1;
   continue;
  }
  printf("success2\n");

  __android_log_print(ANDROID_LOG_INFO,"Webkey C++","using touch device: %s",touch_device);

  printf("xmin = %d, xmax = %d, ymin = %d, ymax = %d\n",xmin,xmax,ymin,ymax);


  if (strcmp(name,"mxt224_ts_input")==0)
  {
   touch_mxt224_ts_input = true;
   printf("found mxt224_ts_input\n");
  }
  return;
 }
 use_uinput_mouse = true;
}

static void savechat()
{
 FILE* f = fo("chat.txt","w");
 int i;
 for (i = 0; i < chat_messages.size(); i++)
  fprintf(f,"%s%c%d%c%s%c",chat_messages[i].user.c_str(),0,chat_messages[i].timestamp,0,chat_messages[i].message.c_str(),0);
 fprintf(f,"%c",0);
 for (std::map<std::string,int>::iterator it = chat_readby.begin(); it != chat_readby.end(); it++)
  fprintf(f,"%s%c%d%c",it->first.c_str(),0,it->second,0);
 fprintf(f,"%c",0);
 fclose(f);
 chmod((dir+"chat.txt").c_str(), 00400|00200|00040|00020);
 chown((dir+"chat.txt").c_str(), info.st_uid, info.st_gid);
 chmod((dir+"chat.txt").c_str(), 00400|00200|00040|00020);
}

static void loadchat()
{
 chat_messages.clear();
 chat_readby.clear();
 chat_readby_real.clear();
 std::string longname = dir + "chat.txt";
 FILE* f = fopen(longname.c_str(),"r");
 if (!f)
  return;
 int i;

 fseek (f , 0 , 2);
 int lSize = ftell (f);
 rewind (f);
 char* buff = new char[lSize+1];
 if (!buff)
 {
  fclose(f);
  return;
 }
 fread(buff,1,lSize,f);

 i = 0;
 while(buff[i] && i < lSize)
 {
  MESSAGE toload;
  toload.user = buff+i;
  while (buff[i] && i < lSize)
   i++;
  if (i < lSize)
   i++;
  toload.timestamp = getnum(buff+i);
  while (buff[i] && i < lSize)
   i++;
  if (i < lSize)
   i++;
  toload.message = buff+i;
  while (buff[i] && i < lSize)
   i++;
  if (i < lSize)
   i++;
  chat_messages.push_back(toload);
 }
 if (i < lSize)
  i++;
 while(buff[i] && i < lSize)
 {
  std::string q;
  int w;
  q = buff+i;
  while (buff[i] && i < lSize)
   i++;
  if (i < lSize)
   i++;
  w = getnum(buff+i);
  while (buff[i] && i < lSize)
   i++;
  if (i < lSize)
   i++;
  chat_readby[q] = w;
  chat_readby_real[q] = w;
 }

 fclose(f);
}

static void
getchatmessage(struct mg_connection *conn,
                const struct mg_request_info *ri, void *data)
{
 if (ri->permissions != -1 && (ri->permissions&4)==0 && ri->remote_ip!=2130706433)
  return;
 if (exit_flag)
  return;
 int n = strlen(ri->uri);
 int i = 0;
 while (i<n && ri->uri[i] != '_') i++;
 i++;
 int random = getnum(ri->uri+i);
 int pos = -1;
 while (i<n && ri->uri[i] != '_') i++;
 i++;
 if (i < n)
  pos = getnum(ri->uri+i);
 int countpos = -1;
 while (i<n && ri->uri[i] != '_') i++;
 i++;
 if (i < n)
  countpos = getnum(ri->uri+i);
 std::string username;
 if (strcmp(ri->remote_user,"JAVA_CLIENT")==0)
  username = "phone";
 else
  username = ri->remote_user;
 pthread_mutex_lock(&chatmutex);
 int count = chat_readby[username];
 int count_real = chat_readby_real[username];
 if (random != chat_random)
 {
  count = 0;
  count_real = 0;
 }
 if (count != count_real)
 {
  chat_count++;
  chat_readby[username] = count_real;
  count = count_real;
  pthread_cond_broadcast(&chatcond);
  savechat();
 }
 if (pos == -1)
  pos = count;
 if (countpos == -1)
  countpos = chat_readby_count[username];
 if (chat_messages.size() == pos && random == chat_random && chat_count == countpos)
 {
  if (!exit_flag)
   pthread_cond_wait(&chatcond,&chatmutex);
 }
 if (random != chat_random)
  pos = 0;
 char buff[4096];
 std::map<int,int> sent;
 send_ok(conn,"Content-Type: text/xml; charset=UTF-8");
 mg_printf(conn,"<chat><readbypos>%d</readbypos><id>%d</id>\n",chat_count,chat_random);
 for (i = pos; i < chat_messages.size(); i++)
 {
  MESSAGE* m = &(chat_messages[i]);
  mg_printf(conn,"<message>");
  mg_printf(conn,"<user>%s</user>",m->user.c_str());
  mg_printf(conn,"<time>%d</time>",m->timestamp);
  convertxml(buff,m->message.c_str());
  mg_printf(conn,"<data>%s</data>",buff);
  mg_printf(conn,"</message>\n");
 }
 if (pos < chat_messages.size())
 {

  chat_readby_real[username] = chat_messages.size();


 }
 chat_readby_count[username] = chat_count;
 for (std::map<std::string,int>::iterator it = chat_readby.begin(); it != chat_readby.end(); it++)
 {
  if (it->first == username && username == "phone")
   continue;
  convertxml(buff,it->first.c_str());
  mg_printf(conn,"<readby name=\"%s\">%d</readby>",buff,it->second);
 }
 mg_printf(conn,"</chat>\n");
 pthread_mutex_unlock(&chatmutex);
}
static void
phonegetchatmessage(struct mg_connection *conn,
                const struct mg_request_info *ri, void *data)
{
 if (ri->remote_ip==2130706433)
  getchatmessage(conn,ri,data);
}
static void
writechatmessage(struct mg_connection *conn,
                const struct mg_request_info *ri, void *data)
{
 if (ri->permissions != -1 && (ri->permissions&4)==0 && ri->remote_ip!=2130706433)
  return;
 lock_wakelock();
 char* post_data;
 int post_data_len;
 read_post_data(conn,ri,&post_data,&post_data_len);
 send_ok(conn);
 if (post_data_len == 0)
  return;
 MESSAGE load;
 if (strcmp(ri->remote_user,"JAVA_CLIENT")!=0)
 {
  load.user = ri->remote_user;
 }
 else
 {
  load.user = "phone";
 }
 load.timestamp = time(__null);
 load.message = std::string(post_data);

 pthread_mutex_lock(&chatmutex);
 chat_messages.push_back(load);
 savechat();
 pthread_cond_broadcast(&chatcond);
 pthread_mutex_unlock(&chatmutex);
 usleep(1500000);
 pthread_mutex_lock(&chatmutex);
 bool intent = false;
 if (chat_messages.size() != chat_readby["phone"])
  intent = true;
 pthread_mutex_unlock(&chatmutex);
 if (intent)
  syst("/system/bin/am broadcast -a \"webkey.intent.action.Chat\" -n \"com.webkey/.ChatReceiver\"&");
 if (post_data)
  delete[] post_data;
}
static void
phonewritechatmessage(struct mg_connection *conn,
                const struct mg_request_info *ri, void *data)
{
 if (ri->remote_ip==2130706433)
  writechatmessage(conn,ri,data);
}
static void
clearchatmessage(struct mg_connection *conn,
                const struct mg_request_info *ri, void *data)
{
 if (ri->permissions != -1 && (ri->permissions&4)==0 && ri->remote_ip!=2130706433)
  return;
 lock_wakelock();







 pthread_mutex_lock(&chatmutex);
 chat_messages.clear();
 chat_readby.clear();
 chat_readby_real.clear();
 chat_readby_count.clear();
 struct timeval tv;
 gettimeofday(&tv,0);
 chat_random = time(__null) + tv.tv_usec;
 chat_count = 1;

 savechat();
 pthread_cond_broadcast(&chatcond);
 pthread_mutex_unlock(&chatmutex);
 send_ok(conn);
}
static void
phoneclearchatmessage(struct mg_connection *conn,
                const struct mg_request_info *ri, void *data)
{
 if (ri->remote_ip==2130706433)
  clearchatmessage(conn,ri,data);
}

static void
adjust_light(struct mg_connection *conn,
                const struct mg_request_info *ri, void *data)
{
    if (ri->permissions != -1)
     return;
    lock_wakelock();
    send_ok(conn);

    int i = getnum(ri->uri+14);
    int fd = open("/sys/class/leds/lcd-backlight/brightness", 00000001);
    if (fd < 0)
     fd = open("/sys/class/backlight/pwm-backlight/brightness", 00000001);
    if(fd < 0)
        return;

    char value[20];
    int n = sprintf(value, "%d\n", i*max_brightness/256);
    write(fd, value, n);
    close(fd);
}
static void
waitdiff(struct mg_connection *conn,
                const struct mg_request_info *ri, void *data)
{
 if (ri->permissions != -1 && (ri->permissions&1)==0)
  return;
 if (exit_flag)
  return;
 send_ok(conn);

 if (!picchanged)
 {

  pthread_mutex_lock(&diffmutex);
  if (!exit_flag)
   pthread_cond_wait(&diffcond,&diffmutex);
  pthread_mutex_unlock(&diffmutex);

 }

 mg_printf(conn,"changed");
}
void update_image(int orient,int lowres, bool png, bool flip, bool reread)
{


 if ((fbfd < 0 && screencap == -1) || scrinfo.yres == 0)
  return;
 if (fbfd >= 0)
 {
  if (ioctl(fbfd, 0x4600, &scrinfo) != 0)
  {
   FILE* fp;
   if (png)
    fp = fo("tmp.png", "wb");
   else
    fp = fo("tmp.jpg", "wb");
   fclose(fp);
   return;
  }
  if (scrinfo.xres_virtual == 240)
         scrinfo.xres_virtual = 256;
  if (force_240)
   scrinfo.xres_virtual = scrinfo.xres = 240;
  if (force_544)
   scrinfo.xres_virtual = 544;
  init_fb_for_test();
 }
# 2345 "webkey-2.09/service/webkey.cpp"
 FILE *fp;
 png_structp png_ptr;
 png_infop info_ptr;
 struct jpeg_compress_struct cinfo;
 struct jpeg_error_mgr jerr;

 std::string path = "tmp";
 bool rec = false;
 if (recording)
 {
  rec = true;
  char num[32];
  path = std::string("/sdcard/webkey_TEMP/screenshot_");
  itoa(num,recordingnum++);
  int l = strlen(num);
  if (l<2)
   path = path+"0";
  if (l<3)
   path = path+"0";
  path = path + num;
 }

 if (png)
 {
  path = path + ".png";
  if (rec)
   fp = fopen(path.c_str(), "wb");
  else
   fp = fo(path.c_str(), "wb");
  if (!fp)
   return;
  png_ptr = png_create_write_struct("1.2.27", __null, __null, __null);
  info_ptr = png_create_info_struct(png_ptr);
  png_init_io(png_ptr, fp);
  if (rec)
   png_set_compression_level(png_ptr, 0);
  else
   png_set_compression_level(png_ptr, 1);
  if (orient == 0)
   png_set_IHDR(png_ptr, info_ptr, scrinfo.xres>>lowres, scrinfo.yres>>lowres,
    8,
    (2), 0,
    0, 0);
  else
   png_set_IHDR(png_ptr, info_ptr, scrinfo.yres>>lowres, scrinfo.xres>>lowres,
    8,
    (2), 0,
    0, 0);
 }
 else
 {
  path = path + ".jpg";
  if (rec)
   fp = fopen(path.c_str(), "wb");
  else
   fp = fo(path.c_str(), "wb");
  if (!fp)
   return;
  JSAMPROW row_pointer[1];
  cinfo.err = jpeg_std_error( &jerr );
  jpeg_CreateCompress((&cinfo), 62, (size_t) sizeof(struct jpeg_compress_struct));
  jpeg_stdio_dest(&cinfo, fp);
  if (orient == 0)
  {
   cinfo.image_width = scrinfo.xres>>lowres;
   cinfo.image_height = scrinfo.yres>>lowres;
  }
  else
  {
   cinfo.image_width = scrinfo.yres>>lowres;
   cinfo.image_height = scrinfo.xres>>lowres;
  }
  cinfo.input_components = 3;
  cinfo.in_color_space = JCS_RGB;
  jpeg_set_defaults( &cinfo );
  jpeg_set_quality(&cinfo, 70, 1);
  jpeg_start_compress( &cinfo, 1 );
 }



 int rr = scrinfo.red.offset;
 int rl = 8-scrinfo.red.length;
 int gr = scrinfo.green.offset;
 int gl = 8-scrinfo.green.length;
 int br = scrinfo.blue.offset;
 int bl = 8-scrinfo.blue.length;
 if (is_reverse_colors)
 {
  rr = 24-rr;
  gr = 24-gr;
  br = 24-br;
 }
 int j;



 int x = scrinfo.xres_virtual;
 int xpic = scrinfo.xres;
 int y = scrinfo.yres;
 int m = scrinfo.yres*scrinfo.xres_virtual;
 int mpic = scrinfo.yres*scrinfo.xres;
 int k;
 int i = 0;
 int p = 0;
 int offset = scrinfo.yoffset*scrinfo.xres_virtual+scrinfo.xoffset;
 if (lowest_offset > offset)
  lowest_offset = offset;
 if (firstfb)
  offset = lowest_offset;


 if (reread)
 {







  pthread_mutex_lock(&fbmutex);
  if (fbfd >= 0)
  {
   memcpy(copyfb,(char*)fbmmap+offset*bytespp,m*bytespp);







  }
  else
  {
   FILE* sc;




    if ((sc = mypopen(screencapbinaries[screencap].name,"r"))==__null)
    {
     pthread_mutex_unlock(&fbmutex);
     return;
    }
    char temp[1024];
    if (fread(temp,1,screencap_skipbytes,sc) != screencap_skipbytes)
    {
     mypclose(sc);
     pthread_mutex_unlock(&fbmutex);
     return;

    }

    fread(copyfb,bytespp,m,sc);

    mypclose(sc);

  }
 }
 offset=0;
 {
  int s = m*bytespp/4/157;
  unsigned int* map = ((unsigned int*)copyfb)+(offset*bytespp/4);
  for (i=0; i < s; i++)
  {
   lastpic[22*i+0] = map[157*i+0];
   lastpic[22*i+1] = map[157*i+7];
   lastpic[22*i+2] = map[157*i+14];
   lastpic[22*i+3] = map[157*i+21];
   lastpic[22*i+4] = map[157*i+28];
   lastpic[22*i+5] = map[157*i+35];
   lastpic[22*i+6] = map[157*i+42];
   lastpic[22*i+7] = map[157*i+49];
   lastpic[22*i+8] = map[157*i+56];
   lastpic[22*i+9] = map[157*i+63];
   lastpic[22*i+10] = map[157*i+70];
   lastpic[22*i+11] = map[157*i+77];
   lastpic[22*i+12] = map[157*i+84];
   lastpic[22*i+13] = map[157*i+91];
   lastpic[22*i+14] = map[157*i+98];
   lastpic[22*i+15] = map[157*i+105];
   lastpic[22*i+16] = map[157*i+112];
   lastpic[22*i+17] = map[157*i+119];
   lastpic[22*i+18] = map[157*i+126];
   lastpic[22*i+19] = map[157*i+133];
   lastpic[22*i+20] = map[157*i+140];
   lastpic[22*i+21] = map[157*i+147];
  }
  picchanged = false;
 }
 if (flip == false)
 {
  i=0;
  if (lowres)
  {
   int rm = 0; for (k = 0; k < scrinfo.red.length; k++) rm = rm*2+1;
   int gm = 0; for (k = 0; k < scrinfo.green.length; k++) gm = gm*2+1;
   int bm = 0; for (k = 0; k < scrinfo.blue.length; k++) bm = bm*2+1;
   if (bytespp == 2)
   {
    rl -= 2;
    gl -= 2;
    bl -= 2;
    unsigned short int* map = ((unsigned short int*)copyfb)+offset;
    if (orient == 0)
    {
     for (j = 0; j < y; j+=2)
     {
      for (k = 0; k < xpic; k+=2)
      {
       pict[i++] = (((map[p]>>rr)&rm)+((map[p+1]>>rr)&rm)+((map[p+x]>>rr)&rm)+((map[p+x+1]>>rr)&rm))<<rl;
       pict[i++] = (((map[p]>>gr)&gm)+((map[p+1]>>gr)&gm)+((map[p+x]>>gr)&gm)+((map[p+x+1]>>gr)&gm))<<gl;
       pict[i++] = (((map[p]>>br)&bm)+((map[p+1]>>br)&bm)+((map[p+x]>>br)&bm)+((map[p+x+1]>>br)&bm))<<bl;
       p+=2;
      }
      p+=x-xpic;
      p+=x;
     }
    }
    else
    {
     for (j = 0; j < xpic; j+=2)
     {
      p = (xpic-j-1);
      for (k = 0; k < y; k+=2)
      {
       pict[i++] = (((map[p]>>rr)&rm)+((map[p-1]>>rr)&rm)+((map[p+x]>>rr)&rm)+((map[p+x-1]>>rr)&rm))<<rl;
       pict[i++] = (((map[p]>>gr)&gm)+((map[p-1]>>gr)&gm)+((map[p+x]>>gr)&gm)+((map[p+x-1]>>gr)&gm))<<gl;
       pict[i++] = (((map[p]>>br)&bm)+((map[p-1]>>br)&bm)+((map[p+x]>>br)&bm)+((map[p+x-1]>>br)&bm))<<bl;
       p += 2*x;
      }
     }
    }
   }
   if (bytespp == 4)
   {
    unsigned int* map = ((unsigned int*)copyfb)+offset;
    if (orient == 0)
    {
     for (j = 0; j < y; j+=2)
     {
      for (k = 0; k < xpic; k+=2)
      {
       pict[i++] = (((map[p]>>rr)&rm)+((map[p+1]>>rr)&rm)+((map[p+x]>>rr)&rm)+((map[p+x+1]>>rr)&rm))>>2<<rl;
       pict[i++] = (((map[p]>>gr)&gm)+((map[p+1]>>gr)&gm)+((map[p+x]>>gr)&gm)+((map[p+x+1]>>gr)&gm))>>2<<gl;
       pict[i++] = (((map[p]>>br)&bm)+((map[p+1]>>br)&bm)+((map[p+x]>>br)&bm)+((map[p+x+1]>>br)&bm))>>2<<bl;
       p+=2;
      }
      p+=x-xpic;
      p+=x;
     }
    }
    else
    {
     for (j = 0; j < xpic; j+=2)
     {
      p = (xpic-j-1);
      for (k = 0; k < y; k+=2)
      {
       pict[i++] = (((map[p]>>rr)&rm)+((map[p-1]>>rr)&rm)+((map[p+x]>>rr)&rm)+((map[p+x-1]>>rr)&rm))>>2<<rl;
       pict[i++] = (((map[p]>>gr)&gm)+((map[p-1]>>gr)&gm)+((map[p+x]>>gr)&gm)+((map[p+x-1]>>gr)&gm))>>2<<gl;
       pict[i++] = (((map[p]>>br)&bm)+((map[p-1]>>br)&bm)+((map[p+x]>>br)&bm)+((map[p+x-1]>>br)&bm))>>2<<bl;



       p += 2*x;
      }
     }
    }
   }
  }
  else
  {
   if (bytespp == 2)
   {
    unsigned short int* map = ((unsigned short int*)copyfb)+offset;
    if (orient == 0)
    {
     for (j = 0; j < y; j++)
     {
      for (k = 0; k < xpic; k++)
      {
       pict[i++] = map[p]>>rr<<rl;
       pict[i++] = map[p]>>gr<<gl;
       pict[i++] = map[p++]>>br<<bl;
      }
      p+=x-xpic;
     }
    }
    else
    {
     for (j = 0; j < xpic; j++)
     {
      p = (xpic-j-1);
      for (k = 0; k < y; k++)
      {
       pict[i++] = map[p]>>rr<<rl;
       pict[i++] = map[p]>>gr<<gl;
       pict[i++] = map[p]>>br<<bl;
       p += x;
      }
     }
    }
   }
   if (bytespp == 4)
   {
    unsigned int* map = ((unsigned int*)copyfb)+offset;
    if (orient == 0)
    {
     for (j = 0; j < y; j++)
     {
      for (k = 0; k < xpic; k++)
      {
       pict[i++] = map[p]>>rr<<rl;
       pict[i++] = map[p]>>gr<<gl;
       pict[i++] = map[p++]>>br<<bl;
      }
      p+=x-xpic;
     }
    }
    else
    {
     for (j = 0; j < xpic; j++)
     {
      p = (xpic-j-1);
      for (k = 0; k < y; k++)
      {
       pict[i++] = map[p]>>rr<<rl;
       pict[i++] = map[p]>>gr<<gl;
       pict[i++] = map[p]>>br<<bl;
       p += x;
      }
     }
    }
   }
  }
 }
 else
 {
  i=3*(scrinfo.xres>>lowres)*(scrinfo.yres>>lowres)-3;
  if (lowres)
  {
   int rm = 0; for (k = 0; k < scrinfo.red.length; k++) rm = rm*2+1;
   int gm = 0; for (k = 0; k < scrinfo.green.length; k++) gm = gm*2+1;
   int bm = 0; for (k = 0; k < scrinfo.blue.length; k++) bm = bm*2+1;
   if (bytespp == 2)
   {
    rl -= 2;
    gl -= 2;
    bl -= 2;
    unsigned short int* map = ((unsigned short int*)copyfb)+offset;
    if (orient == 0)
    {
     for (j = 0; j < y; j+=2)
     {
      for (k = 0; k < xpic; k+=2)
      {
       pict[i++] = (((map[p]>>rr)&rm)+((map[p+1]>>rr)&rm)+((map[p+x]>>rr)&rm)+((map[p+x+1]>>rr)&rm))<<rl;
       pict[i++] = (((map[p]>>gr)&gm)+((map[p+1]>>gr)&gm)+((map[p+x]>>gr)&gm)+((map[p+x+1]>>gr)&gm))<<gl;
       pict[i++] = (((map[p]>>br)&bm)+((map[p+1]>>br)&bm)+((map[p+x]>>br)&bm)+((map[p+x+1]>>br)&bm))<<bl;
       i -= 6;
       p+=2;
      }
      p+=x-xpic;
      p+=x;
     }
    }
    else
    {
     for (j = 0; j < xpic; j+=2)
     {
      p = (xpic-j-1);
      for (k = 0; k < y; k+=2)
      {
       pict[i++] = (((map[p]>>rr)&rm)+((map[p-1]>>rr)&rm)+((map[p+x]>>rr)&rm)+((map[p+x-1]>>rr)&rm))<<rl;
       pict[i++] = (((map[p]>>gr)&gm)+((map[p-1]>>gr)&gm)+((map[p+x]>>gr)&gm)+((map[p+x-1]>>gr)&gm))<<gl;
       pict[i++] = (((map[p]>>br)&bm)+((map[p-1]>>br)&bm)+((map[p+x]>>br)&bm)+((map[p+x-1]>>br)&bm))<<bl;
       i -= 6;
       p += 2*x;
      }
     }
    }
   }
   if (bytespp == 4)
   {
    unsigned int* map = ((unsigned int*)copyfb)+offset;

    if (orient == 0)
    {
     for (j = 0; j < y; j+=2)
     {
      for (k = 0; k < xpic; k+=2)
      {
       pict[i++] = (((map[p]>>rr)&rm)+((map[p+1]>>rr)&rm)+((map[p+x]>>rr)&rm)+((map[p+x+1]>>rr)&rm))>>2<<rl;
       pict[i++] = (((map[p]>>gr)&gm)+((map[p+1]>>gr)&gm)+((map[p+x]>>gr)&gm)+((map[p+x+1]>>gr)&gm))>>2<<gl;
       pict[i++] = (((map[p]>>br)&bm)+((map[p+1]>>br)&bm)+((map[p+x]>>br)&bm)+((map[p+x+1]>>br)&bm))>>2<<bl;



       i -= 6;
       p+=2;
      }
      p+=x-xpic;
      p+=x;
     }
    }
    else
    {

     for (j = 0; j < xpic; j+=2)
     {
      p = (xpic-j-1);
      for (k = 0; k < y; k+=2)
      {
       pict[i++] = (((map[p]>>rr)&rm)+((map[p-1]>>rr)&rm)+((map[p+x]>>rr)&rm)+((map[p+x-1]>>rr)&rm))>>2<<rl;
       pict[i++] = (((map[p]>>gr)&gm)+((map[p-1]>>gr)&gm)+((map[p+x]>>gr)&gm)+((map[p+x-1]>>gr)&gm))>>2<<gl;
       pict[i++] = (((map[p]>>br)&bm)+((map[p-1]>>br)&bm)+((map[p+x]>>br)&bm)+((map[p+x-1]>>br)&bm))>>2<<bl;



       i -= 6;
       p += 2*x;
      }
     }
    }
   }
  }
  else
  {
   if (bytespp == 2)
   {
    unsigned short int* map = ((unsigned short int*)copyfb)+offset;
    if (orient == 0)
    {
     for (j = 0; j < y; j++)
     {
      for (k = 0; k < xpic; k++)
      {
       pict[i++] = map[p]>>rr<<rl;
       pict[i++] = map[p]>>gr<<gl;
       pict[i++] = map[p++]>>br<<bl;
       i -= 6;
      }
      p+=x-xpic;
     }
    }
    else
    {
     for (j = 0; j < xpic; j++)
     {
      p = (xpic-j-1);
      for (k = 0; k < y; k++)
      {
       pict[i++] = map[p]>>rr<<rl;
       pict[i++] = map[p]>>gr<<gl;
       pict[i++] = map[p]>>br<<bl;
       i -= 6;
       p += x;
      }
     }
    }
   }
   if (bytespp == 4)
   {
    unsigned int* map = ((unsigned int*)copyfb)+offset;
    if (orient == 0)
    {
     for (j = 0; j < y; j++)
     {
      for (k = 0; k < xpic; k++)
      {
       pict[i++] = map[p]>>rr<<rl;
       pict[i++] = map[p]>>gr<<gl;
       pict[i++] = map[p++]>>br<<bl;
       i -= 6;
      }
      p+=x-xpic;
     }
    }
    else
    {
     for (j = 0; j < xpic; j++)
     {
      p = (xpic-j-1);
      for (k = 0; k < y; k++)
      {
       pict[i++] = map[p]>>rr<<rl;
       pict[i++] = map[p]>>gr<<gl;
       pict[i++] = map[p]>>br<<bl;
       i -= 6;
       p += x;
      }
     }
    }
   }
  }
 }
 pthread_mutex_unlock(&fbmutex);
 if (orient == 0)
 {
  for (i = 0; i < y>>lowres; i++)
   graph[i] = pict+(i*xpic*3>>lowres);
 }
 else
 {
  for (i = 0; i < x>>lowres; i++)
   graph[i] = pict+(i*y*3>>lowres);
 }

 if (png)
 {
  png_write_info(png_ptr, info_ptr);
  png_write_image(png_ptr, graph);
  png_write_end(png_ptr, info_ptr);
  png_destroy_write_struct(&png_ptr, &info_ptr);
 }
 else
 {
  i = 0;
  while( cinfo.next_scanline < cinfo.image_height )
  {
   jpeg_write_scanlines( &cinfo, graph+i++, 1 );
  }
  jpeg_finish_compress( &cinfo );
  jpeg_destroy_compress( &cinfo );
 }
 fclose(fp);
 if (recording)
  recordingnumfinished = recordingnum-1;
 else
  recordingnumfinished = -1;




}

static
void* watchscreen(void* param)
{
 if (fbfd < 0 && screencap == -1)
  return 0;
 while (1)
 {
  if (exit_flag)
   return __null;
  pthread_mutex_lock(&diffmutex);
  pthread_cond_wait(&diffstartcond,&diffmutex);
  pthread_mutex_unlock(&diffmutex);
  int l = 0;
  int i;

  while(1)
  {
   if (exit_flag)
    return __null;
   usleep(10000);

   pthread_mutex_lock(&fbmutex);
   if (fbfd >= 0)
   {
    if (ioctl(fbfd, 0x4600, &scrinfo) != 0)
    {
     pthread_mutex_unlock(&fbmutex);
     usleep(100000);
     continue;
    }
    if (scrinfo.xres_virtual == 240)
     scrinfo.xres_virtual = 256;
    if (force_240)
     scrinfo.xres_virtual = scrinfo.xres = 240;
    if (force_544)
     scrinfo.xres_virtual = 544;
    init_fb_for_test();
   }
   int m = scrinfo.yres*scrinfo.xres;
   int offset = scrinfo.yoffset*scrinfo.xres_virtual+scrinfo.xoffset;
   if (lowest_offset > offset)
    lowest_offset = offset;
   if (firstfb)
    offset = lowest_offset;
   if (pict && lastpic);
   {
    int s = m*bytespp/4/157;
    unsigned int* map;
    if (fbfd >=0)
     memcpy(copyfb,(char*)fbmmap+offset*bytespp,m*bytespp);

    else
    {
     FILE* sc;
     if ((sc = mypopen(screencapbinaries[screencap].name,"r"))==__null)
     {
      pthread_mutex_unlock(&fbmutex);
      usleep(100000);
      continue;
     }
     char temp[1024];
     if (fread(temp,1,screencap_skipbytes,sc) != screencap_skipbytes)
     {
      mypclose(sc);

      pthread_mutex_unlock(&fbmutex);
      usleep(100000);
      continue;
     }
     fread(copyfb,bytespp,m,sc);
     mypclose(sc);
    }
    map = (unsigned int*)copyfb;
    int start = 0;
    int end = s;
    if (lastorient == 0)
    {
     if (lastflip)
      end = s*19/20;
     else
      start = s/20;
    }
    int rowlength = scrinfo.xres*bytespp/4;
    for (i=start; i < end; i++)
    {
     if (lastpic[22*i+0] != map[157*i+0] ||
     lastpic[22*i+1] != map[157*i+7] ||
     lastpic[22*i+2] != map[157*i+14] ||
     lastpic[22*i+3] != map[157*i+21] ||
     lastpic[22*i+4] != map[157*i+28] ||
     lastpic[22*i+5] != map[157*i+35] ||
     lastpic[22*i+6] != map[157*i+42] ||
     lastpic[22*i+7] != map[157*i+49] ||
     lastpic[22*i+8] != map[157*i+56] ||
     lastpic[22*i+9] != map[157*i+63] ||
     lastpic[22*i+10] != map[157*i+70] ||
     lastpic[22*i+11] != map[157*i+77] ||
     lastpic[22*i+12] != map[157*i+84] ||
     lastpic[22*i+13] != map[157*i+91] ||
     lastpic[22*i+14] != map[157*i+98] ||
     lastpic[22*i+15] != map[157*i+105] ||
     lastpic[22*i+16] != map[157*i+112] ||
     lastpic[22*i+17] != map[157*i+119] ||
     lastpic[22*i+18] != map[157*i+126] ||
     lastpic[22*i+19] != map[157*i+133] ||
     lastpic[22*i+20] != map[157*i+140] ||
     lastpic[22*i+21] != map[157*i+147])
     {


      picchanged = true;
      pthread_mutex_lock(&diffmutex);
      diffcondDiffCounter++;
      pthread_cond_broadcast(&diffcond);
      pthread_mutex_unlock(&diffmutex);
      break;
     }
    }
   }
   pthread_mutex_unlock(&fbmutex);
   if (picchanged)
    break;

   l++;
   if (recording)
   {
    if (l > 3000)
     break;
    usleep(10000);
   }
   else
   {
    if (l > 600)
     break;
    usleep(150000);
   }
  }
  if (picchanged == false)
  {
   pthread_mutex_lock(&diffmutex);
   diffcondDiffCounter++;
   pthread_cond_broadcast(&diffcond);
   pthread_mutex_unlock(&diffmutex);
  }
 }
}

static void
emptyresponse(struct mg_connection *conn,
                const struct mg_request_info *ri, void *data)
{
 send_ok(conn);
}
static char *jsonEscape(const char *buf, int len);

static int callback(void *NotUsed, int argc, char **argv, char **azColName){
 int i;
 struct mg_connection* conn = (struct mg_connection*)NotUsed;
 if (!conn)
  return 0;
 mg_printf(conn,"{");
 for(i=0; i<argc; i++)
 {
  if (argv[i])
  {
   char* t = jsonEscape(argv[i],strlen(argv[i]));
   mg_printf(conn,"\"%s\" : \"%s\"", azColName[i], t);
   delete[] t;
  }
  else
   mg_printf(conn,"\"%s\" : \"%s\"", azColName[i], "NULL");

  if (i<argc-1)
   mg_printf(conn,", ");
 }
 mg_printf(conn,"},\n");
 return 0;
}



static void
sql(struct mg_connection *conn,
                const struct mg_request_info *ri, void *data)
{
 if (ri->permissions != -1)
  return;
 send_ok(conn);
 lock_wakelock();
 access_log(ri,"sql request");
 char* post_data;
 int post_data_len;
 read_post_data(conn,ri,&post_data,&post_data_len);
 if (post_data_len)
 {
  char* zErrMsg = 0;
  mg_printf(conn,"[");
  int rc = sqlite3_exec(db,post_data,callback, (void*)conn, &zErrMsg);
  mg_printf(conn,"]");
  if( rc!=0 ){
   mg_printf(conn,"SQL error: %s\n", zErrMsg);
   sqlite3_free(zErrMsg);
  }
 }
 if (post_data)
  delete[] post_data;
}

static void
touch(struct mg_connection *conn,
                const struct mg_request_info *ri, void *data)
{

 if (ri->permissions != -1)
  return;
 lock_wakelock();
 access_log(ri,"touch inject");
 char* s = ri->uri;
 int n = 0;
 char* post_data;
 int post_data_len;
 read_post_data(conn,ri,&post_data,&post_data_len);
 int i = 0;
 if (post_data_len == 0)
 {
  n = strlen(ri->uri);
  if (n<8)
   return;
  i = 7;
 }
 else
 {
  n = post_data_len;
  s = post_data;
  i = 0;
 }
 int orient = 0;
 bool perc = false;
 if(use_uinput_mouse == false && (touchfd == -1 || scrinfo.xres == 0 || scrinfo.yres == 0))
  return;

 while(s[i] == '_')
  i++;

 while(i < n && s[i])
 {
  if (s[i]=='h')
   orient = 1;
  if (s[i]=='p')
   perc = true;
  i++;
  int x = getnum(s+i);
  while (i<n && s[i++]!='_');
  int y = getnum(s+i);
  while (i<n && s[i++]!='_');
  int down = getnum(s+i);

  while (i<n && s[i++]!='_');
  struct input_event ev;



  if (orient)
  {
   int t = x;
   x = scrinfo.xres-y;
   y = t;
  }

  if (use_uinput_mouse)
  {
   xmin = -2047;
   xmax = 2048;
   ymin = -2047;
   ymax = 2048;
  }
  int xx, yy;
  if (perc)
  {
   if (x < 0) x = 0;
   if (y < 0) y = 0;
   if (x > 65535) x = 65535;
   if (y > 65535) y = 65535;
   if (flip_touch)
   {
    x = 65535 - x;
    y = 65535 - y;
   }
   if (rotate_touch)
   {
    int t = y;
    yy = ymin + (x * (ymax - ymin)) / 65535;
    xx = xmax - (t * (xmax - xmin)) / 65535;
   }
   else
   {
    xx = xmin + (x * (xmax - xmin)) / 65535;
    yy = ymin + (y * (ymax - ymin)) / 65535;
   }
  }
  else
  {
   if (x < 0) x = 0;
   if (y < 0) y = 0;
   if (x > scrinfo.xres) x = scrinfo.xres;
   if (y > scrinfo.yres) y = scrinfo.yres;
   if (flip_touch)
   {
    x = scrinfo.xres - x;
    y = scrinfo.yres - y;
   }
   if (rotate_touch)
   {
    int t = y;
    yy = ymin + (x * (ymax - ymin)) / (scrinfo.xres);
    xx = xmax - (t * (xmax - xmin)) / (scrinfo.yres);
   }
   else
   {
    xx = xmin + (x * (xmax - xmin)) / (scrinfo.xres);
    yy = ymin + (y * (ymax - ymin)) / (scrinfo.yres);
   }
  }

  memset(&ev, 0, sizeof(ev));


  if (use_uinput_mouse)
  {
   if (uinput_fd == -1)
   {
    init_uinput();
    shutdownkey_up = up+17;
    if (geniatech)
     shutdownkey_up+=3600;
   }
   if (uinput_fd == -1)
    return;
   suinput_mouse(uinput_fd, xx, yy, (int32_t)down);
   usleep(1000);
   continue;
  }
  if (is_icecreamsandwich)
  {

   gettimeofday(&ev.time,0);
   ev.type = 0x03;
   ev.code = 53;
   ev.value = xx;
   if(write(touchfd, &ev, sizeof(ev)) < 0)
    printf("touchfd write failed.\n");

   gettimeofday(&ev.time,0);
   ev.type = 0x03;
   ev.code = 54;
   ev.value = yy;
   if(write(touchfd, &ev, sizeof(ev)) < 0)
    printf("touchfd write failed.\n");

   gettimeofday(&ev.time,0);
   ev.type = 0x03;
   ev.code = 58;
   ev.value = down>0?100:0;
   if(write(touchfd, &ev, sizeof(ev)) < 0)
    printf("touchfd write failed.\n");

   gettimeofday(&ev.time,0);
   ev.type = 0x03;
   ev.code = 48;
   ev.value = down>0?1:0;
   if(write(touchfd, &ev, sizeof(ev)) < 0)
    printf("touchfd write failed.\n");


     gettimeofday(&ev.time,0);
     ev.type = 0x01;
     ev.code = 0x14a;
     ev.value = down;
     if(write(touchfd, &ev, sizeof(ev)) < 0)
      printf("touchfd write failed.\n");
   gettimeofday(&ev.time,0);
   ev.type = 0x03;
   ev.code = 57;
   ev.value = 0;
   if(write(touchfd, &ev, sizeof(ev)) < 0)
    printf("touchfd write failed.\n");
  }
  else
  {


   if (disable_mouse_pointer == false)
   {
    if (down != 2)
    {
     gettimeofday(&ev.time,0);
     ev.type = 0x01;
     ev.code = 0x14a;
     ev.value = down;
     if(write(touchfd, &ev, sizeof(ev)) < 0)
      printf("touchfd write failed.\n");
    }
   }
   gettimeofday(&ev.time,0);
   ev.type = 0x03;
   ev.code = 48;
   if (samsung)
    ev.value = down>0?1:0;
   else
    ev.value = down>0?100:0;
   if(write(touchfd, &ev, sizeof(ev)) < 0)
    printf("touchfd write failed.\n");
   gettimeofday(&ev.time,0);
   ev.type = 0x03;
   ev.code = 50;
   ev.value = down>0?1:0;
   if(write(touchfd, &ev, sizeof(ev)) < 0)
    printf("touchfd write failed.\n");

   gettimeofday(&ev.time,0);
   ev.type = 0x03;
   ev.code = 0x00;
   ev.value = xx;
   if(write(touchfd, &ev, sizeof(ev)) < 0)
    printf("touchfd write failed.\n");

   gettimeofday(&ev.time,0);
   ev.type = 0x03;
   ev.code = 53;
   ev.value = xx;
   if(write(touchfd, &ev, sizeof(ev)) < 0)
    printf("touchfd write failed.\n");


   gettimeofday(&ev.time,0);
   ev.type = 0x03;
   ev.code = 0x01;
   ev.value = yy;
   if(write(touchfd, &ev, sizeof(ev)) < 0)
    printf("touchfd write failed.\n");

   gettimeofday(&ev.time,0);
   ev.type = 0x03;
   ev.code = 54;
   ev.value = yy;
   if(write(touchfd, &ev, sizeof(ev)) < 0)
    printf("touchfd write failed.\n");

   gettimeofday(&ev.time,0);
   ev.type = 0x00;
   ev.code = 2;
   ev.value = 0;
   if(write(touchfd, &ev, sizeof(ev)) < 0)
    printf("touchfd write failed.\n");
   }

  gettimeofday(&ev.time,0);
  ev.type = 0x00;
  ev.code = 0;
  ev.value = 0;
  if(write(touchfd, &ev, sizeof(ev)) < 0)
   printf("touchfd write failed.\n");
  usleep(1000);

 }
 send_ok(conn);
 if (post_data)
  delete[] post_data;
}
static void
qwerty_press(int fd, int key)
{
 if(key=='q')
  suinput_click(fd,16);
 else if(key=='Q')
 {
  suinput_press(fd, 42);
  suinput_click(fd,16);
  suinput_release(fd, 42);
 }
 else if(key=='w')
  suinput_click(fd,17);
 else if(key=='W')
 {
  suinput_press(fd, 42);
  suinput_click(fd,17);
  suinput_release(fd, 42);
 }
 else if(key=='e')
  suinput_click(fd,18);
 else if(key=='E')
 {
  suinput_press(fd, 42);
  suinput_click(fd,18);
  suinput_release(fd, 42);
 }
 else if(key=='r')
  suinput_click(fd,19);
 else if(key=='R')
 {
  suinput_press(fd, 42);
  suinput_click(fd,19);
  suinput_release(fd, 42);
 }
 else if(key=='t')
  suinput_click(fd,20);
 else if(key=='T')
 {
  suinput_press(fd, 42);
  suinput_click(fd,20);
  suinput_release(fd, 42);
 }
 else if(key=='y')
  suinput_click(fd,21);
 else if(key=='Y')
 {
  suinput_press(fd, 42);
  suinput_click(fd,21);
  suinput_release(fd, 42);
 }
 else if(key=='u')
  suinput_click(fd,22);
 else if(key=='U')
 {
  suinput_press(fd, 42);
  suinput_click(fd,22);
  suinput_release(fd, 42);
 }
 else if(key=='i')
  suinput_click(fd,23);
 else if(key=='I')
 {
  suinput_press(fd, 42);
  suinput_click(fd,23);
  suinput_release(fd, 42);
 }
 else if(key=='o')
  suinput_click(fd,24);
 else if(key=='O')
 {
  suinput_press(fd, 42);
  suinput_click(fd,24);
  suinput_release(fd, 42);
 }
 else if(key=='p')
  suinput_click(fd,25);
 else if(key=='P')
 {
  suinput_press(fd, 42);
  suinput_click(fd,25);
  suinput_release(fd, 42);
 }
 else if(key=='a')
  suinput_click(fd,30);
 else if(key=='A')
 {
  suinput_press(fd, 42);
  suinput_click(fd,30);
  suinput_release(fd, 42);
 }
 else if(key=='s')
  suinput_click(fd,31);
 else if(key=='S')
 {
  suinput_press(fd, 42);
  suinput_click(fd,31);
  suinput_release(fd, 42);
 }
 else if(key=='d')
  suinput_click(fd,32);
 else if(key=='D')
 {
  suinput_press(fd, 42);
  suinput_click(fd,32);
  suinput_release(fd, 42);
 }
 else if(key=='f')
  suinput_click(fd,33);
 else if(key=='F')
 {
  suinput_press(fd, 42);
  suinput_click(fd,33);
  suinput_release(fd, 42);
 }
 else if(key=='g')
  suinput_click(fd,34);
 else if(key=='G')
 {
  suinput_press(fd, 42);
  suinput_click(fd,34);
  suinput_release(fd, 42);
 }
 else if(key=='h')
  suinput_click(fd,35);
 else if(key=='H')
 {
  suinput_press(fd, 42);
  suinput_click(fd,35);
  suinput_release(fd, 42);
 }
 else if(key=='j')
  suinput_click(fd,36);
 else if(key=='J')
 {
  suinput_press(fd, 42);
  suinput_click(fd,36);
  suinput_release(fd, 42);
 }
 else if(key=='k')
  suinput_click(fd,37);
 else if(key=='K')
 {
  suinput_press(fd, 42);
  suinput_click(fd,37);
  suinput_release(fd, 42);
 }
 else if(key=='l')
  suinput_click(fd,38);
 else if(key=='L')
 {
  suinput_press(fd, 42);
  suinput_click(fd,38);
  suinput_release(fd, 42);
 }
 else if(key=='z')
  suinput_click(fd,44);
 else if(key=='Z')
 {
  suinput_press(fd, 42);
  suinput_click(fd,44);
  suinput_release(fd, 42);
 }
 else if(key=='x')
  suinput_click(fd,45);
 else if(key=='X')
 {
  suinput_press(fd, 42);
  suinput_click(fd,45);
  suinput_release(fd, 42);
 }
 else if(key=='c')
  suinput_click(fd,46);
 else if(key=='C')
 {
  suinput_press(fd, 42);
  suinput_click(fd,46);
  suinput_release(fd, 42);
 }
 else if(key=='v')
  suinput_click(fd,47);
 else if(key=='V')
 {
  suinput_press(fd, 42);
  suinput_click(fd,47);
  suinput_release(fd, 42);
 }
 else if(key=='b')
  suinput_click(fd,48);
 else if(key=='B')
 {
  suinput_press(fd, 42);
  suinput_click(fd,48);
  suinput_release(fd, 42);
 }
 else if(key=='n')
  suinput_click(fd,49);
 else if(key=='N')
 {
  suinput_press(fd, 42);
  suinput_click(fd,49);
  suinput_release(fd, 42);
 }
 else if(key=='m')
  suinput_click(fd,50);
 else if(key=='M')
 {
  suinput_press(fd, 42);
  suinput_click(fd,50);
  suinput_release(fd, 42);
 }
 else if(key=='-')
  suinput_click(fd,12);
 else if(key=='_')
 {
  suinput_press(fd, 42);
  suinput_click(fd,12);
  suinput_release(fd, 42);
 }
 else if(key=='=')
  suinput_click(fd,13);
 else if(key=='+')
 {
  suinput_press(fd, 42);
  suinput_click(fd,13);
  suinput_release(fd, 42);
 }
 else if(key==-8)
  suinput_click(fd,14);
 else if(key=='[')
  suinput_click(fd,26);
 else if(key=='{')
 {
  suinput_press(fd, 42);
  suinput_click(fd,26);
  suinput_release(fd, 42);
 }
 else if(key==']')
  suinput_click(fd,27);
 else if(key=='}')
 {
  suinput_press(fd, 42);
  suinput_click(fd,27);
  suinput_release(fd, 42);
 }
 else if(key==13)
  suinput_click(fd,28);
 else if(key==';')
  suinput_click(fd,39);
 else if(key==':')
 {
  suinput_press(fd, 42);
  suinput_click(fd,39);
  suinput_release(fd, 42);
 }
 else if(key=='\'')
  suinput_click(fd,40);
 else if(key=='"')
 {
  suinput_press(fd, 42);
  suinput_click(fd,40);
  suinput_release(fd, 42);
 }
 else if(key=='`')
  suinput_click(fd,41);
 else if(key=='~')
 {
  suinput_press(fd, 42);
  suinput_click(fd,41);
  suinput_release(fd, 42);
 }
 else if(key=='\\')
  suinput_click(fd,43);
 else if(key=='|')
 {
  suinput_press(fd, 42);
  suinput_click(fd,43);
  suinput_release(fd, 42);
 }
 else if(key==',')
  suinput_click(fd,51);
 else if(key=='<')
 {
  suinput_press(fd, 42);
  suinput_click(fd,51);
  suinput_release(fd, 42);
 }
 else if(key=='.')
  suinput_click(fd,52);
 else if(key=='>')
 {
  suinput_press(fd, 42);
  suinput_click(fd,52);
  suinput_release(fd, 42);
 }
 else if(key=='/')
  suinput_click(fd,53);
 else if(key=='?')
 {
  suinput_press(fd, 42);
  suinput_click(fd,53);
  suinput_release(fd, 42);
 }
 else if(key=='*')
  suinput_click(fd,55);
 else if(key==' ')
  suinput_click(fd,57);
 else if(key=='7')
  suinput_click(fd,71);
 else if(key=='8')
  suinput_click(fd,72);
 else if(key=='9')
  suinput_click(fd,73);
 else if(key=='4')
  suinput_click(fd,75);
 else if(key=='5')
  suinput_click(fd,76);
 else if(key=='6')
  suinput_click(fd,77);
 else if(key=='1')
  suinput_click(fd,79);
 else if(key=='2')
  suinput_click(fd,80);
 else if(key=='3')
  suinput_click(fd,81);
 else if(key=='0')
  suinput_click(fd,82);


}

static void
qwerty_press_usb(int fd, int key)
{
 if(key=='q')
  suinput_click(fd,16);
 else if(key=='Q')
 {
  suinput_press(fd, 42);
  suinput_click(fd,16);
  suinput_release(fd, 42);
 }
 else if(key=='w')
  suinput_click(fd,17);
 else if(key=='W')
 {
  suinput_press(fd, 42);
  suinput_click(fd,17);
  suinput_release(fd, 42);
 }
 else if(key=='e')
  suinput_click(fd,18);
 else if(key=='E')
 {
  suinput_press(fd, 42);
  suinput_click(fd,18);
  suinput_release(fd, 42);
 }
 else if(key=='r')
  suinput_click(fd,19);
 else if(key=='R')
 {
  suinput_press(fd, 42);
  suinput_click(fd,19);
  suinput_release(fd, 42);
 }
 else if(key=='t')
  suinput_click(fd,20);
 else if(key=='T')
 {
  suinput_press(fd, 42);
  suinput_click(fd,20);
  suinput_release(fd, 42);
 }
 else if(key=='y')
  suinput_click(fd,21);
 else if(key=='Y')
 {
  suinput_press(fd, 42);
  suinput_click(fd,21);
  suinput_release(fd, 42);
 }
 else if(key=='u')
  suinput_click(fd,22);
 else if(key=='U')
 {
  suinput_press(fd, 42);
  suinput_click(fd,22);
  suinput_release(fd, 42);
 }
 else if(key=='i')
  suinput_click(fd,23);
 else if(key=='I')
 {
  suinput_press(fd, 42);
  suinput_click(fd,23);
  suinput_release(fd, 42);
 }
 else if(key=='o')
  suinput_click(fd,24);
 else if(key=='O')
 {
  suinput_press(fd, 42);
  suinput_click(fd,24);
  suinput_release(fd, 42);
 }
 else if(key=='p')
  suinput_click(fd,25);
 else if(key=='P')
 {
  suinput_press(fd, 42);
  suinput_click(fd,25);
  suinput_release(fd, 42);
 }
 else if(key=='a')
  suinput_click(fd,30);
 else if(key=='A')
 {
  suinput_press(fd, 42);
  suinput_click(fd,30);
  suinput_release(fd, 42);
 }
 else if(key=='s')
  suinput_click(fd,31);
 else if(key=='S')
 {
  suinput_press(fd, 42);
  suinput_click(fd,31);
  suinput_release(fd, 42);
 }
 else if(key=='d')
  suinput_click(fd,32);
 else if(key=='D')
 {
  suinput_press(fd, 42);
  suinput_click(fd,32);
  suinput_release(fd, 42);
 }
 else if(key=='f')
  suinput_click(fd,33);
 else if(key=='F')
 {
  suinput_press(fd, 42);
  suinput_click(fd,33);
  suinput_release(fd, 42);
 }
 else if(key=='g')
  suinput_click(fd,34);
 else if(key=='G')
 {
  suinput_press(fd, 42);
  suinput_click(fd,34);
  suinput_release(fd, 42);
 }
 else if(key=='h')
  suinput_click(fd,35);
 else if(key=='H')
 {
  suinput_press(fd, 42);
  suinput_click(fd,35);
  suinput_release(fd, 42);
 }
 else if(key=='j')
  suinput_click(fd,36);
 else if(key=='J')
 {
  suinput_press(fd, 42);
  suinput_click(fd,36);
  suinput_release(fd, 42);
 }
 else if(key=='k')
  suinput_click(fd,37);
 else if(key=='K')
 {
  suinput_press(fd, 42);
  suinput_click(fd,37);
  suinput_release(fd, 42);
 }
 else if(key=='l')
  suinput_click(fd,38);
 else if(key=='L')
 {
  suinput_press(fd, 42);
  suinput_click(fd,38);
  suinput_release(fd, 42);
 }
 else if(key=='z')
  suinput_click(fd,44);
 else if(key=='Z')
 {
  suinput_press(fd, 42);
  suinput_click(fd,44);
  suinput_release(fd, 42);
 }
 else if(key=='x')
  suinput_click(fd,45);
 else if(key=='X')
 {
  suinput_press(fd, 42);
  suinput_click(fd,45);
  suinput_release(fd, 42);
 }
 else if(key=='c')
  suinput_click(fd,46);
 else if(key=='C')
 {
  suinput_press(fd, 42);
  suinput_click(fd,46);
  suinput_release(fd, 42);
 }
 else if(key=='v')
  suinput_click(fd,47);
 else if(key=='V')
 {
  suinput_press(fd, 42);
  suinput_click(fd,47);
  suinput_release(fd, 42);
 }
 else if(key=='b')
  suinput_click(fd,48);
 else if(key=='B')
 {
  suinput_press(fd, 42);
  suinput_click(fd,48);
  suinput_release(fd, 42);
 }
 else if(key=='n')
  suinput_click(fd,49);
 else if(key=='N')
 {
  suinput_press(fd, 42);
  suinput_click(fd,49);
  suinput_release(fd, 42);
 }
 else if(key=='m')
  suinput_click(fd,50);
 else if(key=='M')
 {
  suinput_press(fd, 42);
  suinput_click(fd,50);
  suinput_release(fd, 42);
 }
 else if(key=='-')
  suinput_click(fd,12);
 else if(key=='_')
 {
  suinput_press(fd, 42);
  suinput_click(fd,12);
  suinput_release(fd, 42);
 }
 else if(key=='=')
  suinput_click(fd,13);
 else if(key=='+')
 {
  suinput_press(fd, 42);
  suinput_click(fd,13);
  suinput_release(fd, 42);
 }
 else if(key==-8)
  suinput_click(fd,14);
 else if(key=='[')
  suinput_click(fd,26);
 else if(key=='{')
 {
  suinput_press(fd, 42);
  suinput_click(fd,26);
  suinput_release(fd, 42);
 }
 else if(key==']')
  suinput_click(fd,27);
 else if(key=='}')
 {
  suinput_press(fd, 42);
  suinput_click(fd,27);
  suinput_release(fd, 42);
 }
 else if(key==13)
  suinput_click(fd,28);
 else if(key==';')
  suinput_click(fd,39);
 else if(key==':')
 {
  suinput_press(fd, 42);
  suinput_click(fd,39);
  suinput_release(fd, 42);
 }
 else if(key=='\'')
  suinput_click(fd,40);
 else if(key=='"')
 {
  suinput_press(fd, 42);
  suinput_click(fd,40);
  suinput_release(fd, 42);
 }
 else if(key=='`')
  suinput_click(fd,41);
 else if(key=='~')
 {
  suinput_press(fd, 42);
  suinput_click(fd,41);
  suinput_release(fd, 42);
 }
 else if(key=='\\')
  suinput_click(fd,43);
 else if(key=='|')
 {
  suinput_press(fd, 42);
  suinput_click(fd,43);
  suinput_release(fd, 42);
 }
 else if(key==',')
  suinput_click(fd,51);
 else if(key=='<')
 {
  suinput_press(fd, 42);
  suinput_click(fd,51);
  suinput_release(fd, 42);
 }
 else if(key=='.')
  suinput_click(fd,52);
 else if(key=='>')
 {
  suinput_press(fd, 42);
  suinput_click(fd,52);
  suinput_release(fd, 42);
 }
 else if(key=='/')
  suinput_click(fd,53);
 else if(key=='?')
 {
  suinput_press(fd, 42);
  suinput_click(fd,53);
  suinput_release(fd, 42);
 }
 else if(key=='(')
  suinput_click(fd,179);
 else if(key==')')
  suinput_click(fd,180);
 else if(key=='*')
  suinput_click(fd,55);
 else if(key==' ')
  suinput_click(fd,57);
 else if(key=='1')
  suinput_click(fd,2);
 else if(key=='2')
  suinput_click(fd,3);
 else if(key=='3')
  suinput_click(fd,4);
 else if(key=='4')
  suinput_click(fd,5);
 else if(key=='5')
  suinput_click(fd,6);
 else if(key=='6')
  suinput_click(fd,7);
 else if(key=='7')
  suinput_click(fd,8);
 else if(key=='8')
  suinput_click(fd,9);
 else if(key=='9')
  suinput_click(fd,10);
 else if(key=='0')
  suinput_click(fd,11);
 else if(key=='!')
 {
  suinput_press(fd, 42);
  suinput_click(fd,2);
  suinput_release(fd, 42);
 }
 else if(key=='@')
 {
  suinput_press(fd, 42);
  suinput_click(fd,3);
  suinput_release(fd, 42);
 }
 else if(key=='#')
 {
  suinput_press(fd, 42);
  suinput_click(fd,4);
  suinput_release(fd, 42);
 }
 else if(key=='$')
 {
  suinput_press(fd, 42);
  suinput_click(fd,5);
  suinput_release(fd, 42);
 }
 else if(key=='%')
 {
  suinput_press(fd, 42);
  suinput_click(fd,6);
  suinput_release(fd, 42);
 }
 else if(key=='^')
 {
  suinput_press(fd, 42);
  suinput_click(fd,7);
  suinput_release(fd, 42);
 }
 else if(key=='&')
 {
  suinput_press(fd, 42);
  suinput_click(fd,8);
  suinput_release(fd, 42);
 }


}
static void
key(struct mg_connection *conn,
                const struct mg_request_info *ri, void *data)
{
 if (ri->permissions != -1)
  return;
 lock_wakelock();
 access_log(ri,"key inject");
 send_ok(conn);
 if (uinput_fd == -1 && geniatech == false)
 {
  shutdownkey_up = up+17;
  init_uinput();
 }
 bool no_uinput = false;
 if (uinput_fd == -1)
  no_uinput = true;
 bool sms_mode = false;
 int key = 0;
 bool old = false;
 int orient = 0;


 int n = 0;
 char* post_data;
 int post_data_len;
 read_post_data(conn,ri,&post_data,&post_data_len);
 if (post_data_len == 0)
 {
  delete[] post_data;
  post_data = 0;
  if (startswith(ri->uri,"/oldkey") && strlen(ri->uri)>10)
  {
   n = 9;
   old = true;
  }
  else
  if (strlen(ri->uri)>9)
  {
   n = 9;
  }
  else
   return;
  if (ri->uri[n-2] == 'h')
   orient = 1;
  if (ri->uri[n-1] == 's')
   sms_mode = true;
 }
 else
 {
  if (strlen(ri->uri)==9 && ri->uri[7] == 'h')
   orient = 1;
  if (strlen(ri->uri)==9 && ri->uri[8] == 's')
   sms_mode = true;



 }



 pthread_mutex_lock(&uinputmutex);
 while(1)
 {
  usleep(1000);
  if (post_data_len == 0)
  {
   while (ri->uri[n] != '_')
   {
          if (ri->uri[++n] == 0)
          {
           pthread_mutex_unlock(&uinputmutex);
           return;
          }
   }
   if (ri->uri[++n] == 0)
   {
    pthread_mutex_unlock(&uinputmutex);
    return;
   }
   key = getnum(ri->uri+n);
   if (old && key < 0)
    key = -key;
  }
  else
  {
   if (n>=post_data_len)
   {
    pthread_mutex_unlock(&uinputmutex);
    return;
   }
   int q = 0;
   unsigned int w = post_data[n++];
   while (w&128) { q++; w = w << 1; }
   key = (w&255)>>q;

   while (q>1 && n < post_data_len)
   {
    key = (key<<6)+(post_data[n++]&63);
    q--;
   }

  }
  if (key == 0)
  {
   pthread_mutex_unlock(&uinputmutex);
   return;
  }

  if (no_uinput || geniatech)
  {
   char device[19] = "/dev/input/event0";
   for (int i=0; i<50; i++)
   {
    int fd;
    char name[256]="Unknown";
    if (i < 10)
    {
     device[sizeof(device)-3] = '0'+(char)(i);
     device[sizeof(device)-2] = 0;
    }
    else
    {
     device[sizeof(device)-3] = '0'+(char)(i/10);
     device[sizeof(device)-2] = '0'+(char)(i%10);
     device[sizeof(device)-1] = 0;
    }
    struct input_absinfo info;
    if((fd = open(device, 00000002)) == -1)
    {
     continue;
    }
    if (ioctl(fd, (((2U) << (((0 +8)+8)+14)) | (('E') << (0 +8)) | ((0x06) << 0) | ((sizeof(name)) << ((0 +8)+8))),name) < 0)
     continue;
    if (check_type(name,"usb keyboard"))
    {
     qwerty_press_usb(fd, key);
     close(fd);
     break;
    }
    if (check_type(name,"aml_keypad"))
    {
     qwerty_press_usb(fd, key);
     close(fd);
     break;
    }
    close(fd);
   }
   continue;
  }
  if (geniatech)
  {
   if (uinput_fd == -1)
   {
    shutdownkey_up = up+17;
    init_uinput();
   }
   qwerty_press_usb(uinput_fd, key);
   continue;
  }
  if (is_icecreamsandwich && use_generic)
  {

   qwerty_press(uinput_fd, key);


   continue;
  }
  int i;
  int j = 0;
  if (sms_mode)
   for (i=0; i < speckeys.size(); i++)
    if ((speckeys[i]->ajax == key || (old && speckeys[i]->ajax == -key)) && speckeys[i]->sms)
    {

     suinput_press(uinput_fd, 57);
     if (speckeys[i]->kcm_sh)
      suinput_press(uinput_fd, 59);
     if (speckeys[i]->kcm)
      suinput_click(uinput_fd, speckeys[i]->kcm);
     suinput_release(uinput_fd, 57);
     if (speckeys[i]->kcm_sh)
      suinput_release(uinput_fd, 59);
     j++;
    }
  if (j)
   continue;
  if (!sms_mode || i == speckeys.size())
  {
   for (i=0; i < speckeys.size(); i++)
    if ((speckeys[i]->ajax == key|| (old && speckeys[i]->ajax == -key) ) && speckeys[i]->sms == false)
    {

     suinput_press(uinput_fd, 57);
     if (speckeys[i]->kcm_sh)
      suinput_press(uinput_fd, 59);
     if (speckeys[i]->kcm)
      suinput_click(uinput_fd, speckeys[i]->kcm);
     suinput_release(uinput_fd, 57);
     if (speckeys[i]->kcm_sh)
      suinput_release(uinput_fd, 59);
     j++;
    }
  }
  if (j)
   continue;
  for (i=0; i < fastkeys.size(); i++)
   if (fastkeys[i]->ajax == key || (old && fastkeys[i]->ajax == -key))
   {
    int k = i+1;
    if (orient)
    {
     if (k == 19)
      k = 22;
     else if (k == 20)
      k = 21;
     else if (k == 21)
      k = 19;
     else if (k == 22)
      k = 20;
    }
    suinput_click(uinput_fd, k);
    j++;
   }
  if (j)
   continue;
  if (48<=key && key < 58)
  {
   suinput_click(uinput_fd, key-48+7);
   j++;
  }
  if (97<=key && key < 123)
  {
   suinput_click(uinput_fd, key-97+29);
   j++;
  }
  if (65<=key && key < 91)
  {
   suinput_press(uinput_fd, 59);
   suinput_click(uinput_fd, key-65+29);
   suinput_release(uinput_fd, 59);
   j++;
  }
  if (32<=key && key <= 47)
  {
   if (spec1sh[key-32]) suinput_press(uinput_fd, 59);
   suinput_click(uinput_fd, spec1[key-32]);
   if (spec1sh[key-32]) suinput_release(uinput_fd, 59);
   j++;
  }
  if (58<=key && key <= 64)
  {
   if (spec2sh[key-58]) suinput_press(uinput_fd, 59);
   suinput_click(uinput_fd, spec2[key-58]);
   if (spec2sh[key-58]) suinput_release(uinput_fd, 59);
   j++;
  }
  if (91<=key && key <= 96)
  {
   if (spec3sh[key-91]) suinput_press(uinput_fd, 59);
   suinput_click(uinput_fd, spec3[key-91]);
   if (spec3sh[key-91]) suinput_release(uinput_fd, 59);
   j++;
  }
  if (123<=key && key <= 127)
  {
   if (spec4sh[key-123]) suinput_press(uinput_fd, 59);
   suinput_click(uinput_fd, spec4[key-123]);
   if (spec4sh[key-123]) suinput_release(uinput_fd, 59);
   j++;
  }
  if (key == -8 || (old && key == 8))
  {
   suinput_click(uinput_fd, 67);
   j++;
  }
  if (key == -13 || key == 13 || key == -10 || key == 10)
  {
   suinput_click(uinput_fd, 66);
   j++;
  }
  if (j == 0)
  {
   BIND* load = new BIND;
   if (key > 0)
   {
    load->ajax = key;
    load->disp = key;
   }
   else
   {
    load->ajax = -key;
    load->disp = -key;
   }
   load->sms = 0;
   speckeys.push_back(load);
   FILE* sk = fo("spec_keys.txt","w");
   if (!sk)
    continue;
   int nrem = 0;
   if (speckeys.size() > 2*52)
    nrem = speckeys.size() - 2*52;;
   for(i=0; i <speckeys.size(); i++)
    if (speckeys[i]->ajax || speckeys[i]->disp)
    {
     if (nrem == 0 || speckeys[i]->ajax != speckeys[i]->disp || speckeys[i]->sms)
      fprintf(sk,"%d %d %d\n",speckeys[i]->sms,speckeys[i]->ajax,speckeys[i]->disp);
     else
      nrem -= 1;
    }
   fclose(sk);
   pthread_mutex_unlock(&uinputmutex);
   run_load_keys = true;
   init_uinput();
   shutdownkey_up = up+17;
   pthread_mutex_lock(&uinputmutex);
   for (i=0; i < speckeys.size(); i++)
    if ((speckeys[i]->ajax == key|| (old && speckeys[i]->ajax == -key) ))
    {

     suinput_press(uinput_fd, 57);
     if (speckeys[i]->kcm_sh)
      suinput_press(uinput_fd, 59);
     if (speckeys[i]->kcm)
      suinput_click(uinput_fd, speckeys[i]->kcm);
     suinput_release(uinput_fd, 57);
     if (speckeys[i]->kcm_sh)
      suinput_release(uinput_fd, 59);
     j++;
    }
   }
 }
 pthread_mutex_unlock(&uinputmutex);
 if (post_data)
  delete[] post_data;

}


static void
savebuttons(struct mg_connection *conn,
                const struct mg_request_info *ri, void *data)
{
 if (ri->permissions != -1)
  return;
 lock_wakelock();
 access_log(ri,"modify buttons");
 char* post_data;
 int post_data_len;
 read_post_data(conn,ri,&post_data,&post_data_len);
 int i;
 for (i=0; i < fastkeys.size(); i++)
  fastkeys[i]->show = false;
 int n = post_data_len;
 i = 0;
 while(i<n)
 {
  if (startswith(post_data+i,"show_"))
  {
   i+=5;
   int id = getnum(post_data+i);
   if (id-1<fastkeys.size())
    fastkeys[id-1]->show = true;

  }
  else if (startswith(post_data+i,"keycode_"))
  {
   i+=8;
   int id = getnum(post_data+i);
   while (i<n && post_data[i++]!='=');
   int ajax = getnum(post_data+i);
   if (id-1<fastkeys.size())
    fastkeys[id-1]->ajax = ajax;
  }
  while (i<n && post_data[i++]!='&');
 }

 FILE* fk = fo("fast_keys.txt","w");
 if (!fk)
  return;
 for (i=0;i<fastkeys.size();i++)
 {
  fprintf(fk,"%d %d %d\n",i+1,fastkeys[i]->show,fastkeys[i]->ajax);
 }
 fclose(fk);
 mg_printf(conn,"HTTP/1.1 200 OK\r\nCache-Control: no-store, no-cache, must-revalidate\r\nCache-Control: post-check=0, pre-check=0\r\nPragma: no-cache\r\nContent-Type: text/html; charset=utf-8\r\nConnection: close\r\n\r\n<html><head><meta http-equiv=\"refresh\" content=\"0;url=phone.html\"></head><body>redirecting</body></html>");
 if (post_data)
  delete[] post_data;
}
static void
savekeys(struct mg_connection *conn,
                const struct mg_request_info *ri, void *data)
{
 if (ri->permissions != -1)
  return;
 lock_wakelock();
 access_log(ri,"modify keys");
 char* post_data;
 int post_data_len;
 read_post_data(conn,ri,&post_data,&post_data_len);
 int i;
 int n = post_data_len;
 for (i=0; i < speckeys.size(); i++)
  if (speckeys[i])
   delete speckeys[i];
 speckeys.clear();
 for (i=0; i < 106; i++)
 {
  BIND* load = new BIND;
  load->ajax = load->disp = load->sms = 0;
  speckeys.push_back(load);
 }
 i = 0;
 while(i<n)
 {
  if (startswith(post_data+i,"sms_"))
  {
   i+=4;
   int id = getnum(post_data+i);
   if (id-1<speckeys.size())
    speckeys[id-1]->sms = true;
  }
  else if (startswith(post_data+i,"keycode_"))
  {
   i+=8;
   int id = getnum(post_data+i);
   while (i<n && post_data[i++]!='=');
   int ajax = getnum(post_data+i);
   if (id-1<speckeys.size())
    speckeys[id-1]->ajax = ajax;
  }
  else if (startswith(post_data+i,"tokeycode_"))
  {
   i+=10;
   int id = getnum(post_data+i);
   while (i<n && post_data[i++]!='=');
   int disp = getnum(post_data+i);
   if (id-1<speckeys.size())
    speckeys[id-1]->disp = disp;
  }
  while (i<n && post_data[i++]!='&');
 }

 FILE* sk = fo("spec_keys.txt","w");
 if (!sk)
  return;
 for(i=0; i <speckeys.size(); i++)
  if (speckeys[i]->ajax || speckeys[i]->disp || speckeys[i]->disp)
   fprintf(sk,"%d %d %d\n",speckeys[i]->sms,speckeys[i]->ajax,speckeys[i]->disp);
 fclose(sk);
 run_load_keys = true;
 init_uinput();
 shutdownkey_up = up+17;
 mg_printf(conn,"HTTP/1.1 200 OK\r\nCache-Control: no-store, no-cache, must-revalidate\r\nCache-Control: post-check=0, pre-check=0\r\nPragma: no-cache\r\nContent-Type: text/html; charset=utf-8\r\nConnection: close\r\n\r\n<html><head><meta http-equiv=\"refresh\" content=\"0;url=phone.html\"></head><body>redirecting</body></html>");
 if (post_data)
  delete[] post_data;
}

std::string lang(const mg_request_info* ri, const char *key)
{
 FILE* f;
 if (ri->language[0] == 0 && strlen(deflanguage) == 2)
  f = fopen((dir+"language_"+deflanguage+".txt").c_str(),"r");
 else if (ri->language[0] == 0)
 {
  return key;
 }
 else
  f = fopen((dir+"language_"+ri->language+".txt").c_str(),"r");
 char line[1024];


 if (f)
 {
  if (strcmp(key,"BEFORETIME")==0)
  {
   fclose(f);
   if (strcmp(ri->language,"es")==0 || (ri->language[0] == 0 && strcmp(deflanguage,"es")==0))
    return "hace ";
   else
    return "";
  }
  int n = strlen(key);
  while (fgets(line, sizeof(line)-1, f) != __null)
  {
   int l = strlen(line);
   if (l && line[l-1] == 10)
    {line[l-1] = 0; l--;}
   if (l && line[l-1] == 13)
    {line[l-1] = 0; l--;}
   if (line[0] == 239 && line[1] == 187 && line[2] == 191)
   {
    int i;
    for (i=3;i<l+1;i++)
     line[i-3]=line[i];
    l-=3;
   }
   if (strncmp(key,line,n) == 0 && line[n] == ' ' && line[n+1] == '-' && line[n+2] == '>' && line[n+3] == ' ')
   {

    fclose(f);
    return line+n+4;
   }
  }
  fclose(f);
  return key;
 }

 return key;
}
static void
sendmenu(struct mg_connection *conn,
                const struct mg_request_info *ri, void *data);
static void
cgi(struct mg_connection *conn,
                const struct mg_request_info *ri, void *data, int lSize, char* filebuffer)
{
 int i = 0;
 int start = 0;
 while (filebuffer[i])
 {
  if (filebuffer[i] == '`')
  {
   mg_write(conn,filebuffer+start,i-start);
   i += 1;
   start = i;
   while (filebuffer[start] && filebuffer[start] != '`')
    start++;
   if (filebuffer[start] == 0)
    break;
   filebuffer[start] = 0;
   start += 1;
   mg_printf(conn,"%s",lang(ri,filebuffer+i).c_str());

   i = start;
  }
  else
  if (filebuffer[i] == '<' && filebuffer[i+1] == '<')
  {
   mg_write(conn,filebuffer+start,i-start);
   i += 2;
   start = i;
   int deep = 1;
   while (filebuffer[start])
   {
    if (filebuffer[start] == '>' && filebuffer[start+1] == '>')
     deep--;
    if (filebuffer[start] == '<' && filebuffer[start+1] == '<')
     deep++;
    if (!deep)
     break;
    start++;
   }
   if (filebuffer[start] == 0)
    break;
   filebuffer[start] = 0;
   start += 2;
   if (strcmp("MENU",filebuffer+i)==0)
   {
    sendmenu(conn,ri,data);
    i = start;
   }
   else
   if (strcmp("BUTTONS",filebuffer+i)==0)
   {
    if (ri->permissions == -1)
     for (int j=0; j < fastkeys.size(); j++)
      if (1 || fastkeys[j]->show)
      {

       mg_printf(conn,"<div class=\"widget\" id=\"button_%s\"><input type=\"button\" class=\"butt\" value=\"%s\" onclick=\"makeRequest('button_%d','')\"/></div>",fastkeys[j]->name,lang(ri,fastkeys[j]->name).c_str(),j+1);
      }
    i = start;
   }
   else
   if (strcmp("MODELNAME",filebuffer+i)==0)
   {
    if (modelname[0])
     mg_printf(conn,"%s",modelname);
    i = start;
   }
   else
   if (strcmp("XRES",filebuffer+i)==0)
   {
    mg_printf(conn,"%d",scrinfo.xres);
    i = start;
   }
   else
   if (strcmp("YRES",filebuffer+i)==0)
   {
    mg_printf(conn,"%d",scrinfo.yres);
    i = start;
   }
   else
   if (strcmp("CHAT",filebuffer+i)==0)
   {
    if (ri->permissions == -1 || (ri->permissions&4))
     mg_printf(conn,"true");
    else
     mg_printf(conn,"false");
    i = start;
   }
   else
   if (strcmp("USERNAME",filebuffer+i)==0)
   {
    if (ri->remote_user)
     mg_printf(conn,"%s",ri->remote_user);
    i = start;
   }
   else
   if (strcmp("PORT",filebuffer+i)==0)
   {
    mg_printf(conn,"%d",port);
    i = start;
   }
   else
   if (strcmp("SSLPORT",filebuffer+i)==0)
   {
    mg_printf(conn,"%d",sslport);
    i = start;
   }
   else
   if (strcmp("WEBVERSION",filebuffer+i)==0)
   {
    mg_printf(conn,"2.09");
    i = start;
   }
   else
   if (strcmp("GAMECODE",filebuffer+i)==0)
   {
    FILE* f = fopen((dir+"gamecode.txt").c_str(),"r");
    if (f)
    {
     char buff[256];
     while (fgets(buff, sizeof(buff), f) != __null)
     {
      mg_printf(conn,buff);
     }
     fclose(f);
    }
    i = start;
   }
   else
   if (strncmp("ADMIN",filebuffer+i,5)==0)
   {
    if (ri->permissions == -1 )
    {
     filebuffer[start-2] = ' ';
     filebuffer[start-1] = ' ';
     i = i+5;
     start = i;
    }
    else
     i = start;
   }
# 4740 "webkey-2.09/service/webkey.cpp"
   else
   if (strncmp("CHANGE2SSL",filebuffer+i,10)==0)
   {
    if (ri->remote_ip && has_ssl && ri->is_ssl == false)
    {
     filebuffer[start-2] = ' ';
     filebuffer[start-1] = ' ';
     i = i+10;
     start = i;
    }
    else
     i = start;
   }
   else
   if (strncmp("CHANGE2NORMAL",filebuffer+i,13)==0)
   {
    if (ri->remote_ip && has_ssl && ri->is_ssl == true)
    {
     filebuffer[start-2] = ' ';
     filebuffer[start-1] = ' ';
     i = i+13;
     start = i;
    }
    else
     i = start;
   }
   else
   if (strcmp("FRAMEBUFFER_COUNT",filebuffer+i)==0)
   {
    if (scrinfo.yres == scrinfo.yres_virtual)
     mg_printf(conn,"hidden");
    else
     mg_printf(conn,"checkbox");
    i = start;
   }
   else
   if (strncmp("REGISTRATION",filebuffer+i,12)==0)
   {
    bool r = true;
    std::string sharedpref = dir + "../shared_prefs/com.webkey_preferences.xml";
    FILE* sp = fopen(sharedpref.c_str(),"r");
    if (!sp)
           sp = fopen("/dbdata/databases/com.webkey/shared_prefs/com.webkey_preferences.xml","r");
    if (sp)
    {
     char buff[256];
     while (fgets(buff, sizeof(buff)-1, sp) != __null)
     {
      if (startswith(buff,"<boolean name=\"allowremotereg\" value=\"false\""))
      {
       r = false;
       break;
      }
     }
     fclose(sp);
    }
    if (r)
    {
     filebuffer[start-2] = ' ';
     filebuffer[start-1] = ' ';
     i = i+12;
     start = i;
    }
    else
     i = start;
   }
   else
   if (strncmp("HASUSER",filebuffer+i,7)==0)
   {
    bool r = false;
    std::string sharedpref = dir + "../shared_prefs/com.webkey_preferences.xml";
    FILE* pf = fopen((dir+passfile).c_str(),"r");
    char tmp[10];
    if (pf != __null && fgets(tmp, 9, pf) != __null)
    {
     r = true;
    }
    if (pf)
     fclose(pf);
    if (r)
    {
     filebuffer[start-2] = ' ';
     filebuffer[start-1] = ' ';
     i = i+7;
     start = i;
    }
    else
     i = start;
   }
   else
   if (strncmp("NOREGISTRATION",filebuffer+i,14)==0)
   {
    bool r = true;
    std::string sharedpref = dir + "../shared_prefs/com.webkey_preferences.xml";
    FILE* sp = fopen(sharedpref.c_str(),"r");
    if (!sp)
           sp = fopen("/dbdata/databases/com.webkey/shared_prefs/com.webkey_preferences.xml","r");
    if (sp)
    {
     char buff[256];
     while (fgets(buff, sizeof(buff)-1, sp) != __null)
     {
      if (startswith(buff,"<boolean name=\"allowremotereg\" value=\"false\""))
      {
       r = false;
       break;
      }
     }
     fclose(sp);
    }
    if (!r)
    {
     filebuffer[start-2] = ' ';
     filebuffer[start-1] = ' ';
     i = i+14;
     start = i;
    }
    else
     i = start;
   }
  }
  else
   i++;
 }

 mg_write(conn,filebuffer+start,i-start);
}
static void
sendmenu(struct mg_connection *conn,
                const struct mg_request_info *ri, void *data)
{
 lock_wakelock();
 mg_printf(conn,"<div id=\"tabs\"><ul>");
 if (ri->permissions == -1 || (ri->permissions&1))
  mg_printf(conn,"<li><a href=\"phone.html\" target=\"_top\"><span>%s</span></a></li> ",lang(ri,"Phone").c_str());
 if (ri->permissions == -1 || (ri->permissions&2))
  mg_printf(conn,"<li><a href=\"gps.html\" target=\"_top\"><span>%s</span></a></li> ",lang(ri,"GPS").c_str());
 if (ri->permissions == -1 || (ri->permissions&16))
 {
  mg_printf(conn,"<li><a href=\"sms.html\" target=\"_top\"><span>%s</span></a></li>",lang(ri,"SMS").c_str());
  mg_printf(conn,"<li><a href=\"calls.html\" target=\"_top\"><span>%s</span></a></li> ",lang(ri,"Call list").c_str());
  mg_printf(conn,"<li><a href=\"net.html\" target=\"_top\"><span>%s</span></a></li> ",lang(ri,"Net").c_str());
 }
 if (ri->permissions == -1)
 {
  mg_printf(conn,"<li><a href=\"notify.html\" target=\"_top\"><span>%s</span></a></li>",lang(ri,"Notify").c_str());
  mg_printf(conn,"<li><a href=\"terminal.html\" target=\"_top\"><span>%s</span></a></li> ",lang(ri,"Terminal").c_str());
 }
 if (ri->permissions == -1 || (ri->permissions&16))
  mg_printf(conn,"<li><a href=\"export.html\" target=\"_top\"><span>%s</span></a></li> ",lang(ri,"Export").c_str());

 if (ri->permissions == -1 || (ri->permissions&32) || (ri->permissions&8))
  mg_printf(conn,"<li><a href=\"files.html\" target=\"_top\"><span>%s</span></a></li> ",lang(ri,"Files").c_str());
 if (ri->permissions == -1 || (ri->permissions&64))
  mg_printf(conn,"<li><a href=\"sdcard.html\" target=\"_top\"><span>%s</span></a></li> ",lang(ri,"Sdcard").c_str());


 mg_printf(conn,"<li><a href=\"help.html\" target=\"_top\"><span>%s</span></a></li> ",lang(ri,"Help").c_str());
 mg_printf(conn,"<li id=\"menulastli\"></li></ul></div>");
# 4924 "webkey-2.09/service/webkey.cpp"
}


static void
getfile(struct mg_connection *conn,
                const struct mg_request_info *ri, void *data)
{
 FILE* f;
 if (strcmp(ri->uri,"/")==0)
  f = fo("index.html","rb");
 else
  f = fo(ri->uri,"rb");
 if(!f)
  return;
 fseek (f , 0 , 2);
 int lSize = ftell (f);



  send_ok(conn,__null);
 rewind (f);
 char* filebuffer = new char[lSize+1];
 if (filebuffer)
 {
  fread(filebuffer,1,lSize,f);
  filebuffer[lSize] = 0;
  cgi(conn,ri,data,lSize,filebuffer);
  fclose(f);
  delete[] filebuffer;
 }
}
static void
sendfile(const char* file,struct mg_connection *conn, bool sendok = false, char * extra = __null)
{
 FILE* f = fopen(file,"rb");
 if(!f)
 {
  if (sendok)
   send_ok(conn);
  return;
 }
 fseek (f , 0 , 2);
 int lSize = ftell (f);
 if (sendok)
  send_ok(conn,extra,lSize);
 rewind (f);
 char* filebuffer = new char[65536];
 if (filebuffer)
 {
  while(lSize>0)
  {
   int s = min(65536,lSize);
   fread(filebuffer,1,min(65536,lSize),f);
   mg_write(conn,filebuffer,s);
   lSize -= s;
  }
  fclose(f);
  delete[] filebuffer;
 }
}
static void
index(struct mg_connection *conn,
                const struct mg_request_info *ri, void *data)
{
 if (ri->permissions != -1 && (ri->permissions&1)==0)
 {
  mg_printf(conn,"HTTP/1.1 200 OK\r\nCache-Control: no-store, no-cache, must-revalidate\r\nCache-Control: post-check=0, pre-check=0\r\nPragma: no-cache\r\nContent-Type: text/html; charset=utf-8\r\nConnection: close\r\n\r\n<html><head><meta http-equiv=\"refresh\" content=\"0;url=pure_menu.html\"></head><body>Redirecting...</body></html>");
  return;
 }
 lock_wakelock();
 getfile(conn,ri,data);
}
static void
generic_button(int fd, int key, int time)
{
 if (key == 21)
  key = 21;
 else if (key == 19)
  key = 19;
 else if (key == 20)
  key = 20;
 else if (key == 22)
  key = 22;
 else if (key == 3)
  key = 3;
 else if (key == 2)
  key = 5;
 else if (key == 4)
  key = 4;
 else if (key == 82)
  key = 82;
 else if (key == 6)
  key = 6;


 else if (key == 23)
  key = 23;



 if (time)
 {
  struct input_event event;
  memset(&event, 0, sizeof(event));
  gettimeofday(&event.time, 0);
  event.type = 0x01;
  event.code = key;
  event.value = 1;
  write(fd, &event, sizeof(event));
  usleep(time*1000);
  event.value = 0;
  write(fd, &event, sizeof(event));
 }
 else
  suinput_click(fd, key, 0);
}
static void
qwerty_button(int fd, int key, int time)
{
 if (key == 21)
  key = 105;
 else if (key == 19)
  key = 103;
 else if (key == 20)
  key = 108;
 else if (key == 22)
  key = 106;
 else if (key == 3)
  key = 172;
 else if (key == 2)
  key = 169;
 else if (key == 4)
  key = 158;
 else if (key == 82)
  key = 127;
 else if (key == 6)
  key = 116;
 else if (key == 23)
  key = 97;



 if (time)
 {
  struct input_event event;
  memset(&event, 0, sizeof(event));
  gettimeofday(&event.time, 0);
  event.type = 0x01;
  event.code = key;
  event.value = 1;
  write(fd, &event, sizeof(event));
  usleep(time*1000);
  event.value = 0;
  write(fd, &event, sizeof(event));
 }
 else
  suinput_click(fd, key, 0);
}
static void
geniatech_button(int fd, int key, int time)
{
 if (key == 21)
  key = 105;
 else if (key == 19)
  key = 103;
 else if (key == 20)
  key = 108;
 else if (key == 22)
  key = 106;
 else if (key == 3)
  key = 60;
 else if (key == 2)
  key = 169;
 else if (key == 4)
  key = 158;
 else if (key == 82)
  key = 127;
 else if (key == 6)
  key = 116;
 else if (key == 23)
  key = 97;



 if (time)
 {
  struct input_event event;
  memset(&event, 0, sizeof(event));
  gettimeofday(&event.time, 0);
  event.type = 0x01;
  event.code = key;
  event.value = 1;
  write(fd, &event, sizeof(event));
  usleep(time*1000);
  event.value = 0;
  write(fd, &event, sizeof(event));
 }
 else
  suinput_click(fd, key, 0);
}
static void
qwerty_button_usb(int fd, int key, int time)
{
 if (key == 21)
  key = 105;
 else if (key == 19)
  key = 103;
 else if (key == 20)
  key = 108;
 else if (key == 22)
  key = 106;
 else if (key == 3)
  key = 102;
 else if (key == 2)
  key = 61;
 else if (key == 4)
  key = 1;
 else if (key == 82)
  key = 59;
 else if (key == 6)
  key = 116;
 else if (key == 84)
  key = 217;
 else if (key == 28)
  return;


 if (time)
 {
  struct input_event event;
  memset(&event, 0, sizeof(event));
  gettimeofday(&event.time, 0);
  event.type = 0x01;
  event.code = key;
  event.value = 1;
  write(fd, &event, sizeof(event));
  usleep(time*1000);
  event.value = 0;
  write(fd, &event, sizeof(event));
 }
 else
  suinput_click(fd, key, 0);
}
static void
button(struct mg_connection *conn,
                const struct mg_request_info *ri, void *data)
{




 send_ok(conn);
 lock_wakelock();
 access_log(ri,"button inject");
 int key = getnum(ri->uri+8);
 int i = 8;
 while(ri->uri[i] && ri->uri[i] != '_') i++;
 long time = 0;
 if (i < strlen(ri->uri))
  time = getnum(ri->uri+i+1);
 if (geniatech)
 {
  if (key == 28)
   return;
  char device[19] = "/dev/input/event0";
  for (int i=0; i<50; i++)
  {
   int fd;
   char name[256]="Unknown";
   if (i < 10)
   {
    device[sizeof(device)-3] = '0'+(char)(i);
    device[sizeof(device)-2] = 0;
   }
   else
   {
    device[sizeof(device)-3] = '0'+(char)(i/10);
    device[sizeof(device)-2] = '0'+(char)(i%10);
    device[sizeof(device)-1] = 0;
   }
   struct input_absinfo info;
   if((fd = open(device, 00000002)) == -1)
   {
    continue;
   }
   if (ioctl(fd, (((2U) << (((0 +8)+8)+14)) | (('E') << (0 +8)) | ((0x06) << 0) | ((sizeof(name)) << ((0 +8)+8))),name) < 0)
    continue;
   if (check_type(name,"aml_keypad"))
   {
    geniatech_button(fd, key, time);
    close(fd);
    break;
   }
   close(fd);
  }
  return;
 }
 if (uinput_fd == -1)
 {
  init_uinput();
  shutdownkey_up = up+17;
 }
 bool no_uinput = false;
 if (uinput_fd == -1)
  no_uinput = true;
 if (is_icecreamsandwich && no_uinput == false)
 {
  if (key == 28 && is_icecreamsandwich)
   key = 59;
  generic_button(uinput_fd, key, time);
  return;
 }
# 5245 "webkey-2.09/service/webkey.cpp"
 std::string devpath = device_names["sec_key"];
 if ((key == 24 ||
     key == 25 ||
     key == 3 ||
     key == 26)
    && devpath.size())
 {
     int fd = open(devpath.c_str(), 00000001 | 00004000);
     if (fd > -1)
     {
      if (key == 24) key = 115;
      if (key == 25) key = 114;
      if (key == 3) key = 102;
      if (key == 26) key = 116;
      suinput_click(fd, key, 0);
      close(fd);
      return;
     }
 }
 devpath = device_names["sec_touchkey"];
 if ((key == 82 ||
     key == 4)
    && devpath.size())
 {
     int fd = open(devpath.c_str(), 00000001 | 00004000);
     if (fd > -1)
     {
      if (key == 82) key = 139;
      if (key == 4) key = 158;
      suinput_click(fd, key, 0);
      close(fd);
      return;
     }
 }

 devpath = device_names["s3c-keypad"];
 if ((key == 3 ||
     key == 26 ||
     key == 24 ||
     key == 25)
    && devpath.size())
 {
     int fd = open(devpath.c_str(), 00000001 | 00004000);
     if (fd > -1)
     {
      if (key == 3) key = 50;
      if (key == 26) key = 26;
      if (key == 24) key = 42;
      if (key == 25) key = 58;
      suinput_click(fd, key, 0);
      close(fd);
      return;
     }
 }
# 5338 "webkey-2.09/service/webkey.cpp"
   {


  if (no_uinput)
  {
   if (key == 28 && is_icecreamsandwich)
    key = 42;
   char device[19] = "/dev/input/event0";
   for (int i=0; i<50; i++)
   {
    int fd;
    char name[256]="Unknown";
    if (i < 10)
    {
     device[sizeof(device)-3] = '0'+(char)(i);
     device[sizeof(device)-2] = 0;
    }
    else
    {
     device[sizeof(device)-3] = '0'+(char)(i/10);
     device[sizeof(device)-2] = '0'+(char)(i%10);
     device[sizeof(device)-1] = 0;
    }
    struct input_absinfo info;
    if((fd = open(device, 00000002)) == -1)
    {
     continue;
    }
    if (ioctl(fd, (((2U) << (((0 +8)+8)+14)) | (('E') << (0 +8)) | ((0x06) << 0) | ((sizeof(name)) << ((0 +8)+8))),name) < 0)
     continue;
    if (check_type(name,"usb keyboard"))
     qwerty_button_usb(fd, key, time);
    close(fd);
   }

  }
  else
  {
   if (time)
   {
    struct input_event event;
    memset(&event, 0, sizeof(event));
    gettimeofday(&event.time, 0);
    event.type = 0x01;
    event.code = key;
    event.value = 1;
    write(uinput_fd, &event, sizeof(event));
    usleep(time*1000);
    event.value = 0;
    write(uinput_fd, &event, sizeof(event));
   }
   else
    suinput_click(uinput_fd, key, 0);
  }
 }
}
static void
config_buttons(struct mg_connection *conn,
                const struct mg_request_info *ri, void *data)
{
 if (ri->permissions != -1)
  return;
 lock_wakelock();
 getfile(conn,ri,data);
 mg_printf(conn,"<table border=\"1\">\n");
 int i;
 for (i=0; i < fastkeys.size(); i++)
 {
  mg_printf(conn, "<tr><td>%s</td>",lang(ri,fastkeys[i]->name).c_str());
  mg_printf(conn, "<td><input type=\"checkbox\" name=\"show_%d\">%s</input></td>",i+1,lang(ri,"Show").c_str());
  mg_printf(conn, "<td>%s: <input type=\"text\" name=\"key_%d\" maxlength=\"1\" size=\"1\" onkeypress=\"var unicode=event.charCode? event.charCode : -event.keyCode;document.config_buttons.keycode_%d.value=unicode; document.config_buttons.key_%d.value=String.fromCharCode(document.config_buttons.keycode_%d.value)\"/></td>",lang(ri,"Key").c_str(),i+1,i+1,i+1,i+1);
  mg_printf(conn, "<td>%s: <input type=\"text\" name=\"keycode_%d\" maxlength=\"8\" size=\"8\" onkeyup=\"document.config_buttons.key_%d.value=String.fromCharCode(document.config_buttons.keycode_%d.value)\"/></td></tr>\n",lang(ri,"Keycode").c_str(),i+1,i+1,i+1);
 }
 mg_printf(conn,"</table></form>\n<script type=\"text/javascript\" language=\"javascript\">");

 for (i=0; i < fastkeys.size(); i++)
 {
  mg_printf(conn,"document.config_buttons.key_%d.value=String.fromCharCode(%d);document.config_buttons.keycode_%d.value='%d';document.config_buttons.show_%d",i+1,fastkeys[i]->ajax,i+1,fastkeys[i]->ajax,i+1);
  if (fastkeys[i]->show)
   mg_printf(conn,".checked='checked';\n");
  else
   mg_printf(conn,".checked='';\n");
 }
 mg_printf(conn,"</script></body></html>");
}
static void
notify_html(struct mg_connection *conn,
                const struct mg_request_info *ri, void *data)
{
 if (ri->permissions != -1)
  return;
 lock_wakelock();
 getfile(conn,ri,data);
 mg_printf(conn,"<script type=\"text/javascript\" language=\"javascript\">\n");
 mg_printf(conn,"document.getElementById('callon').checked = %s;\n",notify.callon?"true":"false");
 mg_printf(conn,"document.getElementById('smson').checked = %s;\n",notify.smson?"true":"false");
 mg_printf(conn,"document.getElementById('interval').value = %d;\n",notify.interval);
 mg_printf(conn,"document.getElementById('vibrate').checked = %s;\n",notify.vibrate?"true":"false");
 std::string t;
 int i;
 for (i = 0; i < notify.vibratepatt.length(); i++)
 {
  if (notify.vibratepatt[i] != '~')
   t += notify.vibratepatt[i];
  else
   t += ',';
 }
 mg_printf(conn,"document.getElementById('vibratepatt').value = \"%s\";\n",t.c_str());
 mg_printf(conn,"document.getElementById('blink').checked = %s;\n",notify.blink?"true":"false");
 mg_printf(conn,"document.getElementById('blinktype').selectedIndex = \"%d\";\n",notify.blinktype);
 mg_printf(conn,"document.getElementById('blinkon').checked = %d;\n",notify.blinkon);
 mg_printf(conn,"document.getElementById('blinkoff').checked = %d;\n",notify.blinkoff);
 mg_printf(conn,"</script></body></html>");
}
static bool
setupnotify(char * st, bool test = false)
{
 int n = strlen(st);
 if (st[n-1] == '\n')
  st[--n] = 0;
 int pos[8];
 int i;
 i = 0;
 int j;
 j = 0;
 while(st[i] && j < 8 && i < n)
 {
  if (st[i] == '_')
  {
   st[i] = 0;
   pos[j++] = i+1;
  }
  i++;
 }
 if (j<8)
  return false;
 set_blink(0,0,0);
 if (startswith(st,"true") || startswith(st,"checked"))
  notify.callon = true;
 else
  notify.callon = false;
 if (startswith(st+pos[0],"true") || startswith(st+pos[0],"checked"))
  notify.smson = true;
 else
  notify.smson = false;
 notify.interval = getnum(st+pos[1]);
 if (startswith(st+pos[2],"true") || startswith(st+pos[2],"checked"))
  notify.vibrate = true;
 else
  notify.vibrate = false;
 notify.vibratepatt = std::string(st+pos[3]);
 if (startswith(st+pos[4],"true") || startswith(st+pos[4],"checked"))
  notify.blink = true;
 else
  notify.blink = false;
 notify.blinktype = getnum(st+pos[5]);
 notify.blinkon = getnum(st+pos[6]);
 notify.blinkoff = getnum(st+pos[7]);

 notify.lastalarm = -1000000;
 if (test)
 {
  if (notify.blink)
   set_blink(1,notify.blinkon,notify.blinkoff);
  if (notify.vibrate)
  {
   int v, p, i;
   p = 0; v = 0;
   i = -1;
   bool b;
   b = false;
   while (i < notify.vibratepatt.size() || i == -1)
   {
    if (i == -1 || notify.vibratepatt[i] == '~')
    {
     p = v;
     v = getnum(notify.vibratepatt.c_str()+i+1);
     b = !b;
     if (b)
      vibrator_on(v);
     else
      usleep((p+v)*1000);
    }
    i++;
   }
   if (!b && notify.blink)
    usleep(v*1000);
  }
  if (notify.blink)
   set_blink(0,0,0);
 }
 return true;
}
static void
setnotify(struct mg_connection *conn,
                const struct mg_request_info *ri, void *data)
{
 if (ri->permissions != -1)
  return;
 lock_wakelock();
 access_log(ri,"setup notify");
 send_ok(conn);
 if (ri->uri[10] == '_')
 {
  FILE * out = fopen((dir+"notify.txt").c_str(),"w");
  if (out)
  {
   fprintf(out,"%s",ri->uri+11);
   fclose(out);
  }
  setupnotify(ri->uri+11,true);
 }
}
static void
config_keys(struct mg_connection *conn,
                const struct mg_request_info *ri, void *data)
{
 if (ri->permissions != -1)
  return;
 lock_wakelock();
 getfile(conn,ri,data);
 mg_printf(conn,"<table border=\"1\">\n");
 int i;
 for (i=0; i < 106; i++)
 {
  mg_printf(conn,"<tr><td>%s: <input type=\"text\" name=\"key_%d\" maxlength=\"1\" size=\"1\" onkeypress=\"var unicode=event.charCode? event.charCode : event.keyCode;document.config_keys.keycode_%d.value=unicode; document.config_keys.key_%d.value=String.fromCharCode(document.config_keys.keycode_%d.value)\"/></td>",lang(ri,"Char").c_str(),i+1,i+1,i+1,i+1);
  mg_printf(conn,"<td>%s: <input type=\"text\" name=\"keycode_%d\" maxlength=\"8\" size=\"8\" onkeyup=\"document.config_keys.key_%d.value=String.fromCharCode(document.config_keys.keycode_%d.value)\"/></td>",lang(ri,"Keycode").c_str(),i+1,i+1,i+1);
  mg_printf(conn,"<td> %s </td>",lang(ri,"converts to").c_str());
  mg_printf(conn,"<td>%s: <input type=\"text\" name=\"tokey_%d\" maxlength=\"1\" size=\"1\" onkeypress=\"var unicode=event.charCode? event.charCode : event.keyCode;document.config_keys.tokeycode_%d.value=unicode; document.config_keys.tokey_%d.value=String.fromCharCode(document.config_keys.tokeycode_%d.value)\"/></td>",lang(ri,"Char").c_str(),i+1,i+1,i+1,i+1);
  mg_printf(conn,"<td>%s: <input type=\"text\" name=\"tokeycode_%d\" maxlength=\"8\" size=\"8\" onkeyup=\"document.config_keys.tokey_%d.value=String.fromCharCode(document.config_keys.tokeycode_%d.value)\"/></td>",lang(ri,"Keycode").c_str(),i+1,i+1,i+1);
  mg_printf(conn,"<td><input type=\"checkbox\" name=\"sms_%d\">%s</input></td></tr>\n",i+1,lang(ri,"works in SMS mode").c_str());
 }
 mg_printf(conn,"</table></form>\n<script type=\"text/javascript\" language=\"javascript\">\n");

 for (i=0; i < speckeys.size(); i++)
 {
  mg_printf(conn,"document.config_keys.key_%d.value=String.fromCharCode(%d);document.config_keys.keycode_%d.value='%d';document.config_keys.tokey_%d.value=String.fromCharCode(%d);document.config_keys.tokeycode_%d.value='%d';document.config_keys.sms_%d",i+1,speckeys[i]->ajax,i+1,speckeys[i]->ajax,i+1,speckeys[i]->disp,i+1,speckeys[i]->disp,i+1);
  if (speckeys[i]->sms)
   mg_printf(conn,".checked='checked';\n");
  else
   mg_printf(conn,".checked='';\n");
 }
 mg_printf(conn,"</script></body></html>");
}
static std::string getoption(char* list, char* option)
{
 std::string ret;
 int n = strlen(list);
 int i;
 for (i = 0; i < n; i++)
  if (startswith(list+i, option))
  {
   i+=strlen(option);
   while(i<n && list[i] != '&')
    ret += list[i++];
   break;
  }
 return ret;
}

static void
getreg(struct mg_connection *conn,
                const struct mg_request_info *ri, void *data)
{
 if (ri->remote_ip!=2130706433 || strcmp(ri->remote_user,"JAVA_CLIENT") != 0)
  return;
 send_ok(conn);



 mg_printf(conn,"%s\n%s\n%u",requested_username.c_str(),requested_password.c_str(),requested_ip);

 requested_username = "";
 requested_password = "";
}
static void
reg(struct mg_connection *conn,
                const struct mg_request_info *ri, void *data)
{

 bool r = true;
 std::string sharedpref = dir + "../shared_prefs/com.webkey_preferences.xml";
 FILE* sp = fopen(sharedpref.c_str(),"r");
 if (!sp)
  sp = fopen("/dbdata/databases/com.webkey/shared_prefs/com.webkey_preferences.xml","r");
 if (sp)
 {
  char buff[256];
  while (fgets(buff, sizeof(buff)-1, sp) != __null)
  {
   if (startswith(buff,"<boolean name=\"allowremotereg\" value=\"false\""))
   {
    r = false;
    break;
   }
  }
  fclose(sp);
 }
 if (!r)
 {
  mg_printf(conn,"HTTP/1.1 200 OK\r\nCache-Control: no-store, no-cache, must-revalidate\r\nCache-Control: post-check=0, pre-check=0\r\nPragma: no-cache\r\nContent-Type: text/html; charset=utf-8\r\nConnection: close\r\n\r\n<html><head><meta http-equiv=\"refresh\" content=\"3;url=index.html\"></head><body>%s",lang(ri,"New user's registration is disabled, click on \"allow user registration in browser\" to enable it.").c_str());
  mg_printf(conn,"%s</body></html>",lang(ri,"Reloading...").c_str());
  return;
 }
 char* post_data;
 int post_data_len;
 read_post_data(conn,ri,&post_data,&post_data_len);
 requested_username = "";

 if (strncmp(post_data,"username=",9))
  return;
 int i = 9;
 while (i < post_data_len && post_data[i] != '&')
 {
  requested_username += post_data[i++];
 }
 if (strncmp(post_data+i,"&password=",10))
 {
  requested_username = "";
  return;
 }
 i += 10;
 requested_password = "";
 while (i < post_data_len && post_data[i] != '&')
 {
  requested_password += post_data[i++];
 }
 if (requested_username.size() >= 4096 -1 || requested_password.size() >= 4096 -1)
 {
  requested_username = "";
  return;
 }

 requested_ip = ri->remote_ip;
 char to[4096];
 strcpy(to,requested_username.c_str());
 url_decode(to, strlen(to), to, 4096, true);
 requested_username = to;
 strcpy(to,requested_password.c_str());
 url_decode(to, strlen(to), to, 4096, true);
 requested_password = to;
 delete[] post_data;
 mg_printf(conn,"HTTP/1.1 200 OK\r\nCache-Control: no-store, no-cache, must-revalidate\r\nCache-Control: post-check=0, pre-check=0\r\nPragma: no-cache\r\nContent-Type: text/html; charset=utf-8\r\nConnection: close\r\n\r\n<html><head><meta http-equiv=\"refresh\" content=\"10;url=index.html\"></head><body>%s ",lang(ri,"Registration request sent, please wait until it's authorized on the phone.").c_str());
 mg_printf(conn,"%s<br/><img alt=\"reganim\" src=\"reganim.gif\"/></body></html>",lang(ri,"Reloading...").c_str());
 syst("am broadcast -a \"webkey.intent.action.remote.registration\"&");
}
static void
setpassword(struct mg_connection *conn,
                const struct mg_request_info *ri, void *data)
{


 if (ri->remote_ip!=2130706433 || (ri->remote_user && strcmp(ri->remote_user,"JAVA_CLIENT") != 0))
  return;
 char* post_data;
 int post_data_len;
 read_post_data(conn,ri,&post_data,&post_data_len);
 int i = 0;
 int pos[1];
 int j = 0;
 for (;i < post_data_len; i++)
 {
  if (post_data[i] == '\n' && j < 1)
  {
   post_data[i] = 0;
   pos[j++] = i+1;
  }
 }



 mg_modify_passwords_file(ctx, (dir+passfile).c_str(), post_data, post_data+pos[0],-2);
 chmod((dir+passfile).c_str(), 00400|00200|00040|00020);
 chown((dir+passfile).c_str(), info.st_uid, info.st_gid);
 chmod((dir+passfile).c_str(), 00400|00200|00040|00020);
 send_ok(conn);
}
static void
setpermission(struct mg_connection *conn,
                const struct mg_request_info *ri, void *data)
{
 if (ri->remote_ip!=2130706433 || (ri->remote_user && strcmp(ri->remote_user,"JAVA_CLIENT") != 0))
  return;
 char* post_data;
 int post_data_len;
 read_post_data(conn,ri,&post_data,&post_data_len);
 int i = 0;
 int pos[2];
 int j = 0;
 for (;i < post_data_len; i++)
 {
  if (post_data[i] == '\n' && j < 2)
  {
   post_data[i] = 0;
   pos[j++] = i+1;
  }
 }




 mg_modify_passwords_file(ctx, (dir+passfile).c_str(), post_data, post_data+pos[0],getnum(post_data+pos[1]));
 chmod((dir+passfile).c_str(), 00400|00200|00040|00020);
 chown((dir+passfile).c_str(), info.st_uid, info.st_gid);
 chmod((dir+passfile).c_str(), 00400|00200|00040|00020);
 send_ok(conn);
}

static void
config(struct mg_connection *conn,
                const struct mg_request_info *ri, void *data)
{


 lock_wakelock();
 char* post_data;
 int post_data_len;
 read_post_data(conn,ri,&post_data,&post_data_len);
        int n = post_data_len;
 int i = 0;
 char name[256];
 char pass[256];
 name[0] = pass[0] = 0;
 bool changed = false;
 bool changed_perm = false;
 int permissions = 0;
 int j = 0;
 if (n>256)
  return;
 while(i < n)
 {

  if (!memcmp(post_data+i, "username",8))
  {
   i+=9;
   j = 0;
   while(i<n && post_data[i] != '&' && j<255)
    name[j++] = post_data[i++];
   name[j] = 0; i++;
  }
  else if (!memcmp(post_data+i, "permission",10))
  {
   changed_perm = true;
   changed = true;
   i+=10;
   if (post_data[i] < '8' && post_data[i] >= '0' && permissions != -1)
   {
    int p = post_data[i] - 48;
    if (p == 0)
     permissions = -1;
    else
     permissions = permissions | (1<<(p-1));
   }

   while(i<n && post_data[i] != '&')
    i++;
   i++;
  }
  else if (!memcmp(post_data+i, "password",8))
  {
   i+=9;
   int k = 0;
   while(i<n && post_data[i] != '&' && k<255)
    pass[k++] = post_data[i++];
   pass[k] = 0; i++;
   if (j && k)
   {
    if (ri->permissions == -1 || strcmp(ri->remote_user,name)==0)
    {
     access_log(ri,"modify users");
     url_decode(name, strlen(name), name, 4096, true);
     url_decode(pass, strlen(pass), pass, 4096, true);
     for (int q = 0; q < strlen(name); q++)
      if (name[q] == ':')
       name[q] = ' ';
     mg_modify_passwords_file(ctx, (dir+passfile).c_str(), name, pass,-2);
    }
    changed = true;
   }
  }
  else if (!memcmp(post_data+i, "remove",6))
  {
   i=n;
   if (j)
   {
    if (ri->permissions == -1)
    {
     access_log(ri,"modify users");
     url_decode(name, strlen(name), name, 4096, true);
     for (int q = 0; q < strlen(name); q++)
      if (name[q] == ':')
       name[q] = ' ';
     mg_modify_passwords_file(ctx, (dir+passfile).c_str(), name, "",-2);
    }
    changed = true;
   }
  }
  else if (!memcmp(post_data+i, "dellog",6))
  {
   if (ri->permissions == -1)
   {

    pthread_mutex_lock(&logmutex);
    FILE* f = fopen(logfile.c_str(),"w");
    if (f)
    {
     fclose(f);
     access_times.clear();
     pthread_mutex_unlock(&logmutex);
     access_log(ri,"clear log");
    }
    else
     pthread_mutex_unlock(&logmutex);
   }
   changed = true;
   break;
  }
  else
   i++;
 }
 if (changed_perm && ri->permissions == -1)
 {
  if (permissions != -1 && (permissions & 8) && (permissions & 32))
   permissions = (permissions ^ 8);
  url_decode(name, strlen(name), name, 4096, true);
  url_decode(pass, strlen(pass), pass, 4096, true);
  for (int q = 0; q < strlen(name); q++)
   if (name[q] == ':')
    name[q] = ' ';
  mg_modify_passwords_file(ctx, (dir+passfile).c_str(), name, pass,permissions);
  access_log(ri,"modify permissions");
 }
 if (changed)
 {
  if (!data)
   mg_printf(conn,"HTTP/1.1 200 OK\r\nCache-Control: no-store, no-cache, must-revalidate\r\nCache-Control: post-check=0, pre-check=0\r\nPragma: no-cache\r\nContent-Type: text/html; charset=utf-8\r\nConnection: close\r\n\r\n<html><head><meta http-equiv=\"refresh\" content=\"1;url=config\"></head><body>%s</body></html>",lang(ri,"Saved, reloading ...").c_str());
  else
   mg_printf(conn,"HTTP/1.1 200 OK\r\nCache-Control: no-store, no-cache, must-revalidate\r\nCache-Control: post-check=0, pre-check=0\r\nPragma: no-cache\r\nContent-Type: text/html; charset=utf-8\r\nConnection: close\r\n\r\n<html><head><meta http-equiv=\"refresh\" content=\"1;url=usersconfig\"></head><body>%s</body></html>",lang(ri,"Saved, reloading ...").c_str());
  if (post_data)
   delete[] post_data;
  return;
 }
 send_ok(conn);
 mg_printf(conn,"<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\n<html>\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n<title>%s</title>",lang(ri,"Webkey for Android").c_str());
        mg_printf(conn,"<link href=\"css/jquery-ui.css\" rel=\"stylesheet\" type=\"text/css\"/><link href=\"css/webkey.css\" rel=\"stylesheet\" type=\"text/css\"/><link rel=\"shortcut icon\" href=\"favicon.ico\"><script src=\"js/jquery.js\"></script><script src=\"js/jquery-ui.min.js\"></script><script src=\"js/webkey.js\"></script></head><body>");
 if (!data)
  sendmenu(conn,ri,__null);

 char line[256]; char domain[256];
 FILE* fp = fo(passfile.c_str(),"r");
 if (!fp)
  return;
 while (fgets(line, sizeof(line)-1, fp) != __null)
 {
  permissions = -1;
  if (sscanf(line, "%[^:]:%[^:]:%[^:]:%d", name, domain, pass, &permissions) < 3)
   continue;
  if (ri->permissions != -1 && strcmp(name,ri->remote_user)!=0)
   continue;

  mg_printf(conn,"<hr/>");
  mg_printf(conn,"<form name=\"%s_form\" method=\"post\">%s: <input type=\"text\" readonly=\"readonly\" value=\"%s\" name=\"username\">",name,lang(ri,"username").c_str(),name);
  mg_printf(conn,"%s: <input type=\"password\" name=\"password\"></input>",lang(ri,"password").c_str());
  mg_printf(conn,"<input type=\"submit\" value=\"%s\"></input>",lang(ri,"Change password").c_str());
  if (ri->permissions == -1)
   mg_printf(conn,"<input name=\"remove\" type=\"submit\" value=\"%s\"></input></form>",lang(ri,"Remove user").c_str());
  else
   mg_printf(conn,"<br/>");
  mg_printf(conn,"<form name=\"%s_form\" method=\"post\"><input type=\"hidden\" name=\"username\" value=\"%s\">",name,name);
  mg_printf(conn,"<input type=\"checkbox\" name=\"permission0\" %s %s>%s</input>",permissions == -1? "checked=\"yes\"":"",ri->permissions == -1?"":"disabled=false",lang(ri,"ALL").c_str());
  mg_printf(conn,"<input type=\"checkbox\" name=\"permission1\" %s %s>%s</input>",(permissions != -1) && (permissions & 1)? "checked=\"yes\"":"",ri->permissions == -1?"":"disabled=false",lang(ri,"Screenshot").c_str());
  mg_printf(conn,"<input type=\"checkbox\" name=\"permission2\" %s %s>%s</input>",(permissions != -1) && (permissions & 2)? "checked=\"yes\"":"",ri->permissions == -1?"":"disabled=false",lang(ri,"Location").c_str());
  mg_printf(conn,"<input type=\"checkbox\" name=\"permission3\" %s %s>%s</input>",(permissions != -1) && (permissions & 4)? "checked=\"yes\"":"",ri->permissions == -1?"":"disabled=false",lang(ri,"Chat").c_str());
  mg_printf(conn,"<input type=\"checkbox\" name=\"permission4\" %s %s>%s</input>",(permissions != -1) && (permissions & 8)? "checked=\"yes\"":"",ri->permissions == -1?"":"disabled=false",lang(ri,"Read /sdcard/public/").c_str());
  mg_printf(conn,"<input type=\"checkbox\" name=\"permission5\" %s %s>%s</input>",(permissions != -1) && (permissions & 16)? "checked=\"yes\"":"",ri->permissions == -1?"":"disabled=false",lang(ri,"Contacts, Sms, Calls").c_str());
  mg_printf(conn,"<input type=\"checkbox\" name=\"permission6\" %s %s>%s</input>",(permissions != -1) && (permissions & 32)? "checked=\"yes\"":"",ri->permissions == -1?"":"disabled=false",lang(ri,"Read files").c_str());
  mg_printf(conn,"<input type=\"checkbox\" name=\"permission7\" %s %s>%s</input>",(permissions != -1) && (permissions & 64)? "checked=\"yes\"":"",ri->permissions == -1?"":"disabled=false",lang(ri,"Sdcard").c_str());
  if (ri->permissions == -1)
   mg_printf(conn,"<input type=\"submit\" value=\"%s\"></input>",lang(ri,"Save permissions").c_str());
  mg_printf(conn,"<br/>");


  mg_printf(conn,"</form>\n");
 }
 mg_printf(conn,"<hr/>");
 if (ri->permissions == -1)
 {
  mg_printf(conn,"<form name=\"newuser\" method=\"post\">%s:<input type=\"text\" name=\"username\">",lang(ri,"New user").c_str());
  mg_printf(conn,"%s: <input type=\"password\" name=\"password\"></input>",lang(ri,"password").c_str());
  mg_printf(conn,"<input type=\"submit\" value=\"%s\"></input></form>\n",lang(ri,"Create").c_str());
 }
 fclose(fp);
 mg_printf(conn,"<h3>%s</h3>",lang(ri,"Details about permissions").c_str());
 mg_printf(conn,"<h4 class=\"list\">%s</h4>",lang(ri,"ALL").c_str());
 mg_printf(conn,"%s",lang(ri,"All other permissions. Additionally, user can inject keys, inject touch events, run commands, run commands in terminal, view log. These functions are not accessible by any of the other permissions.").c_str());
 mg_printf(conn,"<h4 class=\"list\">%s</h4>",lang(ri,"Screenshot").c_str());
 mg_printf(conn,"%s",lang(ri,"View screenshot of the phone.").c_str());
 mg_printf(conn,"<h4 class=\"list\">%s</h4>",lang(ri,"Location").c_str());
 mg_printf(conn,"%s",lang(ri,"View GPS and network location of the phone. The GPS is only available if it is enabled in your phone's Settings. Network location depends on your carrier.").c_str());
 mg_printf(conn,"<h4 class=\"list\">%s</h4>",lang(ri,"Chat").c_str());
 mg_printf(conn,"%s",lang(ri,"Read and write messages. Every message is in the same list, and everyone can empty that list.").c_str());
 mg_printf(conn,"<h4 class=\"list\">%s</h4>",lang(ri,"Read /sdcard/public/").c_str());
 mg_printf(conn,"%s",lang(ri,"If this permission is set and the permission \"Read files\" is not, then under the menu \"Files\" only the content of /sdcard/public will be available for read. Please create that directory if you are about to use this function.").c_str());
 mg_printf(conn,"<h4 class=\"list\">%s</h4>",lang(ri,"Contacts, Sms, Calls").c_str());
 mg_printf(conn,"%s",lang(ri,"Read personal data such as contacts, messages and call list.").c_str());
 mg_printf(conn,"<h4 class=\"list\">%s</h4>",lang(ri,"Read files").c_str());
 mg_printf(conn,"%s",lang(ri,"Read all files on the phone. Be careful, the contacts, messages, call list and the passwords of Webkey are stored in files!").c_str());
 mg_printf(conn,"<h4 class=\"list\">%s</h4>",lang(ri,"Sdcard").c_str());
 mg_printf(conn,"%s",lang(ri,"Read and modify the content of the sdcard.").c_str());

 if (ri->permissions == -1)
 {
  mg_printf(conn,"<h3>%s</h3>",lang(ri,"Log (activities is logged once in every 30 minutes)").c_str());
  FILE *f = fopen(logfile.c_str(),"r");
  if(f)
  {
   char buff[256];
   while (fgets(buff, sizeof(buff)-1, f) != __null)
   {
    mg_printf(conn,"%s<br/>",buff);
   }
   fclose(f);
  }
  mg_printf(conn,"<form name=\"dellog_form\" method=\"post\"><input type=\"hidden\" name=\"dellog\" value=\"dellog\"><input type=\"submit\" value=\"%s\"></input></form>",lang(ri,"Clear log").c_str());
 }
 mg_printf(conn,"</body></html>");
 if (post_data)
  delete[] post_data;
}
static void
screenshot(struct mg_connection *conn,
                const struct mg_request_info *ri, void *data)
{
 if (ri->permissions != -1 && (ri->permissions&1)==0)
  return;
 lock_wakelock();
 access_log(ri,"view screenshot");
 int orient = 0;
 bool png = false;
 if (ri->uri[12] == 'p')
  png = true;
 if (ri->uri[16] == 'h')
  orient = 1;
 int lowres = 0;
 if (ri->uri[17] == 'l')
  lowres = 1;
 firstfb = false;
 if (ri->uri[18] == 'f')
  firstfb = true;
 bool flip = false;
 if (ri->uri[19] == 'f')
  flip = true;
 bool wait = false;
 if (ri->uri[20] == 'w')
  wait = true;
 bool asfile = false;
 if (ri->uri[21] == 'f')
 {
  asfile = true;
 }
 lastorient = orient;
 lastflip = flip;




 if (wait && !picchanged)
 {
  pthread_mutex_lock(&diffmutex);
  diffcondWaitCounter++;
  int myCounter = diffcondWaitCounter;
  pthread_cond_broadcast(&diffstartcond);
  if (exit_flag)
         return;
  do{
   pthread_cond_wait(&diffcond,&diffmutex);
   if (exit_flag)
    return;
  }
  while ((myCounter%3)!=(diffcondDiffCounter%3));
  pthread_mutex_unlock(&diffmutex);
 }
 if (!asfile)
 {
  struct timeval tv;
  gettimeofday(&tv,0);
  time_t now = tv.tv_sec;
  if (png == true)
   mg_printf(conn,"HTTP/1.1 200 OK\r\nConnection: close\r\nContent-Type: image/png\r\nCache-Control: max-age=300\r\nSet-Cookie: time=%lu%lu\r\n\r\n",tv.tv_sec,tv.tv_usec);
  else
   mg_printf(conn,"HTTP/1.1 200 OK\r\nConnection: close\r\nContent-Type: image/jpeg\r\nCache-Control: max-age=300\r\nSet-Cookie: time=%lu%lu\r\n\r\n",tv.tv_sec,tv.tv_usec);
 }

 if (!pict)
  init_fb();
 FILE* f;
 std::string path = dir+"tmp";
 if (!recording)
 {
# 6047 "webkey-2.09/service/webkey.cpp"
  pthread_mutex_lock(&pngmutex);
  update_image(orient,lowres,png,flip,!wait);
  pthread_mutex_unlock(&pngmutex);
 }
 else
 {
  char num[32];
  path = "/sdcard/webkey_TEMP/screenshot_";
  pthread_mutex_lock(&pngmutex);
  int fin = recordingnumfinished;
  pthread_mutex_unlock(&pngmutex);
  itoa(num,fin);
  int l = strlen(num);
  if (l<2)
   path = path+"0";
  if (l<3)
   path = path+"0";
  path = path + num;
  if (fin < 0)
   path = dir+"tmp";
 }
 if (png)
 {
  path += ".png";
  f = fopen(path.c_str(),"rb");
 }
 else
 {
  path += ".jpg";
  f = fopen(path.c_str(),"rb");
 }
 if (!f)
 {
  return;
 }
 fseek (f , 0 , 2);
 int lSize = ftell (f);
 rewind (f);
 char* filebuffer = new char[lSize+1];
 if(!filebuffer)
 {
  error("not enough memory for loading tmp.png\n");
 }
 fread(filebuffer,1,lSize,f);
 filebuffer[lSize] = 0;

 if (asfile)
 {
  if (png)
   send_ok(conn,"Content-Type: image/png; charset=UTF-8\r\nContent-Disposition: attachment;filename=screenshot.png",lSize);
  else
   send_ok(conn,"Content-Type: image/jpeg; charset=UTF-8\r\nContent-Disposition: attachment;filename=screenshot.jpg",lSize);
 }
 mg_write(conn,filebuffer,lSize);
 fclose(f);
 delete[] filebuffer;

}


static void
stop(struct mg_connection *conn,
                const struct mg_request_info *ri, void *data)
{
 ;
 send_ok(conn);
 if (ri->remote_ip==2130706433)
 {

  ;
  exit_flag = 2;
  mg_printf(conn,"Goodbye.");
  access_log(ri,"stop service");
 }
}
static void
run(struct mg_connection *conn,
                const struct mg_request_info *ri, void *data)
{
 if (ri->permissions != -1)
  return;
 lock_wakelock();
 access_log(ri,"run command");
 char* post_data;
 int post_data_len;
 read_post_data(conn,ri,&post_data,&post_data_len);
 send_ok(conn);
 int n = 4;
 std::string call = "";
 if (post_data_len)
 {
  call = post_data;
 }
 else
 if (ri->uri[n] == '_')
  while (ri->uri[++n])
  {
   int k = getnum(ri->uri+n);
   while(ri->uri[n] && ri->uri[n] != '_') n++;
   if (k<=0 || 255<k)
    continue;
   call += (char)k;
  }
 if (post_data)
  delete[] post_data;
 call += " 2>&1";
 FILE* in;





 struct pid volatile cur;
 int pdes[2];
 pid_t pid;

 if (pipe(pdes) < 0) {
  return;
 }

 switch (pid = fork()) {
 case -1:
  (void)close(pdes[0]);
  (void)close(pdes[1]);
  return;

 case 0:
     {
  struct pid *pcur;
  int tpdes1 = pdes[1];

  (void) close(pdes[0]);




  if (tpdes1 != 1) {
   (void)dup2(tpdes1, 1);
   (void)close(tpdes1);
   tpdes1 = 1;
  }
  execl("/system/bin/sh", "sh", "-c", call.c_str(), (char *)__null);
  _exit(127);

     }
 }

 (void)close(pdes[1]);




 char buff[256];
 bool empty = true;



 while (1)
 {
  fd_set set;
  struct timeval timeout;
  (memset (&set, 0, sizeof (*(fd_set *)(&set))));
  (((fd_set *)(&set))->fds_bits[(pdes[0]) >> 5] |= (1<<((pdes[0]) & 31)));
  timeout.tv_sec = 10;
  timeout.tv_usec = 0;
  int s = select(1024, &set, __null, __null, &timeout);
  if (s>0)
  {
   int i = read(pdes[0],buff,255);
   if (i == 0 || exit_flag)
   {
    kill(pid,9);
    break;
   }
   buff[i] = 0;
   mg_printf(conn,"%s",buff);
   empty = false;
  }
# 6238 "webkey-2.09/service/webkey.cpp"
 }
 if (empty)
  mg_printf(conn,"</pre>empty<pre>");
}
static void
sendsms(struct mg_connection *conn,
                const struct mg_request_info *ri, void *data)
{
 if (ri->permissions != -1 && (ri->permissions&16)==0)
  return;
 lock_wakelock();
 access_log(ri,"send sms");
 char* post_data;
 int post_data_len;
 read_post_data(conn,ri,&post_data,&post_data_len);

 send_ok(conn);
 int n = 8;
 int i = 0;
 while (i<post_data_len && post_data[i] != 13 && post_data[i] != 10)
 {
  if (post_data[i] == ';')
  {
   post_data[i] = '\n';
   break;
  }
  i++;
 }
 FILE* out;
 out = fo("smsqueue","w");
 fwrite(post_data,1,post_data_len,out);
 fclose(out);
 syst("/system/bin/am broadcast -a \"webkey.intent.action.SMS.SEND\" -n \"com.webkey/.SMS\"&");
 if (post_data)
  delete[] post_data;
}
static void
sendbroadcast(struct mg_connection *conn,
                const struct mg_request_info *ri, void *data)
{
 send_ok(conn);
 mg_printf(conn,"OK");
 if (ri->remote_ip==2130706433 && strcmp(ri->remote_user,"JAVA_CLIENT") == 0)
 {
  lock_wakelock();
  syst("/system/bin/am broadcast -a \"android.intent.action.BOOT_COMPLETED\" -n com.android.mms/.transaction.SmsReceiver&");
 }
}
static void
gpsset(struct mg_connection *conn,
                const struct mg_request_info *ri, void *data)
{
 send_ok(conn);
 if (ri->remote_ip==2130706433 && strcmp(ri->remote_user,"JAVA_CLIENT") == 0)
 {
  lock_wakelock();
  int n = strlen(ri->uri)-7;
  int i;

  if (n<512)
   for (i=n;i>=0;i--)
    position_value[i] = ri->uri[i+7];
  position_id++;
 }
}
static void
gpsget(struct mg_connection *conn,
                const struct mg_request_info *ri, void *data)
{
 if (ri->permissions != -1 && (ri->permissions&2)==0)
  return;
 lock_wakelock();
 access_log(ri,"get gps position");
 send_ok(conn);
 FILE* in;
 int last = ++position_id;
 syst("/system/bin/am broadcast -a \"webkey.intent.action.GPS.START\" -n \"com.webkey/.GPS\"&");
 gps_active = true;
 struct timeval tv;
 gettimeofday(&tv,0);
 last_gps_time = tv.tv_sec;
 int i;
 for (i=0; i<25;i++)
 {
  if (last != position_id)
  {
   mg_printf(conn,"%s",position_value);
   break;
  }
  struct timespec tim;
  tim.tv_sec = 0;
  tim.tv_nsec = 200000000;
  nanosleep(&tim,0);
 }
}
# 6362 "webkey-2.09/service/webkey.cpp"
static void load_mimetypes()
{
 std::string cmd = dir + "sqlite3 /data/data/com.android.providers.contacts/databases/contacts2.db \'select * from mimetypes\'";
 pthread_mutex_lock(&popenmutex);
 fprintf(pipeout,"%s\n",cmd.c_str());
 fflush(pipeout);
 char buff[4096];
 int pos[7];
 int i;
 int j;
 bool first = true;
 while (fgets(buff, 4096 -1, pipein) != __null)
 {
  if (strcmp(buff,"!!!END_OF_POPEN!!!\n")==0)
   break;
  i = getnum(buff);
  if (i>0 && i < 32)
  {
   j=0;
   while(buff[j] && buff[j]!='/' && j<4096 -1)
    j++;
   j++;
   int n = strlen(buff);
   if (buff[n-1]=='\n')
    buff[n-1] = 0;
   if (buff[j])
   {
    mimetypes[i] = buff+j;

   }
  }
 }

 fflush(pipeout);
 pthread_mutex_unlock(&popenmutex);
}
static void
smsxml(struct mg_connection *conn,
                const struct mg_request_info *ri, void *data)
{
 if (ri->permissions != -1 && (ri->permissions&16)==0)
  return;
 lock_wakelock();
 access_log(ri,"read sms messages");
 send_ok(conn,"Content-Type: text/xml; charset=UTF-8");

 std::string cmd = dir + "sqlite3 /data/data/com.android.providers.telephony/databases/mmssms.db 'select \"_id\",\"address\",\"person\",\"date\",\"read\",\"status\",\"type\",\"body\" from sms order by \"date\"'";

 pthread_mutex_lock(&popenmutex);
 fprintf(pipeout,"%s\n",cmd.c_str());
 fflush(pipeout);
 char buff[4096];
 char conv[4096];

 int pos[7];
 int i;
 int j;
 mg_printf(conn,"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<messages>\n");
 bool first = true;
 while (fgets(buff, 4096 -1, pipein) != __null)
 {
  if (strcmp(buff,"!!!END_OF_POPEN!!!\n")==0)
   break;
  i = 0; j = 0;
  while(buff[i])
   if (buff[i++] == '|')
    j++;
  if (j<7)
  {
   mg_printf(conn,"%s",convertxml(conv, buff));
   continue;
  }
  i = 0;
  j = 0;
  while(buff[i] && j < 7 && i < 4096 -1)
  {
   if (buff[i] == '|')
   {
    buff[i] = 0;
    pos[j++] = i+1;
   }
   i++;
  }
  if (!first)
   mg_printf(conn,"</body></sms>\n");
  first = false;
  mg_printf(conn,"<sms><id>%s</id><number>%s</number>",buff,convertxml(conv, buff+pos[0]));
  if (buff[pos[1]])
   mg_printf(conn,"<person>%s</person>",convertxml(conv, buff+pos[1]));
  mg_printf(conn,"<date>%s</date><read>%s</read><status>%s</status><type>%s</type><body>%s",buff+pos[2],buff+pos[3],buff+pos[4],buff+pos[5],convertxml(conv, buff+pos[6]));
 }
 if (!first)
  mg_printf(conn,"</body></sms>\n");
 mg_printf(conn,"</messages>");
 fflush(pipeout);
 pthread_mutex_unlock(&popenmutex);






}
static void
contactsxml(struct mg_connection *conn,
                const struct mg_request_info *ri, void *data)
{
 if (ri->permissions != -1 && (ri->permissions&16)==0)
  return;
 lock_wakelock();
 access_log(ri,"read contact data");
 send_ok(conn,"Content-Type: text/xml; charset=UTF-8");

 std::string cmd = dir + "sqlite3 /data/data/com.android.providers.contacts/databases/contacts2.db \'select \"raw_contact_id\",\"mimetype_id\",\"data1\" from data where \"data1\" <> \"\" order by \"raw_contact_id\"\'";

 char buff[4096];
 char last[4096];
 char conv[4096];
 last[0] = 0;
 int pos[3];
 int i;
 int j;
 mg_printf(conn,"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<people>\n");
 bool first = true;
 for (i = 0; i < 32; i++)
  if (mimetypes[i].length())
   break;
 if (i==32)
  load_mimetypes();
 int lastmime = -1;
 pthread_mutex_lock(&popenmutex);
 fprintf(pipeout,"%s\n",cmd.c_str());
 fflush(pipeout);
 while (fgets(buff, 4096 -1, pipein) != __null)
 {
  if (strcmp(buff,"!!!END_OF_POPEN!!!\n")==0)
   break;
  i = 0;
  j = 0;
  while(buff[i] && buff[i] != '\n' && j < 2 && i < 255)
  {
   if (buff[i] == '|')
   {
    buff[i] = 0;
    pos[j++] = i+1;
   }
   i++;
  }
  if (j<2)
  {
   if (lastmime != -1)
    mg_printf(conn,"\n%s",convertxml(conv, buff));
   continue;
  }
  if (lastmime != -1)
   mg_printf(conn,"</%s>",mimetypes[lastmime].c_str());
  while(buff[i]) i++;
  if (i)
   buff[i-1] = 0;
  if (strcmp(buff,last))
  {
   strcpy(last,buff);
   if (first)
    mg_printf(conn,"<contact><id>%s</id>",buff);
   else
    mg_printf(conn,"</contact>\n<contact><id>%s</id>",buff);
   first = false;
  }
  int n = getnum(buff+pos[0]);
  lastmime = n;
  if (n > 0 && n < 32 && mimetypes[n].length() && buff[pos[1]])
  {
   mg_printf(conn,"<%s>%s",mimetypes[n].c_str(),convertxml(conv, buff+pos[1]));
  }
 }
 if (lastmime != -1)
  mg_printf(conn,"</%s>",mimetypes[lastmime].c_str());
 if (first)
  mg_printf(conn,"<contact><name>Empty list. Your phone might not be supported. On some newer and older phones the contact list is not in /data/data/com.android.providers.contacts/databases/contacts2.db</name><phone_v2>_</phone_v2></contact></people>");
 else
  mg_printf(conn,"</contact></people>");

 fflush(pipeout);
 pthread_mutex_unlock(&popenmutex);






}
static void
callsxml(struct mg_connection *conn,
                const struct mg_request_info *ri, void *data)
{
 if (ri->permissions != -1 && (ri->permissions&16)==0)
  return;
 lock_wakelock();
 access_log(ri,"read call log");
 send_ok(conn,"Content-Type: text/xml; charset=UTF-8");

 std::string cmd = dir + "sqlite3 /data/data/com.android.providers.contacts/databases/contacts2.db \'select \"_id\",\"number\",\"date\",\"duration\",\"type\",\"new\",\"name\",\"numbertype\" from calls order by \"_id\"\'";
 pthread_mutex_lock(&popenmutex);
 fprintf(pipeout,"%s\n",cmd.c_str());
 fflush(pipeout);


 char buff[4096];
 char conv[4096];
 int pos[7];
 int i;
 int j;
 mg_printf(conn,"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<calls>\n");
 bool first = true;
 while (fgets(buff, 255, pipein) != __null)
 {
  if (strcmp(buff,"!!!END_OF_POPEN!!!\n")==0)
   break;
  i = 0;
  j = 0;
  while(buff[i] && buff[i] != '\n' && j < 7 && i < 255)
  {
   if (buff[i] == '|')
   {
    buff[i] = 0;
    pos[j++] = i+1;
   }
   i++;
  }
  if (j<7)
   continue;
  while(buff[i]) i++;
  if (i)
   buff[i-1] = 0;
  if (i-1 && buff[i-2] == 13)
   buff[i-2] = 0;
  mg_printf(conn,"<call><id>%s</id><number>%s</number><date>%s</date><duration>%s</duration><type>%s</type><new>%s</new><name>%s</name><numbertype>%s</numbertype></call>\n",buff,buff+pos[0],buff+pos[1],buff+pos[2],buff+pos[3],buff+pos[4],convertxml(conv,buff+pos[5]),buff+pos[6]);
 }
 mg_printf(conn,"</calls>");
 pthread_mutex_unlock(&popenmutex);
}
static void
intent(struct mg_connection *conn,
                const struct mg_request_info *ri, void *data)
{
 if (ri->permissions != -1)
  return;
 lock_wakelock();
 access_log(ri,"start intent");
 send_ok(conn);
 int n = 7;
 std::string call = "/system/bin/am start ";
        while (ri->uri[++n])
 {
  int k = getnum(ri->uri+n);
  while(ri->uri[n] && ri->uri[n] != '_') n++;
  if (k<=0 || 255<k)
   continue;
  char ch = (char)k;
  if ((ch >= 'a' && ch <= 'z') ||
   (ch >= 'A' && ch <= 'Z') || ch == ' ')
   call += ch;
  else
  {
   call += '\\';
   call += ch;
  }
 }



 syst(call.c_str());
}
static void
exports(struct mg_connection *conn,
                const struct mg_request_info *ri, void *data)
{
 if (ri->permissions != -1 && (ri->permissions&16)==0)
  return;
 lock_wakelock();
 access_log(ri,"export data");
 char buff[4096];
 char last[4096];
 char conv[4096];
 int cols;
 std::string cmd;
 std::string header;
 int datepos=-1;
 int type;
 bool winnewline = false;
 if (ri->uri[8] == '0')
 {
  cmd = dir + "sqlite3 /data/data/com.android.providers.contacts/databases/contacts2.db \'select \"raw_contact_id\",\"mimetype_id\",\"data1\" from data where \"data1\" <> \"\" order by \"raw_contact_id\"\'";
  cols = 3-1;
  header = "contacts";
  type = 0;
 }
 if (ri->uri[8] == '1')
 {
  cmd = dir + "sqlite3 /data/data/com.android.providers.telephony/databases/mmssms.db 'select \"_id\",\"address\",\"person\",\"date\",\"read\",\"status\",\"type\",\"body\" from sms order by \"date\"'";
  cols = 8-1;
  header = "messages";
  datepos = 3;
  type = 1;
 }
 if (ri->uri[8] == '2')
 {
  cmd = dir + "sqlite3 /data/data/com.android.providers.contacts/databases/contacts2.db \'select \"_id\",\"number\",\"date\",\"duration\",\"type\",\"new\",\"name\",\"numbertype\" from calls order by \"_id\"\'";
  cols = 8-1;
  header = "call_list";
  datepos = 2;
  type = 2;
 }
 int format = ri->uri[9]-48;
 int dateformat = ri->uri[10]-48;
 int datesep = ri->uri[11]-48;
 int datein = ri->uri[12]-48;
 if (ri->uri[13] == '1')
  winnewline = true;
 int datetimezone = (ri->uri[14]-48)*10+ri->uri[15]-48-10-12;
 if (format < 0 || format > 2 || dateformat < 0 || dateformat > 2 || datesep < 0 || datesep > 2 || datein < 0 || datein > 1 || datetimezone < -12 || datetimezone > 12)
  return;
 switch(format)
 {
  case 0: header = std::string()+"Content-Type: text/plain; charset=UTF-8\r\nContent-Disposition: attachment;filename="+header+".txt"; break;
  case 1: header = std::string()+"Content-Type: text/csv; charset=UTF-8\r\nContent-Disposition: attachment;filename="+header+".csv"; break;
  case 2: header = std::string()+"Content-Type: text/xml; charset=UTF-8\r\nContent-Disposition: attachment;filename="+header+".xml"; break;
 }
 send_ok(conn,header.c_str());



 int pos[16];
 int i;
 int j;
 int n;
 std::string mimedata[32];
 int maxmime = 0;
 switch(type)
 {
  case 0:
   for (i = 0; i < 32; i++)
    if (mimetypes[i].length())
     break;
   if (i==32)
    load_mimetypes();
   for (maxmime = 31; maxmime >= 0; maxmime--)
    if (mimetypes[maxmime].length())
     break;
   maxmime++;

   switch(format)
   {
    case 0:
     mg_printf(conn,"Contacts:");
     break;
    case 1:
     mg_printf(conn,"id;");
     for (i = 1; i < maxmime; i++)
      if (mimetypes[i].length())
       mg_printf(conn,"%s;",mimetypes[i].c_str());
     if (winnewline)
      mg_printf(conn,"\r\n");
     else
      mg_printf(conn,"\n");
     break;
    case 2:
     if (winnewline)
      mg_printf(conn,"<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<people>\r\n");
     else
      mg_printf(conn,"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<people>\n");
     break;
   }
   break;
  case 1:
   switch(format)
   {
    case 0:
     mg_printf(conn,"Messages:");
     break;
    case 1:
     mg_printf(conn,"id;address;person;date;read;status;type;body");
     break;
    case 2:
     if (winnewline)
      mg_printf(conn,"<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<messages>\r\n");
     else
      mg_printf(conn,"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<messages>\n");
     break;
   }
   break;
  case 2:
   switch(format)
   {
    case 0:
     if (winnewline)
      mg_printf(conn,"Calls:\r\n\r\n");
     else
      mg_printf(conn,"Calls:\n\n");
     break;
    case 1:
     mg_printf(conn,"id;number;date;duration;type;new;name;numbertype");
     break;
    case 2:
     if (winnewline)
      mg_printf(conn,"<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<calls>\r\n");
     else
      mg_printf(conn,"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<calls>\n");
     break;
   }
   break;
 }
 bool first = true;
 int lastmime = -1;
 pthread_mutex_lock(&popenmutex);
 fprintf(pipeout,"%s\n",cmd.c_str());
 fflush(pipeout);
 while (fgets(buff, 4096 -1, pipein) != __null)
 {
  if (strcmp(buff,"!!!END_OF_POPEN!!!\n")==0)
  {
   break;
  }
  i = 0;
  j = 0;
  while(buff[i] && buff[i] != '\n' && j < cols && i < 4096)
  {
   if (buff[i] == '|')
   {
    buff[i] = 0;
    pos[j++] = i+1;
   }
   i++;
  }
  while(buff[i]) i++;
  if (i)
   buff[i-1] = 0;
  if (j<cols)
  {
   switch(format)
   {
    case 0:
     if (winnewline)
      mg_printf(conn,"\r\n%s",buff);
     else
      mg_printf(conn,"\n%s",buff);
     break;
    case 1:
     if (type == 0)
     {
      if (lastmime != -1)
       mimedata[lastmime] = mimedata[lastmime] + removesemicolon(conv,buff);
     }
     else
      mg_printf(conn," %s",removesemicolon(conv,buff));
     break;
    case 2:
     if (winnewline)
      mg_printf(conn,"\r\n%s",convertxml(conv,buff));
     else
      mg_printf(conn,"\n%s",convertxml(conv,buff));
     break;
   }
   continue;
  }
  bool newid = false;
  switch(type)
  {
   case 0:
    if (strcmp(buff,last))
    {
     if (!first && format==1)
     {
      mg_printf(conn,"%s;",last);
      for (i = 1; i < maxmime; i++)
       mg_printf(conn,"%s;",removesemicolon(conv,mimedata[i].c_str()));
      if (winnewline)
       mg_printf(conn,"\r\n");
      else
       mg_printf(conn,"\n");
     }
     strcpy(last,buff);
     newid = true;
     for (i = 0; i < 32; i++)
      mimedata[i] = "";
    }
    switch(format)
    {
     case 0:
      if (newid)
      {
       if (winnewline)
        mg_printf(conn,"\r\n\r\n%s\r\n",buff);
       else
        mg_printf(conn,"\n\n%s\n",buff);
      }
      n = getnum(buff+pos[0]);
      if (n>0 && n < 32)
      {
       if (winnewline)
        mg_printf(conn,"%s: %s\r\n",mimetypes[n].c_str(),buff+pos[1]);
       else
        mg_printf(conn,"%s: %s\n",mimetypes[n].c_str(),buff+pos[1]);
       lastmime = n;
      }
      break;
     case 1:
      n = getnum(buff+pos[0]);
      if (n>0 && n < 32)
      {
       if (mimedata[n].length())
        mimedata[n] = mimedata[n] + ", " + (buff+pos[1]);
       else
        mimedata[n] = buff+pos[1];
      }
      break;
     case 2:
      if (lastmime != -1)
       mg_printf(conn,"</%s>",mimetypes[lastmime].c_str());
      if (first)
       mg_printf(conn,"<contact><id>%s</id>",buff);
      else if(newid)
      {
       if (winnewline)
        mg_printf(conn,"</contact>\r\n<contact><id>%s</id>",buff);
       else
        mg_printf(conn,"</contact>\n<contact><id>%s</id>",buff);
      }
      int n = getnum(buff+pos[0]);
      lastmime = n;
      if (n > 0 && n < 32 && mimetypes[n].length() && buff[pos[1]])
      {
       mg_printf(conn,"<%s>%s",mimetypes[n].c_str(),convertxml(conv, buff+pos[1]));
      }
      break;
    }
    break;
   case 1:
    if (pos[3]>pos[2]+4)
     buff[pos[3]-4]=0;
    switch(format)
    {
     case 0:
      if (winnewline)
       mg_printf(conn,"\r\n\r\n");
      else
       mg_printf(conn,"\n\n");
      mg_printf(conn,"%s. %s (%s), ",buff,buff+pos[1],buff+pos[0]);
      if (buff[pos[5]] == '1')
       mg_printf(conn,"in, ");
      else
      if (buff[pos[5]] == '2')
       mg_printf(conn,"out, ");
      mg_printf(conn,humandate(conv,getnum(buff+pos[2]),dateformat,datesep,datein,datetimezone));
      if (winnewline)
       mg_printf(conn,":\r\n");
      else
       mg_printf(conn,":\n");
      mg_printf(conn,"%s",buff+pos[6]);
      break;
     case 1:
      if (winnewline)
       mg_printf(conn,"\r\n");
      else
       mg_printf(conn,"\n");
      mg_printf(conn,"%s;%s;%s;%s;%s;%s;%s",buff,buff+pos[0],buff+pos[1],humandate(conv,getnum(buff+pos[2]),dateformat,datesep,datein,datetimezone),buff+pos[3],buff+pos[4],buff+pos[5]);
      mg_printf(conn,";%s",removesemicolon(conv,buff+pos[6]));
      break;
     case 2:
      if (!first)
      {
       if (winnewline)
        mg_printf(conn,"</body></sms>\r\n");
       else
        mg_printf(conn,"</body></sms>\n");
      }
      mg_printf(conn,"<sms><id>%s</id><address>%s</address><person>%s</person><date>%s</date><read>%s</read><status>%s</status><type>%s</type><body>%s",buff,buff+pos[0],buff+pos[1],buff+pos[2],buff+pos[3],buff+pos[4],buff+pos[5],convertxml(conv,buff+pos[6]));
      break;
    }
    break;
   case 2:
    if (pos[2]>pos[1]+4)
     buff[pos[2]-4]=0;
    switch(format)
    {
     case 0:
      if (winnewline)
       mg_printf(conn,"\r\n\r\n");
      else
       mg_printf(conn,"\n\n");
      mg_printf(conn,"%s. %s (%s), ",buff,buff+pos[5],buff+pos[0]);
      if (buff[pos[3]] == '1')
       mg_printf(conn,"in, ");
      else
      if (buff[pos[3]] == '2')
       mg_printf(conn,"out, ");
      else
      if (buff[pos[3]] == '3')
       mg_printf(conn,"rejected, ");
      mg_printf(conn,humandate(conv,getnum(buff+pos[1]),dateformat,datesep,datein,datetimezone));
      mg_printf(conn,", ");
      mg_printf(conn,humandur(conv,getnum(buff+pos[2])));
      if (winnewline)
       mg_printf(conn,"\r\n");
      else
       mg_printf(conn,"\n");
      break;
     case 1:
      if (winnewline)
       mg_printf(conn,"\r\n");
      else
       mg_printf(conn,"\n");
      mg_printf(conn,"%s;%s;%s;%s;%s;%s;%s;%s",buff,buff+pos[0],humandate(conv,getnum(buff+pos[1]),dateformat,datesep,datein,datetimezone),buff+pos[2],buff+pos[3],buff+pos[4],buff+pos[5],buff+pos[6]);
      break;
     case 2:
      if (winnewline)
       mg_printf(conn,"<call><id>%s</id><number>%s</number><date>%s</date><duration>%s</duration><type>%s</type><new>%s</new><name>%s</name><numbertype>%s</numbertype></call>\r\n",buff,buff+pos[0],buff+pos[1],buff+pos[2],buff+pos[3],buff+pos[4],convertxml(conv,buff+pos[5]),buff+pos[6]);
      else
       mg_printf(conn,"<call><id>%s</id><number>%s</number><date>%s</date><duration>%s</duration><type>%s</type><new>%s</new><name>%s</name><numbertype>%s</numbertype></call>\n",buff,buff+pos[0],buff+pos[1],buff+pos[2],buff+pos[3],buff+pos[4],convertxml(conv,buff+pos[5]),buff+pos[6]);
      break;
    }
    break;
  }






  first = false;
 }







 pthread_mutex_unlock(&popenmutex);

 switch(type)
 {
  case 0:
   switch(format)
   {
    case 0:
     break;
    case 1:
     if (!first)
     {
      mg_printf(conn,"%s;",last);
      for (i = 0; i < maxmime; i++)
       mg_printf(conn,"%s;",mimedata[i].c_str());
      if (winnewline)
       mg_printf(conn,"\r\n");
      else
       mg_printf(conn,"\n");
     }
     break;
    case 2:
     if (lastmime != -1)
      mg_printf(conn,"</%s></contact>",mimetypes[lastmime].c_str());
     mg_printf(conn,"</people>");
     break;
   }
   break;
  case 1:
   switch(format)
   {
    case 0:
     break;
    case 1:
     break;
    case 2:
     if (!first)
     {
      if (winnewline)
       mg_printf(conn,"</body></sms>\r\n");
      else
       mg_printf(conn,"</body></sms>\n");
     }
     mg_printf(conn,"</messages>");
     break;
   }
   break;
  case 2:
   switch(format)
   {
    case 0:
     break;
    case 1:
     break;
    case 2:
     mg_printf(conn,"</calls>");
     break;
   }
   break;
 }







}
static void
password(struct mg_connection *conn,
                const struct mg_request_info *ri, void *data)
{
 send_ok(conn);




}

static std::string update_dyndns(__u32 ip)
{
 if (!ip)
  return "no IP address found";
 int s;
 if ((s = socket(2, 1, 0)) < 0) {

  return "error opening socket";
 }
 struct sockaddr_in addr;
 struct hostent *hp;
 if ((hp = gethostbyname("members.dyndns.org")) == __null)
 {
  close(s);
  return "unable to resolve members.dyndns.org";
 }
 bcopy ( hp->h_addr_list[0], &(addr.sin_addr.s_addr), hp->h_length);
 addr.sin_port = __extension__({ __uint16_t __swap16gen_x = (80); (__uint16_t)((__swap16gen_x & 0xff) << 8 | (__swap16gen_x & 0xff00) >> 8); });
 addr.sin_family = 2;
 if (connect(s, (struct sockaddr *)&addr, sizeof(struct sockaddr_in)) < 0)
 {
  close(s);
  return "unable to connect members.dyndns.org";
 }
 std::string data = "GET /nic/update?hostname=";
 data += dyndns_host+"&myip=";
 in_addr r;
 r.s_addr = ip;
 data += inet_ntoa(r);
 data += "&wildcard=NOCHG&mx=NOCHG&backmx=NOCHG HTTP/1.0\r\nHost: members.dyndns.org\r\nAuthorization: Basic ";
 data += dyndns_base64;
 data += "\r\nUser-Agent: Webkey\r\n\r\n";
 if (send(s, data.c_str(), data.size(),0x4000) < 0)
 {
  close(s);
  return "unable to send data to members.dyndns.org";
 }
 char buf[256];
 bzero(buf, sizeof(buf));
 if (read(s, buf, sizeof(buf)) < 0)
 {
  close(s);
  return "unable to receive data from members.dyndns.org";
 }
 int n = contains(buf,"\r\n\r\n");
 std::string ans;
        if(n!=0)
  ans = (buf+n+3);
 shutdown(s,SHUT_RDWR);
 close(s);
 if (contains(ans.c_str(),"good") || contains(ans.c_str(),"nochg"))
 {
  dyndns_last_updated_ip = ip;
  return "update's ok, dyndns answered: "+ans;
 }
 if (contains(ans.c_str(),"badauth") || contains(ans.c_str(),"!donator") || contains(ans.c_str(),"notfqdn")
   || contains(ans.c_str(),"nohost") || contains(ans.c_str(),"numhost")
   || contains(ans.c_str(),"abuse") || contains(ans.c_str(),"badagent"))
 {
  dyndns = false;
  return "dyndns rejected, their answer: "+ans;
 }
 return "unknown answer: "+ans;
}

static __u32 ipaddress()
{
 struct ifreq *ifr;
 struct ifconf ifc;
 int numif;
 int s, j;

 memset(&ifc, 0, sizeof(ifc));
 ifc.ifc_ifcu.ifcu_req = __null;
 ifc.ifc_len = 0;

 if ((s = socket(2, 1, 0)) < 0) {

  return 0;
 }
 if (ioctl(s, 0x8912, &ifc) < 0) {
  perror("ioctl");
  return 0;
 }

 if ((ifr = new ifreq[ifc.ifc_len+2]) == __null) {

  close(s);
  return 0;
 }
 ifc.ifc_ifcu.ifcu_req = ifr;

 if (ioctl(s, 0x8912, &ifc) < 0) {

  close(s);
  return 0;
 }

 numif = ifc.ifc_len / sizeof(struct ifreq);
 __u32 ip = 0;
 __u32 ip192 = 0;
 for (j = 0; j < numif; j++)
 {
  struct ifreq *r = &ifr[j];
  struct ifreq c = *r;
  if (ioctl(s, 0x8913, &c) < 0)
  {

   close(s);
   return 0;
  }
  if ((c.ifr_ifru.ifru_flags & 0x1) && ((c.ifr_ifru.ifru_flags & 0x8) == 0))
  {
   __u32 t = ((struct sockaddr_in *)&r->ifr_ifru.ifru_addr)->sin_addr.s_addr;
   if ((t&255) == 192 && ((t>>8)&255) == 168)
    ip192 = t;
   else
    ip = t;
  }

 }
 if (ip == 0)
 {
  ip = ip192;
 }
 delete[] ifr;
 close(s);
 return ip;
}
static void
dyndnsset(struct mg_connection *conn,
                const struct mg_request_info *ri, void *data)
{
 send_ok(conn);
 if (ri->remote_ip!=2130706433 || strcmp(ri->remote_user,"JAVA_CLIENT") != 0)
 {
  return;
 }
 int n = strlen(ri->uri);
        if (n == 7)
 {
  dyndns = false;
  mg_printf(conn,"stopped using dyndns\n");
  return;
 }
 dyndns = true;
 dyndns_last_updated_ip = 0;
 dyndns_host = "";
 dyndns_base64 = "";
 int i = 7;
 while (i<n && ri->uri[i]!='&')
 {
  dyndns_host += ri->uri[i];
  i++;
 }
 i++;
 while (i<n)
 {
  dyndns_base64 += ri->uri[i];
  i++;
 }
 __u32 ip = ipaddress();
 mg_printf(conn,"%s",update_dyndns(ip).c_str());
}


static void
uptime(struct mg_connection *conn,
                const struct mg_request_info *ri, void *data)
{
 send_ok(conn);
 if (ri->permissions != -1)
  return;
 lock_wakelock();
 FILE* f;
 double a,b;
 if ((f = fopen("/proc/uptime","r")) && fscanf(f,"%lf %lf\n",&a,&b) == 2)
 {
  int A = (int)a/60;
  int B = (int)b/60;
  mg_printf(conn,"%s: ",lang(ri,"uptime").c_str());
  mg_printf(conn,"<abbr title=\"%s: %d\">",lang(ri,"uptime secs").c_str(),(int)a);
  if (A < 2*60)
   mg_printf(conn,"%d %s</abbr>, ",A,lang(ri,"mins").c_str());
  else if (A < 2*24*60)
   mg_printf(conn,"%d %s</abbr>, ",A/60,lang(ri,"hours").c_str());
  else if ((A/60)%24 == 1)
  {
   mg_printf(conn,"%d %s ",A/60/24,lang(ri,"days").c_str());
   mg_printf(conn,"%d %s</abbr>, ",(A/60)%24,lang(ri,"hour").c_str());
  }
  else
  {
   mg_printf(conn,"%d %s ",A/60/24,lang(ri,"days").c_str());
   mg_printf(conn,"%d %s</abbr>, ",(A/60)%24,lang(ri,"hours").c_str());
  }
  if ((int)b)
  {
   mg_printf(conn,"%s: ",lang(ri,"CPUup").c_str());
   mg_printf(conn,"<abbr title=\"%s: %d\">",lang(ri,"CPU uptime secs").c_str(),(int)b);
   if (B < 2*60)
    mg_printf(conn,"%d %s</abbr>, ",B,lang(ri,"mins").c_str());
   else if (B < 2*24*60)
    mg_printf(conn,"%d %s</abbr>, ",B/60,lang(ri,"hours").c_str());
   else if ((B/60)%24 == 1)
   {
    mg_printf(conn,"%d %s ",B/60/24,lang(ri,"days").c_str());
    mg_printf(conn,"%d %s</abbr>, ",(B/60)%24,lang(ri,"hour").c_str());
   }
   else
   {
    mg_printf(conn,"%d %s ",B/60/24,lang(ri,"days").c_str());
    mg_printf(conn,"%d %s</abbr>, ",(B/60)%24,lang(ri,"hours").c_str());
   }
   mg_printf(conn,"</abbr>");
  }
 }
 if (f)
  fclose(f);
}

static void
meminfo(struct mg_connection *conn,
                const struct mg_request_info *ri, void *data)
{
 send_ok(conn);
 if (ri->permissions != -1)
  return;
 lock_wakelock();
 FILE* f;
 if (f = fopen("/proc/meminfo","r"))
 {
  char name[100];
  int size;
  while(fscanf(f,"%s %d kB\n",name,&size) == 2)
  {
   if (!strcmp(name,"MemTotal:") || !strcmp(name,"MemFree:") || ((!strcmp(name,"SwapTotal:") || !strcmp(name,"SwapFree:")) && size))
   {
    if (size < 1000)
     mg_printf(conn,"%s <span class=\"gray\">%d</span> kB, ",name,size);
    else
     mg_printf(conn,"%s %d<span class=\"gray\"> %03d</span> kB, ",name,size/1000,size%1000);
   }
  }
  fclose(f);
 }
}

static void
netinfo(struct mg_connection *conn,
                const struct mg_request_info *ri, void *data)
{
 send_ok(conn);
 if (ri->permissions != -1)
  return;
 lock_wakelock();
 FILE* f;
 if (f = fopen("/proc/net/dev","r"))
 {
  char name[200];
  int bin,bout,pin,pout,t;
  fgets(name,200,f);
  fgets(name,200,f);
  while(fscanf(f,"%s %d %d",name,&bin,&pin) == 3)
  {

   int i;
   for (i=0; i< 6;i++)
   {
    if (fscanf(f,"%d",&t) != 1)
     break;
   }
   if (i<6)
    break;
   if(fscanf(f,"%d %d",&bout,&pout) != 2)
    break;
   if (bin+bout && strcmp(name,"lo:"))
   {
    if (bin+bout < 1024*1000)
     mg_printf(conn,"<abbr title=\"%s kbytes in: %d, out: %d; packages in: %d, out: %d\">%s</abbr>.<span class=\"gray\">%d</span> kB, ",name,bin>>10,bout>>10,pin,pout,name,(bin+bout)>>10);
    else
     mg_printf(conn,"<abbr title=\"%s kbytes in: %d, out: %d; packages in: %d, out: %d\">%s</abbr> %d<span class=\"gray\"> %03d</span> kB, ",name,bin>>10,bout>>10,pin,pout,name,((bin+bout)>>10)/1000,((bin+bout)>>10)%1000);
   }
   fgets(name,200,f);
  }
  fclose(f);
 }
}

static void
brightness(struct mg_connection *conn,
                const struct mg_request_info *ri, void *data)
{
 send_ok(conn);
 if (ri->permissions != -1)
  return;
 lock_wakelock();
 int fd = open("/sys/class/leds/lcd-backlight/brightness", 00000000);
 if (fd < 0)
  fd = open("/sys/class/backlight/pwm-backlight/brightness", 00000000);
 char value[20];
 int n;
 if (fd >= 0)
 {
  n = read(fd, value, 10);
  if (n)
   mg_printf(conn,"%s: %d%%, ",lang(ri,"Brightness").c_str(),100*getnum(value)/max_brightness);
  close(fd);
 }
}
static void
status(struct mg_connection *conn,
                const struct mg_request_info *ri, void *data)
{
 send_ok(conn);





 if (ri->permissions != -1)
  return;
 lock_wakelock();

 if (modelname[0])
  mg_printf(conn,"%s, ",modelname);

 FILE* f;
 double a,b;
 if ((f = fopen("/proc/uptime","r")) && fscanf(f,"%lf %lf\n",&a,&b) == 2)
 {
  int A = (int)a/60;
  int B = (int)b/60;
  mg_printf(conn,"%s: ",lang(ri,"uptime").c_str());
  mg_printf(conn,"<abbr title=\"%s: %d\">",lang(ri,"uptime secs").c_str(),(int)a);
  if (A < 2*60)
   mg_printf(conn,"%d %s</abbr>, ",A,lang(ri,"mins").c_str());
  else if (A < 2*24*60)
   mg_printf(conn,"%d %s</abbr>, ",A/60,lang(ri,"hours").c_str());
  else if ((A/60)%24 == 1)
  {
   mg_printf(conn,"%d %s ",A/60/24,lang(ri,"days").c_str());
   mg_printf(conn,"%d %s</abbr>, ",(A/60)%24,lang(ri,"hour").c_str());
  }
  else
  {
   mg_printf(conn,"%d %s ",A/60/24,lang(ri,"days").c_str());
   mg_printf(conn,"%d %s</abbr>, ",(A/60)%24,lang(ri,"hours").c_str());
  }
  if ((int)b)
  {
   mg_printf(conn,"%s: ",lang(ri,"CPUup").c_str());
   mg_printf(conn,"<abbr title=\"%s: %d\">",lang(ri,"CPU uptime secs").c_str(),(int)b);
   if (B < 2*60)
    mg_printf(conn,"%d %s</abbr>, ",B,lang(ri,"mins").c_str());
   else if (B < 2*24*60)
    mg_printf(conn,"%d %s</abbr>, ",B/60,lang(ri,"hours").c_str());
   else if ((B/60)%24 == 1)
   {
    mg_printf(conn,"%d %s ",B/60/24,lang(ri,"days").c_str());
    mg_printf(conn,"%d %s</abbr>, ",(B/60)%24,lang(ri,"hour").c_str());
   }
   else
   {
    mg_printf(conn,"%d %s ",B/60/24,lang(ri,"days").c_str());
    mg_printf(conn,"%d %s</abbr>, ",(B/60)%24,lang(ri,"hours").c_str());
   }
   mg_printf(conn,"</abbr>");
  }
 }
 if (f)
  fclose(f);
 if (f = fopen("/proc/meminfo","r"))
 {
  char name[100];
  int size;
  while(fscanf(f,"%s %d kB\n",name,&size) == 2)
  {
   if (!strcmp(name,"MemTotal:") || !strcmp(name,"MemFree:") || ((!strcmp(name,"SwapTotal:") || !strcmp(name,"SwapFree:")) && size))
   {
    if (size < 1000)
     mg_printf(conn,"%s <span class=\"gray\">%d</span> kB, ",name,size);
    else
     mg_printf(conn,"%s %d<span class=\"gray\"> %03d</span> kB, ",name,size/1000,size%1000);
   }
  }
  fclose(f);
 }
 if (f = fopen("/proc/net/dev","r"))
 {
  char name[200];
  int bin,bout,pin,pout,t;
  fgets(name,200,f);
  fgets(name,200,f);
  while(fscanf(f,"%s %d %d",name,&bin,&pin) == 3)
  {

   int i;
   for (i=0; i< 6;i++)
   {
    if (fscanf(f,"%d",&t) != 1)
     break;
   }
   if (i<6)
    break;
   if(fscanf(f,"%d %d",&bout,&pout) != 2)
    break;
   if (bin+bout && strcmp(name,"lo:"))
   {
    if (bin+bout < 1024*1000)
     mg_printf(conn,"<abbr title=\"%s kbytes in: %d, out: %d; packages in: %d, out: %d\">%s</abbr>.<span class=\"gray\">%d</span> kB, ",name,bin>>10,bout>>10,pin,pout,name,(bin+bout)>>10);
    else
     mg_printf(conn,"<abbr title=\"%s kbytes in: %d, out: %d; packages in: %d, out: %d\">%s</abbr> %d<span class=\"gray\"> %03d</span> kB, ",name,bin>>10,bout>>10,pin,pout,name,((bin+bout)>>10)/1000,((bin+bout)>>10)%1000);
   }
   fgets(name,200,f);
  }
  fclose(f);
 }

 int fd = open("/sys/class/leds/lcd-backlight/brightness", 00000000);
 if (fd < 0)
  fd = open("/sys/class/backlight/pwm-backlight/brightness", 00000000);
 char value[20];
 int n;
 if (fd >= 0)
 {
  n = read(fd, value, 10);
  if (n)
   mg_printf(conn,"%s: %d%%, ",lang(ri,"Brightness").c_str(),100*getnum(value)/max_brightness);
  close(fd);
 }
 if (recording)
 {
  mg_printf(conn,"<span style=\"color: red\">%s %d ",lang(ri,"Recorded").c_str(),recordingnum);
  mg_printf(conn,"%s</span>, ",lang(ri,"images").c_str());
 }
}
static void
sdcard(struct mg_connection *conn,
                const struct mg_request_info *ri, void *data)
{
 if (ri->permissions != -1 && (ri->permissions&64)==0)
  return;
 lock_wakelock();
 access_log(ri,"browse sdcard");
 send_ok(conn,"Content-Type: text/html; charset=UTF-8\r\nSet-Cookie: path=/");
 FILE* f = fo("sdcard.html","rb");
 if (!f)
  return;
 fseek (f , 0 , 2);
 int lSize = ftell (f);
 rewind (f);
 char* filebuffer = new char[lSize+1];
 if (!filebuffer)
  return;
 fread(filebuffer,1,lSize,f);
 filebuffer[lSize] = 0;
 mg_write(conn,filebuffer,lSize);
 fclose(f);
 delete[] filebuffer;
}

int remove_directory(const char *path)
{
   DIR *d = opendir(path);
   size_t path_len = strlen(path);
   int r = -1;
   if (d)
   {
      struct dirent *p;
      r = 0;
      while (!r && (p=readdir(d)))
      {
          int r2 = -1;
          char *buf;
          size_t len;
          if (!strcmp(p->d_name, ".") || !strcmp(p->d_name, ".."))
             continue;
   std::string next = std::string(path) + std::string("/") + std::string(p->d_name);
   struct stat statbuf;
             if (!stat(next.c_str(), &statbuf))
             {
                if ((((statbuf.st_mode) & 00170000) == 0040000))
                {
                   r2 = remove_directory(next.c_str());
                }
                else
                {
                   r2 = unlink(next.c_str());
                }
             }
          r = r2;
      }
      closedir(d);
   }
   if (!r)
   {
    r = rmdir(path);
   }
   return r;
}

static void
upload(struct mg_connection *conn,
                const struct mg_request_info *ri, void *data)
{

 if (ri->permissions != -1)
  return;
 lock_wakelock();
 access_log(ri,"upload");
 char* post_data;
 int post_data_len = contentlen(conn);
 int read = 0;



 std::string file = getoption(ri->uri,"file=");
 if (file.size() == 0)
  file = dir + getoption(ri->uri,"local=");

 char to[4096];
 strcpy(to,file.c_str());
 url_decode(to, strlen(to), to, 4096, true);
 remove_double_dots_and_double_slashes(to);

 mg_printf(conn,"HTTP/1.1 200 OK\r\nCache-Control: no-store, no-cache, must-revalidate\r\nCache-Control: post-check=0, pre-check=0\r\nPragma: no-cache\r\nContent-Type: text/plain;\r\nConnection: close\r\n\r\n");

 FILE* out;
 if ((out = fopen(to, "w")) == __null)
 {
  mg_printf(conn,"Unable to open file.\n");
  return;
 }

 while (read < post_data_len)
 {
  int next = post_data_len - read;
  if (next > 1048576)
   next = 1048576;
  post_data = new char[next+1];
  if (post_data == __null)
  {
   mg_printf(conn, "Not enough memory.\n");
   return;
  }

  read += mg_read(conn,post_data,next);
  if (fwrite(post_data, 1, next, out) < next)
  {
   mg_printf(conn, "Failed to save file.\n");
   delete[] post_data;
   return;
  }
  delete[] post_data;
 }
 fclose(out);
 std::string perm = getoption(post_data,"file=");
 if (perm.size())
 {
  int p = atoi(perm.c_str());
  chmod(to, p);
 }

 mg_printf(conn, "ok");
}

static void
content(struct mg_connection *conn,
                const struct mg_request_info *ri, void *data)
{
 if (ri->permissions != -1 && (ri->permissions&64)==0)
  return;
 lock_wakelock();
 access_log(ri,"browse sdcard");
 char* post_data;
 int post_data_len;
 read_post_data(conn,ri,&post_data,&post_data_len);


 if (ri->query_string == __null && post_data_len && startswith(post_data,"get_action=put_content"))
 {
  std::string file = getoption(post_data,"file=");
  char to[4096];
  strcpy(to,file.c_str());
  url_decode(to, strlen(to), to, 4096, true);
  remove_double_dots_and_double_slashes(to);
  std::string code = getoption(post_data,"content=");
  char* c = new char[code.length()+1];
  strcpy(c,code.c_str());
  url_decode(c,strlen(c),c,strlen(c),true);
  mg_printf(conn,"HTTP/1.1 200 OK\r\nCache-Control: no-store, no-cache, must-revalidate\r\nCache-Control: post-check=0, pre-check=0\r\nPragma: no-cache\r\nContent-Type: text/plain;\r\nConnection: close\r\n\r\n");
  if (post_data_len == 65536)
  {
   mg_printf(conn,"The file is too large.");
   delete[] c;
   return;
  }
  FILE* out;
  if (out = fopen(to, "w"))
  {
   fwrite(c, 1, strlen(c), out);
   fclose(out);
   mg_printf(conn,"The file has been saved successfully");
  }
  else
   mg_printf(conn,"1000");

  delete[] c;
  return;
 }
 int i;
 for (i = 0; i < ri->num_headers; i++)
 {
  if (!strncasecmp("Content-Type", ri->http_headers[i].name,12) &&
   !strncasecmp("multipart/form-data", ri->http_headers[i].value,19))
   break;
 }

 if (i < ri->num_headers)
 {

  i = 0;
  while (i < post_data_len && post_data[i] != '\r') i++;
  if (i>=post_data_len) {if (post_data) delete[] post_data; return;}
  post_data[i] = 0;
  std::string boundary = std::string("\r\n") + std::string(post_data);
  i+=2;

  if (i>=post_data_len) {if (post_data) delete[] post_data; return;}

  if (strncasecmp("Content-Disposition: form-data; name=\"userfile_",post_data+i,47))
   {if (post_data) delete[] post_data; return;}
  i += 47;

  while (i < post_data_len && post_data[i] != '_') i++;
  i++;
  if (i>=post_data_len) {if (post_data) delete[] post_data; return;}
  int start = i;
  while (i < post_data_len && post_data[i] != '"') i++;
  if (i>=post_data_len) {if (post_data) delete[] post_data; return;}
  post_data[i] = 0;

  url_decode(post_data+start, strlen(post_data+start), post_data+start, 4096, true);
  std::string dir = post_data+start;

  while (i < post_data_len-4 && strncmp(post_data+i,"filename=\"",10)) i++;
  i += 10;
  start = i;
  while (i < post_data_len-4 && post_data[i] != '"') i++;
  if (i>=post_data_len) {if (post_data) delete[] post_data; return;}

  post_data[i] = 0;
  std::string filename = post_data+start;

  while (i < post_data_len-4 && strncmp(post_data+i,"\r\n\r\n",4)) i++;
  i+=4;
  if (i>=post_data_len) {if (post_data) delete[] post_data; return;}
  start = i;

  send_ok(conn);
  FILE * f = fopen((dir+"/"+filename).c_str(),"w");
  if (!f)
  {

   mg_printf(conn,"<html><script language=\"javascript\">if(parent.ajaxplorer.actionBar.multi_selector) parent.ajaxplorer.actionBar.multi_selector.submitNext('Error opening file for writing');</script></html>\n");
   if (post_data)
    delete[] post_data;
   return;
  }

  int already_read = 65536;
  while(post_data_len == 65536)
  {
   int s = fwrite(post_data+start,1,65536-500-start,f);


   if(s < 65536-500-start)
    {
     mg_printf(conn,"<html><script language=\"javascript\">if(parent.ajaxplorer.actionBar.multi_selector) parent.ajaxplorer.actionBar.multi_selector.submitNext('Error writing. Is disk full?');</script></html>\n");
     fclose(f);
     if (post_data)
      delete[] post_data;
     return;
    }
   start = 0;
   int l = contentlen(conn) - already_read;

   if (l > 65536-500)
    l = 65536-500;
   memcpy(post_data,post_data+65536-500,500);
   post_data_len = mg_read(conn,post_data+500,l) + 500;
   post_data[post_data_len] = 0;
   already_read += post_data_len - 500;

  }
  i=0;
  while (i < post_data_len && strncmp(post_data+i,boundary.c_str(),boundary.size())) i++;
  if (i>=post_data_len)
  {
   mg_printf(conn,"<html><script language=\"javascript\">if(parent.ajaxplorer.actionBar.multi_selector) parent.ajaxplorer.actionBar.multi_selector.submitNext('Error, no boundary found at the end of the stream. Strange...');</script></html>\n");
   if (post_data)
    delete[] post_data;
   fclose(f);
   return;
  }
  if(fwrite(post_data+start,1,i-start,f) < i-start)
   {
    mg_printf(conn,"<html><script language=\"javascript\">if(parent.ajaxplorer.actionBar.multi_selector) parent.ajaxplorer.actionBar.multi_selector.submitNext('Error writing. Is disk full?');</script></html>\n");
    fclose(f);
    if (post_data)
     delete[] post_data;
    return;
   }
  fclose(f);
  mg_printf(conn,"<html><script language=\"javascript\">if(parent.ajaxplorer.actionBar.multi_selector) parent.ajaxplorer.actionBar.multi_selector.submitNext();</script></html>\n");
  if (post_data)
   delete[] post_data;
  return;
 }
 if (ri->query_string == __null)
  return;

 FILE* f = __null;
 if (startswith(ri->query_string,"get_action=save_user_pref")
 || startswith(ri->query_string,"get_action=switch_repository"))
 {
  sdcard(conn,ri,data);
  return;
 }
 std::string action = getoption(ri->query_string,"action=");

 if (action == "get_boot_conf")
 {
  send_ok(conn,"Content-Type: text/javascript; charset=UTF-8");
  f = fo("ae_get_boot_conf","rb");
 }
 if (strcmp(ri->query_string,"get_action=get_template&template_name=flash_tpl.html&pluginName=uploader.flex&encode=false")==0)
 {
  send_ok(conn);
  f = fo("ae_get_template","rb");
  if (f)
  {
   fseek (f , 0 , 2);
   int lSize = ftell (f);
   rewind (f);
   char* filebuffer = new char[lSize+1];
   if (!filebuffer)
    return;
   fread(filebuffer,1,lSize,f);
   filebuffer[lSize] = 0;
   mg_write(conn,filebuffer,lSize);
   fclose(f);
   delete[] filebuffer;






   f = __null;

  }
 }
 if (action == "get_xml_registry")
 {
  send_ok(conn,"Content-Type: text/xml; charset=UTF-8");
  f = fo("ae_get_xml_registry","rb");
 }
 if (f)
 {
  fseek (f , 0 , 2);
  int lSize = ftell (f);
  rewind (f);
  char* filebuffer = new char[lSize+1];
  if (!filebuffer)
   return;
  fread(filebuffer,1,lSize,f);
  filebuffer[lSize] = 0;
  mg_write(conn,filebuffer,lSize);
  fclose(f);
  delete[] filebuffer;
  return;
 }
 if (action == "ls")
 {

  send_ok(conn,"Content-Type: text/xml; charset=UTF-8");
  std::string dp = getoption(ri->query_string,"dir=");
  char dirpath[4096];







   strcpy(dirpath, dp.c_str());
   url_decode(dirpath, strlen(dirpath), dirpath, 4096, true);


  if (!startswith(dirpath,"/sdcard"))
  {
   (void) mg_printf(conn, "<?xml version=\"1.0\" encoding=\"UTF-8\"?><tree filename=\"\" text=\"\" is_file=\"false\"><tree is_file=\"false\" filename=\"/sdcard\" text=\"sdcard\" icon=\"folder.png\" mimestring=\"Directory\" is_image=\"0\"/></tree>");
   return;
  }

  remove_double_dots_and_double_slashes(dirpath);


  my_send_directory(conn,dirpath);
 }
 if (action == "download"
  || action == "preview_data_proxy"
  || action == "audio_proxy"
  || action == "get_content"
  || action == "open_with")
 {

  std::string fp = getoption(ri->query_string,"file=");
  if (action == "audio_proxy")
   fp = base64_decode(fp);
  char filepath[4096];
  strcpy(filepath, fp.c_str());
  url_decode(filepath, strlen(filepath), filepath, 4096, true);
  if (!startswith(filepath,"/sdcard"))
   return;
  remove_double_dots_and_double_slashes(filepath);
  int i;
  for (i = strlen(filepath)-1; i>=0; i--)
   if (filepath[i]=='/')
    break;


  if (action=="preview_data_proxy")
  {
   mg_printf(conn,"HTTP/1.1 200 OK\r\nCache-Control: no-store, no-cache, must-revalidate\r\nCache-Control: post-check=0, pre-check=0\r\nPragma: no-cache\r\nContent-Type: image/jpg; name=\"%s\"\r\nConnection: close\r\n\r\n",filepath+i+1);

  }
  if (action == "open_with" || action == "get_content")
  {
   mg_printf(conn,"HTTP/1.1 200 OK\r\nCache-Control: no-store, no-cache, must-revalidate\r\nCache-Control: post-check=0, pre-check=0\r\nPragma: no-cache\r\nContent-Type: text/plain;\r\nConnection: close\r\n\r\n");
  }
  if (action == "download")
  {
   mg_printf(conn,"HTTP/1.1 200 OK\r\nCache-Control: no-store, no-cache, must-revalidate\r\nCache-Control: post-check=0, pre-check=0\r\nPragma: no-cache\r\nname=\"%s\"\r\nContent-Disposition: attachment; filename=\"%s\"\r\nConnection: close\r\n\r\n",filepath+i+1,filepath+i+1);
  }
  if (action == "audio_proxy")
  {
   mg_printf(conn,"HTTP/1.1 200 OK\r\nCache-Control: no-store, no-cache, must-revalidate\r\nCache-Control: post-check=0, pre-check=0\r\nPragma: no-cache\r\nContent-Type: audio/mp3: name=\"%s\"\r\nConnection: close\r\n\r\n",filepath+i+1);
  }
  sendfile(filepath,conn);

  return;
 }
 if (action == "rename")
 {
  std::string fp = getoption(ri->query_string,"file=");
  char filepath[4096];
  strcpy(filepath, fp.c_str());
  url_decode(filepath, strlen(filepath), filepath, 4096, true);
  if (!startswith(filepath,"/sdcard"))
   return;
  remove_double_dots_and_double_slashes(filepath);
  int i;
  for (i = strlen(filepath)-1; i>=0; i--)
   if (filepath[i]=='/')
    break;

  fp = getoption(ri->query_string,"filename_new=");
  char newfile[4096];
  strcpy(newfile, filepath);
  newfile[i+1] = 0;
  strcat(newfile, fp.c_str());
  url_decode(newfile, strlen(newfile), newfile, 4096, true);
  remove_double_dots_and_double_slashes(newfile);

  int st = rename(filepath, newfile);
  send_ok(conn);
  if (st == 0)
  {
   char buff[4096];
   convertxml(buff,filepath);
   char buff2[4096];
   convertxml(buff2,fp.c_str());
   mg_printf(conn,"<?xml version=\"1.0\" encoding=\"UTF-8\"?><tree><message type=\"SUCCESS\">%s has been renamed to %s</message><reload_instruction object=\"data\" node=\"\" file=\"%s\"/></tree>",buff,buff2,buff2);
  }
  else
  {
   char buff[4096];
   convertxml(buff,filepath);
   char buff2[4096];
   convertxml(buff2,fp.c_str());
   mg_printf(conn,"<?xml version=\"1.0\" encoding=\"UTF-8\"?><tree><message type=\"ERROR\">Error renaming %s to %s</message></tree>",buff,buff2);
  }
  return;
 }
 if (action == "mkdir")
 {
  std::string fp = getoption(ri->query_string,"dir=");
  if (!startswith(fp.c_str(),"%2Fsdcard"))
   fp = "/sdcard/"+fp;
  char filepath[4096];
  strcpy(filepath, fp.c_str());
  url_decode(filepath, strlen(filepath), filepath, 4096, true);

  std::string nd = getoption(ri->query_string,"dirname=");
  std::string dirname = fp + '/' + nd;
  char newdir[4096];
  strcpy(newdir, dirname.c_str());
  url_decode(newdir, strlen(newdir), newdir, 4096, true);
  remove_double_dots_and_double_slashes(newdir);

  int st = mkdir(newdir, 0777);
  send_ok(conn);
  if (st == 0)
  {
   char buff[4096];
   convertxml(buff,newdir);
   char buff2[4096];
   convertxml(buff2,nd.c_str());
   mg_printf(conn,"<?xml version=\"1.0\" encoding=\"UTF-8\"?><tree><message type=\"SUCCESS\">The directory %s has been created.</message><reload_instruction object=\"data\" node=\"\" file=\"%s\"/></tree>",buff,buff2);
  }
  else
  {
   char buff[4096];
   convertxml(buff,newdir);
   mg_printf(conn,"<?xml version=\"1.0\" encoding=\"UTF-8\"?><tree><message type=\"ERROR\">Error creating directory %s</message></tree>",buff);
  }
  return;
 }
 if (action == "mkfile")
 {
  std::string file = getoption(ri->query_string,"dir=") + "/" + getoption(ri->query_string,"filename=");
  if (!startswith(file.c_str(),"%2Fsdcard"))
   file = "/sdcard/"+file;

  char filepath[4096];
  strcpy(filepath, file.c_str());
  url_decode(filepath, strlen(filepath), filepath, 4096, true);
  remove_double_dots_and_double_slashes(filepath);

  FILE* f;
  char buff[4096];
  convertxml(buff,filepath);
  if (f=fopen(filepath,"a"))
  {
   mg_printf(conn,"<?xml version=\"1.0\" encoding=\"UTF-8\"?><tree><message type=\"SUCCESS\">The file %s has been created.</message><reload_instruction object=\"data\" node=\"\" file=\"%s\"/></tree>",buff,buff);
   fclose(f);
   return;
  }
  mg_printf(conn,"<?xml version=\"1.0\" encoding=\"UTF-8\"?><tree><message type=\"ERROR\">Error creating file %s</message></tree>",buff);
 }
 if (action == "delete" || action == "copy" || action == "move")
 {
  bool copy = (action == "copy");
  bool del = (action == "delete");
  bool move = (action == "move");
  std::string dest = getoption(ri->query_string,"dest=");
  if (!startswith(dest.c_str(),"%2Fsdcard"))
   dest = "/sdcard/"+dest;
  int i = -1;
  std::string file;
  int ok = 0;
  int failed = 0;
  char filepath[4096];
  char to[4096];


  while(1)
  {
   if (i == -1)
    file = getoption(ri->query_string,"file=");
   else
   {
    char name[32];
    strcpy(name,"file_");
    char num[32];
    itoa(num,i);
    strcat(name,num);
    strcat(name,"=");
    file = getoption(ri->query_string,name);
   }
   if (file == "" && i != -1)
    break;
   if (file == "" && i == -1)
   {
    i++;
    continue;
   }
   if (!startswith(file.c_str(),"%2Fsdcard"))
    file = "/sdcard/"+file;

   strcpy(filepath, file.c_str());
   url_decode(filepath, strlen(filepath), filepath, 4096, true);
   remove_double_dots_and_double_slashes(filepath);

   if (del)
   {
      struct stat statbuf;
      if (!stat(filepath, &statbuf))
      {
       int r = -1;
       if ((((statbuf.st_mode) & 00170000) == 0040000))
        r = remove_directory(filepath);
       else
        r = unlink(filepath);
       if (!r)
        ok++;
      }
      else
       ok++;


   }
   if (move)
   {
    strcpy(to,dest.c_str());
    url_decode(to, strlen(to), to, 4096, true);
    remove_double_dots_and_double_slashes(to);
    int j = strlen(to);
    if (j && to[j-1] != '/')
    {
     to[j++] = '/';
     to[j] = 0;
    }
    int n = strlen(filepath)+1;
    int i = n;
    for (;i>=0 && filepath[i] != '/';i--);
    for(i++; i < n; i++)
     to[j++] = filepath[i];
    to[j++] = 0;
    if (!rename(filepath, to))
     ok++;


   }
   if (copy)
   {

    strcpy(to,dest.c_str());
    url_decode(to, strlen(to), to, 4096, true);
    remove_double_dots_and_double_slashes(to);
    int j = strlen(to);
    if (j && to[j-1] != '/')
    {
     to[j++] = '/';
     to[j] = 0;
    }
    int n = strlen(filepath)+1;
    int i = n;
    for (;i>=0 && filepath[i] != '/';i--);
    for(i++; i < n; i++)
     to[j++] = filepath[i];
    to[j++] = 0;
    FILE* in, *out;
    char buff[65526];
    struct stat s;
    if (!stat(filepath,&s) && (((s.st_mode) & 00170000) == 0100000) && (in = fopen(filepath, "r")))
    {
     if ((out = fopen(to, "w")))
     {
      while(j = fread(buff, 1, 65536, in))
      {

       fwrite(buff, 1, j, out);
      }
      fclose(out);
      ok++;
     }
     fclose(in);
    }
   }

   i++;
  }
  char d[4096];
  strcpy(d,dest.c_str());
  url_decode(d, strlen(d), d, 4096, true);
  remove_double_dots_and_double_slashes(d);
  if (i == 0 && del)
  {
   char buff[4096];
   convertxml(buff,filepath);
   if (ok == 0)
    mg_printf(conn,"<?xml version=\"1.0\" encoding=\"UTF-8\"?><tree><message type=\"ERROR\">Error deleting file or directory %s</message></tree>",buff);
   else
    mg_printf(conn,"<?xml version=\"1.0\" encoding=\"UTF-8\"?><tree><message type=\"SUCCESS\">The file or directory %s has been deleted.</message><reload_instruction object=\"data\" node=\"\"/></tree>",buff);
  }
  if (i == 0 && move)
  {
   char buff[4096];
   convertxml(buff,filepath);
   char buff2[4096];
   convertxml(buff2,to);
   char buff3[4096];
   convertxml(buff3,d);
   if (ok == 0)
    mg_printf(conn,"<?xml version=\"1.0\" encoding=\"UTF-8\"?><tree><message type=\"ERROR\">Error moving file or directory %s to %s.</message></tree>",buff,buff2);
   else
    mg_printf(conn,"<?xml version=\"1.0\" encoding=\"UTF-8\"?><tree><message type=\"SUCCESS\">The file or directory %s has been moved to %s.</message><reload_instruction object=\"data\" node=\"\"/><reload_instruction object=\"data\" node=\"%s\"/></tree>",buff,buff2,buff3);
  }
  if (i == 0 && copy)
  {
   char buff[4096];
   convertxml(buff,filepath);
   char buff2[4096];
   convertxml(buff2,to);
   char buff3[4096];
   convertxml(buff3,d);
   if (ok == 0)
    mg_printf(conn,"<?xml version=\"1.0\" encoding=\"UTF-8\"?><tree><message type=\"ERROR\">Error copying file or directory %s to %s.</message></tree>",buff,buff2);
   else
    mg_printf(conn,"<?xml version=\"1.0\" encoding=\"UTF-8\"?><tree><message type=\"SUCCESS\">The file or directory %s has been copied to %s.</message><reload_instruction object=\"data\" node=\"\"/><reload_instruction object=\"data\" node=\"%s\"/></tree>",buff,buff2,buff3);
  }
  if (i>0 && del)
  {
   if (ok != i)
    mg_printf(conn,"<?xml version=\"1.0\" encoding=\"UTF-8\"?><tree><message type=\"ERROR\">Error deleting some files or directories</message><reload_instruction object=\"data\" node=\"\"/></tree>");
   else
    mg_printf(conn,"<?xml version=\"1.0\" encoding=\"UTF-8\"?><tree><message type=\"SUCCESS\">The selected files and directories have been deleted.</message><reload_instruction object=\"data\" node=\"\"/></tree>");
  }
  if (i>0 && move)
  {
   char buff3[4096];
   convertxml(buff3,d);
   if (ok != i)
    mg_printf(conn,"<?xml version=\"1.0\" encoding=\"UTF-8\"?><tree><message type=\"ERROR\">Error moving some files or directories</message><reload_instruction object=\"data\" node=\"\"/><reload_instruction object=\"data\" node=\"%s\"/></tree>",buff3);
   else
    mg_printf(conn,"<?xml version=\"1.0\" encoding=\"UTF-8\"?><tree><message type=\"SUCCESS\">The selected files and directories have been moved.</message><reload_instruction object=\"data\" node=\"\"/><reload_instruction object=\"data\" node=\"%s\"/></tree>",buff3);
  }
  if (i>0 && copy)
  {
   char buff3[4096];
   convertxml(buff3,d);
   if (ok != i)
    mg_printf(conn,"<?xml version=\"1.0\" encoding=\"UTF-8\"?><tree><message type=\"ERROR\">Error copying some files or directories</message><reload_instruction object=\"data\" node=\"\"/><reload_instruction object=\"data\" node=\"%s\"/></tree>",buff3);
   else
    mg_printf(conn,"<?xml version=\"1.0\" encoding=\"UTF-8\"?><tree><message type=\"SUCCESS\">The selected files and directories have been copied.</message><reload_instruction object=\"data\" node=\"\"/><reload_instruction object=\"data\" node=\"%s\"/></tree>",buff3);
  }
 }
 if (action == "upload")
 {
# 8319 "webkey-2.09/service/webkey.cpp"
  send_ok(conn);
  std::string dir = getoption(ri->query_string,"dir=");
  char to[4096];
  strcpy(to,dir.c_str());
  url_decode(to, strlen(to), to, 4096, true);
  int i;
  std::string file;
  for (i = 0; i < ri->num_headers; i++)
   if (!strcasecmp("X-File-Name", ri->http_headers[i].name))
   {
    file = ri->http_headers[i].value;
    break;
   }
  if (i == ri->num_headers)
  {
   mg_printf(conn,"There should be an X-File-Name in the HTTP header list.");
   return;
  }
  if (!startswith(to,"/sdcard"))
   file = std::string("/sdcard/")+std::string(to)+'/'+file;
  else
   file = std::string(to)+'/'+file;
  char filepath[4096];
  if (file.size() >= 4096 -1)
  {
   mg_printf(conn,"Too long filename");
   return;
  }
  strcpy(filepath,file.c_str());
  remove_double_dots_and_double_slashes(filepath);

  FILE* f = fopen(filepath,"w");
  if (!f)
  {
   mg_printf(conn,"Bad Request3");
   return;
  }


  int already_read = 0;
  while(post_data_len)
  {
   already_read += post_data_len;
   fwrite(post_data,1,post_data_len,f);
   int l = contentlen(conn) - already_read;
   if (l > 65536)
    l = 65536;
   post_data_len = mg_read(conn,post_data,l);
   post_data[post_data_len] = 0;
  }
  fwrite(post_data,1,post_data_len,f);
  fclose(f);
  mg_printf(conn,"OK");
 }
 if (post_data)
  delete[] post_data;
}

static void
testfb(struct mg_connection *conn,
                const struct mg_request_info *ri, void *data)
{
 if (ri->permissions != -1)
  return;
 lock_wakelock();
 access_log(ri,"run testfb");
 send_ok(conn);

        size_t pixels;


        pixels = scrinfo.xres * scrinfo.yres;
        bytespp = scrinfo.bits_per_pixel / 8;
 if (bytespp == 3)
  bytespp = 4;

        mg_printf(conn,"We might read from unused memory, it might happen that Webkey gets stopped.\n");
        mg_printf(conn,"xres=%d, yres=%d, xresv=%d, yresv=%d, xoffs=%d, yoffs=%d, bpp=%d\n",
          (int)scrinfo.xres, (int)scrinfo.yres,
          (int)scrinfo.xres_virtual, (int)scrinfo.yres_virtual,
          (int)scrinfo.xoffset, (int)scrinfo.yoffset,
          (int)scrinfo.bits_per_pixel);



 int rr = scrinfo.red.offset;
 int rl = 8-scrinfo.red.length;
 int gr = scrinfo.green.offset;
 int gl = 8-scrinfo.green.length;
 int br = scrinfo.blue.offset;
 int bl = 8-scrinfo.blue.length;
 int j;
 mg_printf(conn,"rr=%d, rl=%d, gr=%d, gl=%d, br=%d, bl=%d\n",rr,rl,gr,gl,br,bl);

 mg_printf(conn,"nonstd=%d\n",scrinfo.nonstd);
 mg_printf(conn,"activate=%d\n",scrinfo.activate);
 mg_printf(conn,"height=%d\n",scrinfo.height);
 mg_printf(conn,"width=%d\n",scrinfo.width);
 mg_printf(conn,"accel_flags=%d\n",scrinfo.accel_flags);
 mg_printf(conn,"pixclock=%d\n",scrinfo.pixclock);
 mg_printf(conn,"left_margin=%d\n",scrinfo.left_margin);
 mg_printf(conn,"right_margin=%d\n",scrinfo.right_margin);
 mg_printf(conn,"upper_margin=%d\n",scrinfo.upper_margin);
 mg_printf(conn,"lower_margin=%d\n",scrinfo.lower_margin);
 mg_printf(conn,"hsync_len=%d\n",scrinfo.hsync_len);
 mg_printf(conn,"vsync_len=%d\n",scrinfo.vsync_len);
 mg_printf(conn,"sync=%d\n",scrinfo.sync);
 mg_printf(conn,"vmode=%d\n",scrinfo.vmode);
 mg_printf(conn,"rotate=%d\n",scrinfo.rotate);
 mg_printf(conn,"reserved[0]=%d\n",scrinfo.reserved[0]);
 mg_printf(conn,"reserved[1]=%d\n",scrinfo.reserved[1]);
 mg_printf(conn,"reserved[2]=%d\n",scrinfo.reserved[2]);
 mg_printf(conn,"reserved[3]=%d\n",scrinfo.reserved[3]);
 mg_printf(conn,"reserved[4]=%d\n",scrinfo.reserved[4]);

 int m = scrinfo.yres*scrinfo.xres_virtual;
 int offset = scrinfo.yoffset*scrinfo.xres_virtual+scrinfo.xoffset;

 if (!pict)
  init_fb();
 memcpy(copyfb,(char*)fbmmap+offset*bytespp,m*bytespp);

 mg_printf(conn,"offset*bytespp=%d\n",offset*bytespp);
 mg_printf(conn,"m*bytespp=%d\n",m*bytespp);

 if (!graph)
  init_fb();
 if (!graph)
 {
  mg_printf(conn,"graph is null\n");
  return;
 }

 int i;
 unsigned short int* map = (unsigned short int*)fbmmap;
 unsigned short int* map2 = (unsigned short int*)copyfb;
 for (i = 0; i < 500; i++)
 {
  mg_printf(conn,"map[%d] is %d\n",100*i+i,map[100*i+i]);
  mg_printf(conn,"map2[%d] is %d\n",100*i+i,map2[100*i+i]);
 }

}

static void
testtouch(struct mg_connection *conn,
                const struct mg_request_info *ri, void *data)
{
 if (ri->permissions != -1)
  return;
 lock_wakelock();
 access_log(ri,"run testtouch");
 send_ok(conn);
 if (is_icecreamsandwich)
  mg_printf(conn,"this is icrecreamsandwich\n");
 if (use_uinput_mouse)
  mg_printf(conn,"using uinput for mouse, type = %d\n", use_uinput_mouse);
 int i;



 char touch_device[19] = "/dev/input/event0";

 int tfd = -1;
 for (i=0; i<50; i++)
 {
  char name[256]="Unknown";
  if (i < 10)
  {
   touch_device[sizeof(touch_device)-3] = '0'+(char)(i);
   touch_device[sizeof(touch_device)-2] = 0;
  }
  else
  {
   touch_device[sizeof(touch_device)-3] = '0'+(char)(i/10);
   touch_device[sizeof(touch_device)-2] = '0'+(char)(i%10);
   touch_device[sizeof(touch_device)-1] = 0;
  }
  struct input_absinfo info;
  if((tfd = open(touch_device, 00000002)) == -1)
  {
   continue;
  }
  mg_printf(conn,"searching for touch device, opening %s ... ",touch_device);
  if (ioctl(tfd, (((2U) << (((0 +8)+8)+14)) | (('E') << (0 +8)) | ((0x06) << 0) | ((sizeof(name)) << ((0 +8)+8))),name) < 0)
  {
   mg_printf(conn,"failed, no name\n");
   close(tfd);
   tfd = -1;
   continue;
  }
  mg_printf(conn,"device name is %s\n",name);


  if(ioctl(tfd, (((2U) << (((0 +8)+8)+14)) | ((('E')) << (0 +8)) | (((0x40 + 0x00)) << 0) | (((((sizeof(struct input_absinfo) == sizeof(struct input_absinfo[1]) && sizeof(struct input_absinfo) < (1 << 14)) ? sizeof(struct input_absinfo) : __invalid_size_argument_for_IOC))) << ((0 +8)+8))), &info))
  {
   printf("failed, no ABS_X\n");
   close(tfd);
   tfd = -1;
   continue;
  }
  xmin = info.minimum;
  xmax = info.maximum;
  if (xmin == 0 && xmax == 0)
  {
   if(ioctl(tfd, (((2U) << (((0 +8)+8)+14)) | ((('E')) << (0 +8)) | (((0x40 + 53)) << 0) | (((((sizeof(struct input_absinfo) == sizeof(struct input_absinfo[1]) && sizeof(struct input_absinfo) < (1 << 14)) ? sizeof(struct input_absinfo) : __invalid_size_argument_for_IOC))) << ((0 +8)+8))), &info))
   {
    printf("failed, no ABS_X\n");
    close(tfd);
    tfd = -1;
    continue;
   }
   xmin = info.minimum;
   xmax = info.maximum;
  }

  if(ioctl(tfd, (((2U) << (((0 +8)+8)+14)) | ((('E')) << (0 +8)) | (((0x40 + 0x01)) << 0) | (((((sizeof(struct input_absinfo) == sizeof(struct input_absinfo[1]) && sizeof(struct input_absinfo) < (1 << 14)) ? sizeof(struct input_absinfo) : __invalid_size_argument_for_IOC))) << ((0 +8)+8))), &info)) {
   printf("failed, no ABS_Y\n");
   close(tfd);
   tfd = -1;
   continue;
  }
  ymin = info.minimum;
  ymax = info.maximum;
  if (ymin == 0 && ymax == 0)
  {
   if(ioctl(tfd, (((2U) << (((0 +8)+8)+14)) | ((('E')) << (0 +8)) | (((0x40 + 54)) << 0) | (((((sizeof(struct input_absinfo) == sizeof(struct input_absinfo[1]) && sizeof(struct input_absinfo) < (1 << 14)) ? sizeof(struct input_absinfo) : __invalid_size_argument_for_IOC))) << ((0 +8)+8))), &info))
   {
    printf("failed, no ABS_Y\n");
    close(tfd);
    tfd = -1;
    continue;
   }
   ymin = info.minimum;
   ymax = info.maximum;
  }
  bool t = contains(name,"touch");
  bool tk = contains(name,"touchkey");
  if (t && !tk)
   printf("there is \"touch\", but not \"touchkey\" in the name\n");
  if (!(t && !tk) && (xmin < 0 || xmin == xmax))
  {
   printf("failed, xmin<0 || xmin==xmax\n");
   close(tfd);
   tfd = -1;
   continue;
  }
  mg_printf(conn,"we choose this one\n");

  __android_log_print(ANDROID_LOG_INFO,"Webkey C++","using touch device: %s",touch_device);

  ymin = info.minimum;
  ymax = info.maximum;
  mg_printf(conn,"xmin = %d, xmax = %d, ymin = %d, ymax = %d\n",xmin,xmax,ymin,ymax);
 }
 mg_printf(conn,"Please use the touchscreen on the phone for a while.\n");
 if (is_icecreamsandwich)
  mg_printf(conn, "it's ice cream sandwich\n");
 else
  mg_printf(conn, "it's not ice cream sandwich\n");
 for (i = 0; i < 500; i++)
 {
  struct input_event ev;
  if(read(touchfd, &ev, sizeof(ev)) < 0)
   mg_printf(conn,"touchfd read failed.\n");
  else
  {
   char buff[32];
   std::string m = "ev.type = ";
   if (ev.type == 3)
    m = m+"ABS("+itoa(buff, ev.type)+")";
   else if (ev.type == 0)
    m = m+"SYN("+itoa(buff, ev.type)+")";
   else
    m = m+itoa(buff, ev.type);
   m += ", ev.code = ";
   if (ev.code == 53)
    m = m+"X("+itoa(buff, ev.code)+")";
   else if (ev.code == 54)
    m = m+"Y("+itoa(buff, ev.code)+")";
   else if (ev.code == 58)
    m = m+"TOUCH("+itoa(buff, ev.code)+")";
   else if (ev.code == 48)
    m = m+"TOUCH("+itoa(buff, ev.code)+")";
   else if (ev.code == 330)
    m = m+"TOUCH("+itoa(buff, ev.code)+")";
   else
    m = m+itoa(buff, ev.code);

   m = m+ ", ev.value = "+itoa(buff, ev.value);


   mg_printf(conn,"%s\n",m.c_str());
  }
 }
 mg_printf(conn,"Finished.\n");
}

static void read_prefs()
{
 ;
 std::string sharedpref = dir + "../shared_prefs/com.webkey_preferences.xml";
 server = false;
 dyndns = false;
 FILE* sp = fopen(sharedpref.c_str(),"r");
 if (!sp)
  sp = fopen("/dbdata/databases/com.webkey/shared_prefs/com.webkey_preferences.xml","r");
 ;
 if (sp)
 {
  char buff[256];
  while (fgets(buff, sizeof(buff)-1, sp) != __null)
  {
   ;
   int n = strlen(buff);
   ;
   if (startswith(buff,"<string name=\"dddomain\">"))
   {
    int i = 0;
    for(i=24;i<n;i++)
     if (buff[i]=='<')
     {
      buff[i]=0;
      break;
     }
    dyndns_base64 = (buff+24);
    ;
   }
   if (startswith(buff,"<string name=\"hash\">"))
   {
    int i = 0;
    for(i=20;i<n;i++)
     if (buff[i]=='<')
     {
      buff[i]=0;
      break;
     }
    dyndns_base64 = (buff+20);
    ;
   }
   if (startswith(buff,"<boolean name=\"ddusing\" value=\"true\""))
   {
    dyndns = true;
    ;
   }
   if (startswith(buff,"<string name=\"port\">"))
   {
    int i = 0;
    for(i=20;i<n;i++)
     if (buff[i]=='<')
     {
      buff[i]=0;
      break;
     }
    port = strtol(buff+20, 0, 10);
    ;
   }
   if (startswith(buff,"<string name=\"sslport\">"))
   {
    int i = 0;
    for(i=23;i<n;i++)
     if (buff[i]=='<')
     {
      buff[i]=0;
      break;
     }
    sslport = strtol(buff+23, 0, 10);
    ;
   }
   if (startswith(buff,"<string name=\"random\">"))
   {
    int i = 0;
    for(i=22;i<n;i++)
     if (buff[i]=='<')
     {
      buff[i]=0;
      break;
     }
    ;
    ;
    if (!server_random || strcmp(server_random,buff+22))
    {
     char * t = server_random;
     server_random = new char[n];
     strcpy(server_random,buff+22);
     ;
     if (t)
      delete[] t;
    }
   }
   if (startswith(buff,"<string name=\"username\">"))
   {
    int i = 0;
    for(i=24;i<n;i++)
     if (buff[i]=='<')
     {
      buff[i]=0;
      break;
     }
    ;
    ;
    if (!server_username || strcmp(server_username,buff+24))
    {
     char * t = server_username;
     server_username = new char[n];
     strcpy(server_username,buff+24);
     ;
     if (t)
      delete[] t;
    }
# 8741 "webkey-2.09/service/webkey.cpp"
   }
   if (startswith(buff,"<boolean name=\"server\" value=\"true\""))
   {
    server = true;
    ;
   }
  }
  fclose(sp);
 }
}

static void
reread(struct mg_connection *conn,
                const struct mg_request_info *ri, void *data)
{
 send_ok(conn);
 if (ri->remote_ip!=2130706433 || strcmp(ri->remote_user,"JAVA_CLIENT") != 0)
 {

  return;
 }
 read_prefs();
 server_changes++;
}
static void
test(struct mg_connection *conn,
                const struct mg_request_info *ri, void *data)
{
    mg_printf(conn,"Webkey");
}
static void
javatest(struct mg_connection *conn,
                const struct mg_request_info *ri, void *data)
{
    send_ok(conn);
    mg_printf(conn,"Webkey");
}

static void
check_notify()
{
 struct timeval t;
 gettimeofday(&t, __null);

 if (notify.lastalarm + 60*notify.interval > t.tv_sec)
  return;

 bool oldstate = (notify.smson && notify.smsalarmed) || (notify.callon && notify.callalarmed);
 struct stat s;
 if (notify.smson && !stat("/data/data/com.android.providers.telephony/databases/mmssms.db",&s) && s.st_mtime != notify.lastsmstime)
 {
  notify.lastsmstime = s.st_mtime;
  std::string cmd = dir + "sqlite3 /data/data/com.android.providers.telephony/databases/mmssms.db 'select \"_id\",\"read\",\"type\" from sms where \"type\"==1 and \"read\"==0'";
  pthread_mutex_lock(&popenmutex);
  fprintf(pipeout,"%s\n",cmd.c_str());
  fflush(pipeout);
  char buff[4096];
  notify.smsalarmed = false;
  while (fgets(buff, 4096 -1, pipein) != __null)
  {
   if (strcmp(buff,"!!!END_OF_POPEN!!!\n")==0)
    break;
   else
    notify.smsalarmed = true;
  }
  pthread_mutex_unlock(&popenmutex);
 }
 if (notify.callon && !stat("/data/data/com.android.providers.contacts/databases/contacts2.db",&s) && s.st_mtime != notify.lastcalltime)
 {
  notify.lastcalltime = s.st_mtime;
  std::string cmd = dir + "sqlite3 /data/data/com.android.providers.contacts/databases/contacts2.db \'select \"_id\",\"type\",\"new\" from calls where \"type\"==3 and \"new\"==1\'";
  pthread_mutex_lock(&popenmutex);
  fprintf(pipeout,"%s\n",cmd.c_str());
  fflush(pipeout);
  char buff[4096];
  notify.callalarmed = false;
  while (fgets(buff, 4096 -1, pipein) != __null)
  {
   if (strcmp(buff,"!!!END_OF_POPEN!!!\n")==0)
    break;
   else
    notify.callalarmed = true;
  }
  pthread_mutex_unlock(&popenmutex);
 }
 if ((notify.smson && notify.smsalarmed) || (notify.callon && notify.callalarmed))
 {
  if (notify.blink && notify.blinktype == 1)
   set_blink(1,notify.blinkon,notify.blinkoff);

  if (oldstate)
  {
   if (notify.blink && notify.blinktype == 0)
    set_blink(1,notify.blinkon,notify.blinkoff);
   if (notify.vibrate)
   {
    lock_wakelock();
    int v, p, i;
    p = 0; v = 0;
    i = -1;
    bool b;
    b = false;
    while (i < notify.vibratepatt.size() || i == -1)
    {
     if (i == -1 || notify.vibratepatt[i] == '~')
     {
      p = v;
      v = getnum(notify.vibratepatt.c_str()+i+1);
      b = !b;
      if (b)
       vibrator_on(v);
      else
       usleep((p+v)*1000);
     }
     i++;
    }
    if (!b && notify.blink && notify.blinktype == 0)
     usleep(v*1000);
   }
   if (notify.blink && notify.blinktype == 0)
    set_blink(0,0,0);
  }
  notify.lastalarm = t.tv_sec;
 }
 else
  if (oldstate && notify.blink && notify.blinktype == 1)
   set_blink(0,0,0);
}

static char *jsonEscape(const char *buf, int len) {
 static const char *hexDigit = "0123456789ABCDEF";

  int count = 0;
  const char *ptr = buf;
  for (int i = 0; i < len; i++) {
    unsigned char ch = *(unsigned char *)ptr++;
    if (ch < ' ') {
      switch (ch) {
      case '\b': case '\f': case '\n': case '\r': case '\t':
        count += 2;
        break;
      default:
        count += 6;
        break;
      }
    } else if (ch == '"' || ch == '\\' || ch == '/') {
      count += 2;
    } else if (ch > '\x7F') {
      count += 6;
    } else {
      count++;
    }
  }


  char *result;
  result = new char[count + 1];
  char *dst = result;
  ptr = buf;
  for (int i = 0; i < len; i++) {
    unsigned char ch = *(unsigned char *)ptr++;
    if (ch < ' ') {
      *dst++ = '\\';
      switch (ch) {
      case '\b': *dst++ = 'b'; break;
      case '\f': *dst++ = 'f'; break;
      case '\n': *dst++ = 'n'; break;
      case '\r': *dst++ = 'r'; break;
      case '\t': *dst++ = 't'; break;
      default:
      unicode:
        *dst++ = 'u';
        *dst++ = '0';
        *dst++ = '0';
        *dst++ = hexDigit[ch >> 4];
        *dst++ = hexDigit[ch & 0xF];
        break;
      }
    } else if (ch == '"' || ch == '\\' || ch == '/') {
      *dst++ = '\\';
      *dst++ = ch;
    } else if (ch > '\x7F') {
      *dst++ = '\\';
      goto unicode;
    } else {
      *dst++ = ch;
    }
  }
  *dst++ = '\000';
  return result;
}



static int create_subprocess(pid_t* pProcessId)
{
    char *devname;

    pid_t pid;

    int ptm = open("/dev/ptmx", 00000002);
    if(ptm < 0){
        printf("[ cannot open /dev/ptmx - %s ]\n",strerror((*__errno())));
        return -1;
    }
    fcntl(ptm, 2, 1);

    if(grantpt(ptm) || unlockpt(ptm) ||
       ((devname = (char*) ptsname(ptm)) == 0)){
        printf("[ trouble with /dev/ptmx - %s ]\n", strerror((*__errno())));
        return -1;
    }


    pid = fork();
    if(pid < 0) {
        printf("- fork failed: %s -\n", strerror((*__errno())));
        return -1;
    }

    if(pid == 0){
     close(ptm);
     int pts;
     setsid();
     pts = open(devname, 00000002);
        if(pts < 0) exit(-1);


        dup2(pts, 0);
        dup2(pts, 1);
        dup2(pts, 2);

 char** env = new char*[6];
 env[0] = "TERM=xterm";
 env[1] = "LINES=25";
 env[2] = "COLUMNS=80";
 env[3] = "HOME=/sdcard";
 env[4] = "PATH=/data/local/bin:/usr/bin:/usr/sbin:/bin:/sbin:/system/bin:/system/xbin:/system/xbin/bb:/system/sbin";
 env[5] = 0;
        execle("/system/bin/bash", "/system/bin/bash", __null, env);
        execle("/system/xbin/bash", "/system/xbin/bash", __null, env);
        execle("/system/xbin/bb/bash", "/system/xbin/bb/bash", __null, env);
        execle("/system/bin/sh", "/system/bin/sh", __null, env);

        exit(-1);
    } else {
 usleep(100000);
        *pProcessId = pid;


        return ptm;
    }
}

static void
shellinabox(struct mg_connection *conn,
                const struct mg_request_info *ri, void *data)
{
 if (ri->permissions != -1)
  return;
 access_log(ri,"run terminal");
 char* post_data;
 int post_data_len;
 read_post_data(conn,ri,&post_data,&post_data_len);
 int i = 0;
 std::string param;
 std::string value;
 int p = 0;
 int width = 0;
 int height = 0;
 std::string sessionstr;
 std::string keys;
 bool keys_received = false;
 bool root_url = false;
 while (true)
 {
  if (i== post_data_len || post_data[i] == '&')
  {
   p = 0;
   if (param == "width")
    width = atoi(value.c_str());
   else if (param == "height")
    height = atoi(value.c_str());
   else if (param == "session")
    sessionstr = value;
   else if (param == "keys")
   {
    keys = value;
    keys_received = true;
   }
   else if (param == "rooturl")
    root_url = true;

   param = "";
   value = "";
  }
  else
  if (post_data[i] == '=')
  {
   p = 1;
  }
  else
  {
   if (p)
    value += post_data[i];
   else
    param += post_data[i];
  }
  if (i == post_data_len)
   break;
  i++;
 }
 send_ok(conn,"Content-type: application/json; charset=utf-8");
 SESSION* session = __null;
 int sessionid = -1;
 int ptm = 0;
 if (sessionstr.length())
  sessionid = atoi(sessionstr.c_str());
 if ( root_url )
 {
  int pid;
  while (1)
  {
   ptm = create_subprocess(&pid);
   char buf[6];
   fd_set set;
   struct timeval timeout;
   (memset (&set, 0, sizeof (*(fd_set *)(&set))));
   (((fd_set *)(&set))->fds_bits[(ptm) >> 5] |= (1<<((ptm) & 31)));
   timeout.tv_sec = 0;
   timeout.tv_usec = 100;
   int s = select(1024, &set, __null, __null, &timeout);
   if (s>0)
   {
    read(ptm,buf,6);
    break;
   }
   kill(pid,9);
  }
  session = new SESSION;
  session->pid = pid;
  session->ptm = ptm;
  session->oldwidth = 180;
  session->oldheight = 25;
  session->alive = true;
  struct timeval tv;
  gettimeofday(&tv,0);
  session->lastused = tv.tv_sec;
  pthread_mutex_init(&(session->mutex), __null);
  sessions.push_back(session);
  if (ptm >= 0)
   mg_printf(conn,"{\"session\":\"%d\",\"data\":\"\"}\n",sessions.size()-1);

  printf("terminal started\n");
  if (post_data)
   delete[] post_data;
  return;
 }
 if (sessionid == -1 || sessionid >= sessions.size())
 {

  if (post_data)
   delete[] post_data;
  return;
 }
 session = sessions[sessionid];
 if (session->alive == false)
 {
  if (post_data)
   delete[] post_data;
  return;
 }
 struct timeval tv;
 gettimeofday(&tv,0);
 session->lastused = tv.tv_sec;

 if (width && height && (width != session->oldwidth || height != session->oldheight))
 {
       struct winsize win;
       ioctl(session->ptm, 0x5413, &win);
       win.ws_row = height;
       win.ws_col = width;
       ioctl(session->ptm, 0x5414, &win);
       session->oldwidth = width;
       session->oldheight = height;

 }


  if (keys_received) {

    lock_wakelock();
    char *keyCodes;
    keyCodes = new char[keys.length()/2];
    int len = 0;
    for (const unsigned char *ptr = (const unsigned char *)keys.c_str(); ;) {
      unsigned c0 = *ptr++;
      if (c0 < '0' || (c0 > '9' && c0 < 'A') ||
          (c0 > 'F' && c0 < 'a') || c0 > 'f') {
        break;
      }
      unsigned c1 = *ptr++;
      if (c1 < '0' || (c1 > '9' && c1 < 'A') ||
          (c1 > 'F' && c1 < 'a') || c1 > 'f') {
        break;
      }
      keyCodes[len++] = 16*((c0 & 0xF) + 9*(c0 > '9')) +
                                (c1 & 0xF) + 9*(c1 > '9');
    }
    write(session->ptm, keyCodes, len);
    delete[] keyCodes;
    if (post_data)
 delete[] post_data;
    return;
  }
  if (post_data)
   delete[] post_data;
  pthread_mutex_lock(&(session->mutex));
  char buf[2048];
  fd_set set;
  struct timeval timeout;
  (memset (&set, 0, sizeof (*(fd_set *)(&set))));
  (((fd_set *)(&set))->fds_bits[(session->ptm) >> 5] |= (1<<((session->ptm) & 31)));
  timeout.tv_sec = 30;
  timeout.tv_usec = 0;
  int s = select(1024, &set, __null, __null, &timeout);
  int n = 1;
  if (s == 1)
   n = read(session->ptm,buf,2047);
  else if (s == 0)
  {
   mg_printf(conn,"{\"session\":\"%d\",\"data\":\"\"}\n",sessionid);
   pthread_mutex_unlock(&(session->mutex));
   return;
  }

  if (s<0 || n <= 0)
  {
   session->alive = false;
   close(session->ptm);

   pthread_mutex_unlock(&(session->mutex));
   return;
  }
  char* t = jsonEscape(buf,n);







 mg_printf(conn,"{\"session\":\"%d\",\"data\":\"%s\"}\n",sessionid,t);

  delete[] t;
  pthread_mutex_unlock(&(session->mutex));
}
static void
startrecord(struct mg_connection *conn,
                const struct mg_request_info *ri, void *data)
{
 if (ri->permissions != -1 && (ri->permissions&1)==0)
  return;
 lock_wakelock();
 access_log(ri,"record screenshots");
 int st = mkdir("/sdcard/webkey_TEMP", 0777);
 int orient = 0;
 bool png = false;
 if (ri->uri[12] == 'p')
  png = true;
 if (ri->uri[16] == 'h')
  orient = 1;
 int lowres = 0;
 if (ri->uri[17] == 'l')
  lowres = 1;
 firstfb = false;
 if (ri->uri[18] == 'f')
  firstfb = true;
 bool flip = false;
 if (ri->uri[19] == 'f')
  flip = true;
 recordingnum = 0;
 recordingnumfinished = -1;
 recording = true;
 while (recording && recordingnum < 1000)
 {
  if (!pict)
   init_fb();
  if (!pthread_mutex_trylock(&pngmutex))
  {

   update_image(orient,lowres,png,flip,false);
   pthread_mutex_unlock(&pngmutex);
  }
  else
  {

   pthread_mutex_lock(&pngmutex);
   pthread_mutex_unlock(&pngmutex);
  }
  lastorient = orient;
  lastflip = flip;
  if (!picchanged)
  {


   pthread_mutex_lock(&diffmutex);
   pthread_cond_broadcast(&diffstartcond);
   if (!exit_flag)
    pthread_cond_wait(&diffcond,&diffmutex);
   pthread_mutex_unlock(&diffmutex);

  }
 }
 send_ok(conn);
}
static void
finishrecord(struct mg_connection *conn,
                const struct mg_request_info *ri, void *data)
{
 if (ri->permissions != -1 && (ri->permissions&1)==0)
  return;
 lock_wakelock();
 recording = false;
 pthread_mutex_lock(&pngmutex);
 pthread_mutex_unlock(&pngmutex);
 zipFile zf = zipOpen("/sdcard/webkey_TEMP/screenshots.zip",0);
    DIR *d = opendir("/sdcard/webkey_TEMP/");
    size_t path_len = strlen("/sdcard/webkey_TEMP/");
    int r = -1;
    if (d)
    {
       struct dirent *p;
       r = 0;
       while (!r && (p=readdir(d)))
       {
    int r2 = -1;
    char *buf;
    size_t len;
    int l = strlen(p->d_name);
    if (l > 3 && (strcmp(p->d_name+l-3,"jpg") == 0 || !strcmp(p->d_name+l-3, "png")))
    {
     zip_fileinfo fi;
     fi.tmz_date.tm_year = 2010;
     fi.dosDate = 0;
     fi.internal_fa = 0;
     fi.external_fa = 0;
     if (strcmp(p->d_name+l-3,"jpg") == 0)
      zipOpenNewFileInZip(zf,p->d_name,&fi,__null,0,__null,0,"",8,(-1));
     else
      zipOpenNewFileInZip(zf,p->d_name,&fi,__null,0,__null,0,"",0,0);
     FILE* f;
     std::string path = std::string("/sdcard/webkey_TEMP/") + p->d_name;
     f = fopen(path.c_str(),"rb");
     if (!f)
      return;
     fseek (f , 0 , 2);
     int lSize = ftell (f);
     rewind (f);
     char* filebuffer = new char[lSize+1];
     if(!filebuffer)
     {
      error("not enough memory for loading tmp.png\n");
     }
     fread(filebuffer,1,lSize,f);
     filebuffer[lSize] = 0;
     zipWriteInFileInZip(zf,filebuffer,lSize);
     fclose(f);
     delete[] filebuffer;
     zipCloseFileInZip(zf);
    }
       }
       zipClose(zf,"");
       FILE* f;
       f = fopen("/sdcard/webkey_TEMP/screenshots.zip","rb");
       fseek (f , 0 , 2);
       int lSize = ftell (f);
       rewind (f);
       char* buf[65536];
       if (!f)
        return;
       send_ok(conn,"Content-Type: application/zip; charset=UTF-8\r\nContent-Disposition: attachment;filename=screenshots.zip",lSize);
       while(1)
       {
        int num_read = 0;
        if ((num_read = fread(buf, 1, 65536, f)) == 0)
         break;
        if (mg_write(conn, buf, num_read) != num_read)
         break;
       }
       fclose(f);
       remove_directory("/sdcard/webkey_TEMP");
    }
}
static void save_net_usage()
{
 pthread_mutex_lock(&netmutex);
 FILE* in = fopen("/proc/net/dev","r");
 if (!in)
  return;
 char line[256];
 char name[256];
 int i,n;
 while (fgets(line, sizeof(line)-1, in) != __null)
 {
  i = 0; while(line[i] && line[i] != ':') i++;
  if (line[i] == 0) continue;
  line[i] = 0; i++;
  while(line[i] && line[i] == ' ') i++;
  uint64_t rec = 0;
  while(line[i] && line[i] >= '0' && line[i] <= '9')
  {
   rec = rec * (uint64_t)10 + (uint64_t)(line[i]-48);
   i++;
  }
  while(line[i] && line[i] == ' ') i++; while(line[i] && line[i] != ' ') i++;
  while(line[i] && line[i] == ' ') i++; while(line[i] && line[i] != ' ') i++;
  while(line[i] && line[i] == ' ') i++; while(line[i] && line[i] != ' ') i++;
  while(line[i] && line[i] == ' ') i++; while(line[i] && line[i] != ' ') i++;
  while(line[i] && line[i] == ' ') i++; while(line[i] && line[i] != ' ') i++;
  while(line[i] && line[i] == ' ') i++; while(line[i] && line[i] != ' ') i++;
  while(line[i] && line[i] == ' ') i++; while(line[i] && line[i] != ' ') i++;
  while(line[i] && line[i] == ' ') i++;
  uint64_t send = 0;
  while(line[i] && line[i] >= '0' && line[i] <= '9')
  {
   send = send * (uint64_t)10 + (uint64_t)(line[i]-48);
   i++;
  }
  if (rec+send == 0)
   continue;
  i = 0; while(line[i] && line[i] == ' ') i++;
  strcpy(name, line+i);
  if (strcmp(name,"lo") == 0)
   continue;
  bool done = false;
  int j;
  for (j = 0; j < net_iface.size(); j++)
   if (net_iface[j] == name)
   {
    if (net_usage[j] >= rec+send)
    {
     net_usage[j] = rec+send;
     break;
    }
    sprintf(line,"INSERT INTO net (epoch,amount,interface) VALUES (%u,%llu,\"%s\")",time(__null),(rec+send-net_usage[j])>>10,name);
    net_usage[j] = rec+send;
    char* zErrMsg = __null;
    int rc = sqlite3_exec(db,line,callback, 0, &zErrMsg);
    if( rc!=0 ){
     printf("SQL error: %s\n", zErrMsg);
     sqlite3_free(zErrMsg);
    }
    break;
   }
  if (j < net_iface.size())
   continue;
  net_iface.push_back(name);
  net_usage.push_back(rec+send);

 }
 fclose(in);






 pthread_mutex_unlock(&netmutex);
}
static void
getnet(struct mg_connection *conn,
                const struct mg_request_info *ri, void *data)
{
 if (ri->permissions != -1 && (ri->permissions&16)==0)
  return;
 send_ok(conn);
 lock_wakelock();
 save_net_usage();
 access_log(ri,"net request");
 char* zErrMsg = 0;
 mg_printf(conn,"[");
 int rc = sqlite3_exec(db,"SELECT epoch,interface,amount FROM net ORDER BY epoch ASC",callback, (void*)conn, &zErrMsg);
 mg_printf(conn,"{}]");
 if( rc!=0 ){
  mg_printf(conn,"SQL error: %s\n", zErrMsg);
  sqlite3_free(zErrMsg);
 }
}
static void
set_sl4a(struct mg_connection *conn,
                const struct mg_request_info *ri, void *data)
{



 if (ri->remote_ip!=2130706433 || strcmp(ri->remote_user,"JAVA_CLIENT") != 0)
  return;
 sl4a_port = getnum(ri->uri+9);
 int i = 9;
 while (ri->uri[i] && ri->uri[i] != '_')
  i++;
 if (ri->uri[i])
  sl4a_uuid = ri->uri+i+1;



 send_ok(conn);

}

static std::string request_sl4a(struct mg_connection *conn, const char* request)
{
 std::string ret;
 char buf[10240];
 for (int i = 0; i < 30; i++)
 {


  if (sl4a_socket ==0)
  {
   if ((sl4a_socket = socket(2, 1, 0)) < 0) {

    sleep(1);
    sl4a_socket = 0;
    continue;
   }
   struct sockaddr_in addr;
   addr.sin_addr.s_addr = inet_addr("127.0.0.1");
   addr.sin_port = __extension__({ __uint16_t __swap16gen_x = (sl4a_port); (__uint16_t)((__swap16gen_x & 0xff) << 8 | (__swap16gen_x & 0xff00) >> 8); });
   addr.sin_family = 2;


   if (sl4a_port == 0 || connect(sl4a_socket, (struct sockaddr *)&addr, sizeof(struct sockaddr_in)) < 0)
   {
    shutdown(sl4a_socket,SHUT_RDWR);
    close(sl4a_socket);

    if (i%10 == 0)
     syst("/system/bin/am broadcast -a \"webkey.intent.action.SL4a.START\" -n \"com.webkey/.SL4A\"&");
    sleep(1);
    sl4a_socket = 0;
    continue;
   }



   std::string str = "{\"params\": [\"";
   str = str + sl4a_uuid.c_str();
   str = str + "\"], \"id\": 0, \"method\": \"_authenticate\"}\n";


   if (send(sl4a_socket, str.c_str(), str.size(), 0x4000) < 0)
   {
    shutdown(sl4a_socket,SHUT_RDWR);
    close(sl4a_socket);

    sleep(1);
    sl4a_socket = 0;
    continue;
   }
   bzero(buf, sizeof(buf));


   if (read(sl4a_socket, buf, sizeof(buf)-1) == 0)
   {
    shutdown(sl4a_socket,SHUT_RDWR);
    close(sl4a_socket);

    sleep(1);
    sl4a_socket = 0;
    continue;
   }

  }
  bzero(buf, sizeof(buf));


  int n = strlen(request);
  if (send(sl4a_socket, request, n,0x4000) <=0 || (request[n-1] != '\n' && send(sl4a_socket, "\n", 1,0x4000)<=0))
  {
   shutdown(sl4a_socket,SHUT_RDWR);
   close(sl4a_socket);
   sl4a_socket = 0;
   continue;
  }


  int r = 0;
  while ((r = read(sl4a_socket, buf, sizeof(buf)-1)) > 0)
  {




   ret = ret + buf;
   if (buf[r-1] == '\n')
    break;
   bzero(buf, sizeof(buf));
  }


  break;
 }
 return ret;
}
static void
sl4a(struct mg_connection *conn,
                const struct mg_request_info *ri, void *data)
{



 if (ri->permissions != -1)
  return;
 access_log(ri,"sl4a");
 send_ok(conn);
 lock_wakelock();
 char* post_data;
 int post_data_len;
 read_post_data(conn,ri,&post_data,&post_data_len);
 if (!post_data)
  return;
 pthread_mutex_lock(&sl4amutex);
 std::string ret = request_sl4a(conn,post_data);
 mg_write(conn,ret.c_str(),ret.size());
 pthread_mutex_unlock(&sl4amutex);
 if (post_data)
  delete[] post_data;

}
static void
sl4as(struct mg_connection *conn,
                const struct mg_request_info *ri, void *data)
{



 if (ri->permissions != -1)
  return;
 access_log(ri,"sl4a");
 send_ok(conn);
 lock_wakelock();
 char* post_data;
 int post_data_len;
 read_post_data(conn,ri,&post_data,&post_data_len);
 if (!post_data)
  return;
 pthread_mutex_lock(&sl4amutex);
 int i = 0;
 mg_printf(conn,"[");
 int last = 0;
 bool first = true;
 std::string ret;
 while (i < post_data_len)
 {
  if (post_data[i] == '\n')
  {
   post_data[i] = 0;
   if (!first)
    mg_printf(conn,",");
   first = false;
   ret = request_sl4a(conn,post_data+last);
   mg_write(conn,ret.c_str(),ret.size());
   last = i+1;
  }
  i++;
 }
 if (last < i)
 {
  if (!first)
   mg_printf(conn,",");
  first = false;
  ret = request_sl4a(conn,post_data+last);
  mg_write(conn,ret.c_str(),ret.size());
 }
 mg_printf(conn,"]");
 pthread_mutex_unlock(&sl4amutex);
 if (post_data)
  delete[] post_data;

}
static void
sl4ascached(struct mg_connection *conn,
                const struct mg_request_info *ri, void *data)
{



 if (ri->permissions != -1)
  return;
 access_log(ri,"sl4a");
 send_ok(conn);
 lock_wakelock();
 char* post_data;
 int post_data_len;
 read_post_data(conn,ri,&post_data,&post_data_len);
 if (!post_data)
  return;
 pthread_mutex_lock(&sl4amutex);
 int i = 0;
 mg_printf(conn,"[");
 int last = 0;
 bool first = true;
 std::string ret;
 char buff[32];
 while (i < post_data_len)
 {
  if (post_data[i] == '\n')
  {
   post_data[i] = 0;
   int rev = getnum(post_data+last);
   while(last<i && post_data[last] != '{')
    last++;
   ret = request_sl4a(conn,post_data+last);
   int drev = sl4a_requests_rev[post_data+last];
   if (ret != sl4a_requests[post_data+last])
   {
    sl4a_requests[post_data+last] = ret;
    sl4a_requests_rev[post_data+last] = ++drev;
   }
   if (rev != drev)
   {
    if (!first)
     mg_printf(conn,",");
    first = false;
    ret = ret.substr(0,ret.size()-2)+",\"rev\":"+itoa(buff,drev)+"}";
    mg_write(conn,ret.c_str(),ret.size());
   }
   last = i+1;
  }
  i++;
 }
 if (last < i)
 {
  post_data[i] = 0;
  int rev = getnum(post_data+last);
  while(last<i && post_data[last] != '{')
   last++;
  ret = request_sl4a(conn,post_data+last);
  int drev = sl4a_requests_rev[post_data+last];
  if (ret != sl4a_requests[post_data+last])
  {
   sl4a_requests[post_data+last] = ret;
   sl4a_requests_rev[post_data+last] = ++drev;
  }
  if (rev != drev)
  {
   if (!first)
    mg_printf(conn,",");
   first = false;
   ret = ret.substr(0,ret.size()-2)+",\"rev\":"+itoa(buff,drev)+"}";
   mg_write(conn,ret.c_str(),ret.size());
  }
  last = i+1;
 }
 mg_printf(conn,"]");
 pthread_mutex_unlock(&sl4amutex);
 if (post_data)
  delete[] post_data;

}

static void *event_handler(enum mg_event event,
                           struct mg_connection *conn,
                           const struct mg_request_info *request_info) {
  if (event != MG_NEW_REQUEST)
   return 0;



  void *processed = (void*)1;
  if (urlcompare(request_info->uri, "/") || urlcompare(request_info->uri,"/index.html"))
 getfile(conn, request_info, __null);
  else if (urlcompare(request_info->uri, "/phone.html"))
  {
      index(conn, request_info, __null);
  }
  else if (urlcompare(request_info->uri, "/calls.html") ||
    urlcompare(request_info->uri, "/main.html")||
    urlcompare(request_info->uri, "/gps.html")||
    urlcompare(request_info->uri, "/help.html")||
    urlcompare(request_info->uri, "/pure_menu.html")||
    urlcompare(request_info->uri, "/pure_menu_nochat.html")||
    urlcompare(request_info->uri, "/export.html")||
    urlcompare(request_info->uri, "/chat.html")||
    urlcompare(request_info->uri, "/net.html")||
    urlcompare(request_info->uri, "/sms.html")||
    urlcompare(request_info->uri, "/files.html")||
    urlcompare(request_info->uri, "/sdcard.html")||
    urlcompare(request_info->uri, "/terminal.html")||
    urlcompare(request_info->uri, "/js/webkey.js") ||
    urlcompare(request_info->uri, "/edit_gamecode.html") ||
    urlcompare(request_info->uri, "/js/screenshot.js")
    )
 getfile(conn, request_info, __null);
  else if (urlcompare(request_info->uri, "/setpassword"))
 setpassword(conn, request_info, __null);
  else if (urlcompare(request_info->uri, "/setpermission"))
 setpermission(conn, request_info, __null);
  else if (urlcompare(request_info->uri, "/register"))
 reg(conn, request_info, __null);
  else if (urlcompare(request_info->uri, "/getreg"))
 getreg(conn, request_info, __null);
  else if (urlcompare(request_info->uri, "/screenshot.*"))
 screenshot(conn, request_info, __null);
  else if (urlcompare(request_info->uri, "/injkey*"))
 key(conn, request_info, __null);
  else if (urlcompare(request_info->uri, "/oldkey*"))
 key(conn, request_info, __null);
  else if (urlcompare(request_info->uri, "/touch*"))
 touch(conn, request_info, __null);
  else if (urlcompare(request_info->uri, "/savebuttons"))
 savebuttons(conn, request_info, __null);
  else if (urlcompare(request_info->uri, "/savekeys"))
 savekeys(conn, request_info, __null);
  else if (urlcompare(request_info->uri, "/button*"))
 button(conn, request_info, __null);
  else if (urlcompare(request_info->uri, "/gpsget"))
 gpsget(conn, request_info, __null);
  else if (urlcompare(request_info->uri, "/gpsset*"))
 gpsset(conn, request_info, __null);
  else if (urlcompare(request_info->uri, "/config_buttons.html"))
 config_buttons(conn, request_info, __null);
  else if (urlcompare(request_info->uri, "/config_keys.html"))
 config_keys(conn, request_info, __null);
  else if (urlcompare(request_info->uri, "/notify.html"))
 notify_html(conn, request_info, __null);
  else if (urlcompare(request_info->uri, "/setnotify*"))
 setnotify(conn, request_info, __null);
  else if (urlcompare(request_info->uri, "/intent_*"))
 intent(conn, request_info, __null);
  else if (urlcompare(request_info->uri, "/run*"))
 run(conn, request_info, __null);
  else if (urlcompare(request_info->uri, "/stop"))
 stop(conn, request_info, __null);


  else if (urlcompare(request_info->uri, "/javatest"))
 javatest(conn, request_info, __null);
  else if (urlcompare(request_info->uri, "/config"))
 config(conn, request_info, __null);
  else if (urlcompare(request_info->uri, "/usersconfig"))
 config(conn, request_info, (void*)"nomenu");
  else if (urlcompare(request_info->uri, "/status"))
 status(conn, request_info, __null);
  else if (urlcompare(request_info->uri, "/dyndns*"))
 dyndnsset(conn, request_info, __null);
  else if (urlcompare(request_info->uri, "/new*"))
 emptyresponse(conn, request_info, __null);
  else if (urlcompare(request_info->uri, "/passwords.txt*"))
 emptyresponse(conn, request_info, __null);
  else if (urlcompare(request_info->uri, "/sdcard*"))
 sdcard(conn, request_info, __null);
  else if (urlcompare(request_info->uri, "/content.php*"))
 content(conn, request_info, __null);
  else if (urlcompare(request_info->uri, "/export_*"))
 exports(conn, request_info, __null);
  else if (urlcompare(request_info->uri, "/client/flash/content.php*"))
 content(conn, request_info, __null);
  else if (urlcompare(request_info->uri, "/TOUCHTEST"))
 testtouch(conn, request_info, __null);
  else if (urlcompare(request_info->uri, "/FBTEST"))
 testfb(conn, request_info, __null);
  else if (urlcompare(request_info->uri, "/reread"))
 reread(conn, request_info, __null);
  else if (urlcompare(request_info->uri, "/sms.xml"))
 smsxml(conn, request_info, __null);
  else if (urlcompare(request_info->uri, "/contacts.xml"))
 contactsxml(conn, request_info, __null);
  else if (urlcompare(request_info->uri, "/calls.xml"))
 callsxml(conn, request_info, __null);
  else if (urlcompare(request_info->uri, "/waitdiff"))
 waitdiff(conn, request_info, __null);
  else if (urlcompare(request_info->uri, "/sendsms"))
 sendsms(conn, request_info, __null);
  else if (urlcompare(request_info->uri, "/sendbroadcast"))
 sendbroadcast(conn, request_info, __null);
  else if (urlcompare(request_info->uri, "/shellinabox*"))
 shellinabox(conn, request_info, __null);
  else if (urlcompare(request_info->uri, "/getchatmessage_*"))
 getchatmessage(conn, request_info, __null);
  else if (urlcompare(request_info->uri, "/writechatmessage"))
 writechatmessage(conn, request_info, __null);
  else if (urlcompare(request_info->uri, "/clearchatmessage"))
 clearchatmessage(conn, request_info, __null);
  else if (urlcompare(request_info->uri, "/phonegetchatmessage_*"))
 phonegetchatmessage(conn, request_info, __null);
  else if (urlcompare(request_info->uri, "/phonewritechatmessage"))
 phonewritechatmessage(conn, request_info, __null);
  else if (urlcompare(request_info->uri, "/phoneclearchatmessage"))
 phoneclearchatmessage(conn, request_info, __null);
  else if (urlcompare(request_info->uri, "/adjust_light_*"))
 adjust_light(conn, request_info, __null);
  else if (urlcompare(request_info->uri, "/startrecord*"))
 startrecord(conn, request_info, __null);
  else if (urlcompare(request_info->uri, "/finishrecord"))
 finishrecord(conn, request_info, __null);
  else if (urlcompare(request_info->uri, "/sql"))
 sql(conn, request_info, __null);
  else if (urlcompare(request_info->uri, "/getnet"))
 getnet(conn, request_info, __null);
  else if (urlcompare(request_info->uri, "/sl4a"))
 sl4a(conn, request_info, __null);
  else if (urlcompare(request_info->uri, "/sl4as"))
 sl4as(conn, request_info, __null);
  else if (urlcompare(request_info->uri, "/sl4ascached"))
 sl4ascached(conn, request_info, __null);
  else if (urlcompare(request_info->uri, "/set_sl4a*"))
 set_sl4a(conn, request_info, __null);
  else if (urlcompare(request_info->uri, "/brightness"))
 brightness(conn, request_info, __null);
  else if (urlcompare(request_info->uri, "/netinfo"))
 netinfo(conn, request_info, __null);
  else if (urlcompare(request_info->uri, "/meminfo"))
 meminfo(conn, request_info, __null);
  else if (urlcompare(request_info->uri, "/upload*"))
 upload(conn, request_info, __null);
  else if (urlcompare(request_info->uri, "/uptime"))
 uptime(conn, request_info, __null);
  else if (urlcompare(request_info->uri, "/login"))
  {
 mg_printf(conn,"HTTP/1.1 200 OK\r\nCache-Control: no-store, no-cache, must-revalidate\r\nCache-Control: post-check=0, pre-check=0\r\nPragma: no-cache\r\nContent-Type: text/html; charset=utf-8\r\nConnection: close\r\n\r\n<html><head><meta http-equiv=\"refresh\" content=\"0;url=phone.html\"></head><body>Redirecting...</body></html>");
  }
  else if (urlcompare(request_info->uri, "/test"))
 test(conn, request_info, __null);





  else
 processed = __null;
# 9895 "webkey-2.09/service/webkey.cpp"
  return processed;
}

static void init_sqlite3()
{
 int rc;
 rc = sqlite3_open((dir+"webkey.db").c_str(), &db);
 if( rc )
 {
  printf("Can't open database: %s\n", sqlite3_errmsg(db));
  sqlite3_close(db);
  exit(1);
 }
 char *zErrMsg = 0;
 rc = sqlite3_exec(db,"CREATE TABLE net(p INTEGER PRIMARY KEY ASC, epoch INTEGER, amount INTEGER, interface TEXT);",callback, 0, &zErrMsg);
 if( rc!=0 ){
  printf("SQL error: %s\n", zErrMsg);
  sqlite3_free(zErrMsg);
 }
 char buf[32];
 rc = sqlite3_exec(db,(std::string("DELETE FROM net WHERE epoch < ")+itoa(buf,time(__null)-7776000)+";").c_str(),callback, 0, &zErrMsg);
 if( rc!=0 ){
  printf("SQL error: %s\n", zErrMsg);
  sqlite3_free(zErrMsg);
 }
# 9930 "webkey-2.09/service/webkey.cpp"
}

int main(int argc, char **argv)
{

 FILE* ___f = fopen("/data/data/com.webkey/files/log.txt","w");
 if (___f)
  fclose(___f);


 umask(00020 | 00002);



 __android_log_print(ANDROID_LOG_INFO,"Webkey C++","service's started");






 modelname[0] = 0;
 deflanguage[0] = 0;
 manufacturer[0] = 0;

 __system_property_get("ro.product.model",modelname);
 __system_property_get("ro.product.manufacturer",manufacturer);
 __system_property_get("persist.sys.language",deflanguage);

 char manu[92];
 manu[0] = 0;

 __system_property_get("ro.product.manufacturer",manu);


 char buildversion[92];
 buildversion[0] = 0;

 __system_property_get("ro.build.version.release",buildversion);




 printf("buildversion = %s\n",buildversion);
 if (buildversion[0] >= '4')
 {
  is_icecreamsandwich = true;
  use_uinput_mouse = true;
  if( access( "/dev/uinput", 0 ) == -1 &&
   access( "/dev/input/uinput", 0 ) == -1 &&
   access( "/dev/misc/uinput", 0 ) == -1)
   use_uinput_mouse = false;
 }
 if (is_icecreamsandwich)
 {
  printf("this is icrecreamsandwich\n");

 }
 if( access( "/system/usr/keylayout/geniatech.kl", 0 ) == 0)
  geniatech = true;
 if (geniatech && access( "/system/usr/idc/Webkey.idc", 0 ) == -1)
 {
  syst("mount -o remount,rw /system");
  FILE* f = fopen("/system/usr/idc/Webkey.idc","w");
  if (f)
  {
   fprintf(f,"touch.deviceType = touchScreen\n"
    "touch.orientationAware = 0\n"
    "keyboard.layout = geniatech\n"
    "keyboard.characterMap = geniatech\n"
    "keyboard.orientationAware = 1\n"
    "keyboard.builtIn = 1\n"
    "cursor.mode = navigation\n"
    "cursor.orientationAware = 0\n");
   fclose(f);
  }
  syst("mount -o remount,ro /system");
 }




 if (check_type(manu,"samsung"))
  samsung = true;
 int i;
 for (i=0;deflanguage[i] && i < 92;i++)
  if (deflanguage[i] >= 'A' && deflanguage[i] <= 'Z')
   deflanguage[i] += 'a'-'A';
 printf("deflanguage = %s\n",deflanguage);
 printf("phone model: %s\n",modelname);
 if (check_type(modelname,"GT-I5800"))
  force_240 = true;
 if (check_type(modelname,"Geeksphone ONE"))
  force_240 = true;
 if (check_type(modelname,"HTC Wildfire"))
  force_240 = true;
 if (check_type(modelname,"Dell Streak"))
 {
  is_handle_m = true;
  is_reverse_colors = true;
 }
 if (check_type(modelname,"HTC Desire HD"))
  is_handle_m = true;
 if (check_type(modelname,"HUAWEI-U8850"))
  is_reverse_colors = true;
 if (check_type(modelname,"C771"))
  is_reverse_colors = true;
 if (check_type(modelname,"U8800"))
                is_reverse_colors = true;
 if (check_type(modelname,"IS11CA"))
  is_reverse_colors = true;
 if (check_type(modelname,"GT-I9001"))
  is_reverse_colors = true;
 if (check_type(modelname,"GT-I5500"))
  is_reverse_colors = true;
 if (check_type(modelname,"GT-S5830"))
  is_reverse_colors = true;
 if (check_type(modelname,"GT-S5660"))
  is_reverse_colors = true;
 if (check_type(modelname,"GT-S5670"))
  is_reverse_colors = true;
 if (check_type(modelname,"SAMSUNG-SGH-I717"))
  is_reverse_colors = true;
 if (check_type(modelname,"Ideos S7 Slim"))
  is_reverse_colors = true;
 if (check_type(modelname,"ZTE BLADE"))
  flip_touch = true;
 if (check_type(modelname,"ZTE-SKATE"))
  flip_touch = true;
 if (check_type(modelname,"NookColor"))
  rotate_touch = true;
 if (check_type(modelname,"XT910"))
  force_544 = true;
 if (check_type(modelname,"BLADE3"))
  force_544 = true;
 if (check_type(modelname,"DROID RAZR"))
  force_544 = true;
 if (check_type(modelname,"DROID3"))
  force_544 = true;
 if (check_type(modelname,"DROID BIONIC"))
  force_544 = true;
 if (check_type(modelname,"Bionic"))
  force_544 = true;
 if (check_type(modelname,"MB865"))
  force_544 = true;
 if (check_type(modelname,"XT860"))
  force_544 = true;
 if (check_type(modelname,"DROID4"))
  force_544 = true;
 if (check_type(modelname,"SH80F"))
 {
  force_544 = true;
  is_reverse_colors = true;
 }
 if (check_type(modelname,"SH12C"))
 {
  force_544 = true;
  is_reverse_colors = true;
 }
 if (strcmp(modelname,"Nexus S")==0)
  samsung = true;
 if (strcmp(modelname,"LG-P999")==0)
  ignore_framebuffer = true;
 if (strcmp(modelname,"LG-P990")==0)
  ignore_framebuffer = true;
 if (check_type(modelname,"LT26i"))
  force_544 = true;

 pid_t pid;
 if (pipe(pipeforward))
  error("Unable to set up pipes.");
 if (pipe(pipeback))
  error("Unable to set up pipes.");

 pid = fork();
 if (pid < (pid_t)0)
 {
  error("Unable to fork().");
 }
 if (pid == 0)
 {
  close(pipeback[0]);
  close(pipeforward[1]);
  char line[4096];
  char buff[4096];
  FILE* in = fdopen(pipeforward[0],"r");
  if (!in)
   error("Unable to open pipeforward.");
  FILE* out = fdopen(pipeback[1],"w");
  if (!out)
   error("Unable to open pipeback.");
  while (fgets(line, sizeof(line)-1, in) != __null)
  {
   if (strlen(line))
    line[strlen(line)-1] = 0;
   if (line[0] == 'S')
   {
    if (fork()==0)
    {
     system(line+1);
     return 1;
    }
    fflush(out);
    continue;
   }
# 10160 "webkey-2.09/service/webkey.cpp"
    FILE* p = mypopen(line,"r");
    if (p)
    {
     while (fgets(buff, sizeof(buff)-1, p) != __null)
     {
      fprintf(out,"%s",buff);
     }
     mypclose(p);
    }
    else
     printf("error calling popen\n");

   fprintf(out,"!!!END_OF_POPEN!!!\n");
   fflush(out);
  }
  fclose(in);
  fclose(out);
  close(pipeback[1]);
  close(pipeforward[0]);
  printf("popen fork closed\n");
  return 1;
 }
 close(pipeback[1]);
 close(pipeforward[0]);
 pipeout = fdopen(pipeforward[1],"w");
 if (!pipeout)
  error("Unable to open pipeout.");
 pipein = fdopen(pipeback[0],"r");
 if (!pipein)
  error("Unable to open pipein.");





 for (i = strlen(argv[0])-1; i>=0; i--)
  if (argv[0][i] == '/')
  {
   argv[0][i+1]=0;
   break;
  }
 dir = argv[0];
 stat(argv[0], &info);

 chmod("/data/data/com.webkey/files/log.txt", 00400|00200|00040|00020);
 chown("/data/data/com.webkey/files/log.txt", info.st_uid, info.st_gid);
 chmod("/data/data/com.webkey/files/log.txt", 00400|00200|00040|00020);

 printf("dir: %s\n",dir.c_str());
 logfile = dir+"log.txt";
 pthread_mutex_init(&logmutex, __null);
 pthread_mutex_init(&sl4amutex, __null);
 pthread_mutex_init(&netmutex, __null);
 pthread_mutex_init(&initfbmutex, __null);
 pthread_mutex_init(&chatmutex, __null);
 pthread_cond_init(&chatcond,0);
 access_log(__null,"service's started");
 dirdepth = -1;
 for (i = 0; i < strlen(argv[0]); i++)
  if (argv[0][i] == '/')
   dirdepth++;


 init_sqlite3();

 port = 80;
 sslport = 443;
 read_prefs();
 if (argc >= 2)
  port = strtol (argv[1], 0, 10);
 if (argc >= 3)
  sslport = strtol (argv[2], 0, 10);
 if (port <= 0 || sslport <= 0)
  error("Invalid port\n");
 fbfd = -1;
        if (is_icecreamsandwich == false && ignore_framebuffer == false && (fbfd = open("/dev/graphics/fb0", 00000000)) == -1)
        {


  __android_log_print(ANDROID_LOG_ERROR,"Webkey C++","error opening framebuffer, let's try other tricks");





        }
 if (fbfd >= 0)
 {
  if (ioctl(fbfd, 0x4600, &scrinfo) != 0)
  {

   printf("error reading screeninfo, fall back\n");
   fbfd = -1;
  }
  if (scrinfo.xres_virtual == 240)
         scrinfo.xres_virtual = 256;
  if (scrinfo.xres == 256)
  {
   int nall = 0;
   int n;
   int fd = open("/dev/graphics/fb0", 00000000);
   char tmp[1024];
   if (fd>=0)
   {
    while (n = read(fd, tmp, 1024))
    {
     nall += n;
    }
    printf("%d\n",nall);
    close(fd);
    bytespp = scrinfo.bits_per_pixel / 8;
    if (bytespp == 3)
     bytespp = 4;
    if (scrinfo.xres*scrinfo.yres*bytespp*2 < nall)
     force_240 = true;
   }
  }
  if (force_240)
   scrinfo.xres_virtual = scrinfo.xres = 240;
 }
 if (fbfd == -1)
 {
  FILE* sc;
  int i;
  for(i = 0; screencapbinaries[i].name!=__null; i++)
  {
   printf("s %d\n",i);




    FILE* sc = mypopen(screencapbinaries[i].name,"r");




   int a;
   uint32_t size[3];
   int x,y,format;
   if (i >= 5)
   {
    char temp[1024];
    if (feof(sc) || fread(temp,1,128,sc) != 128)
    {
     printf("fread failed\n");

     mypclose(sc);
     continue;
    }
    int i = 0;
    while(i < 110 && strncmp(temp+i,"size",4)!=0) i++;
    i+=4;
    while (i < 110 && temp[i]== ' ') i++;
    x = getnum(temp+i);
    while (i < 110 && temp[i]!= 'x' && temp[i] != 'X') i++;
    i++;
    y = getnum(temp+i);
    while(i < 110 && strncmp(temp+i,"format",6)!=0) i++;
    i+=6;
    while (i < 110 && temp[i]== ' ') i++;
    format = getnum(temp+i);
    int s = 128;
    while ((i = fread(temp,1,1024,sc)) == 1024)
     s += i;
    s+=i;
    screencap_skipbytes = max(0,s-x*y*4);
    printf("xres = %d, yres = %d, format = %d, skip first %d bytes\n",x,y,format,screencap_skipbytes);

   }
   else
   {
    if (feof(sc) || (a = fread(size,4,3,sc)) != 3)
    {
     printf("fread failed a = %d\n",a);

     mypclose(sc);
     continue;
    }
    x = size[0];
    y = size[1];
    format = size[2];
    screencap_skipbytes = 12;
   }
   scrinfo.xres_virtual = scrinfo.xres = x;
   scrinfo.yres_virtual = scrinfo.yres = y;
   if (format == 4)
   {
    scrinfo.bits_per_pixel = 16;
    scrinfo.red.offset = 11;
    scrinfo.red.length = 5;
    scrinfo.green.offset = 5;
    scrinfo.green.length = 6;
    scrinfo.blue.offset = 0;
    scrinfo.blue.length = 5;
   }
   else
   {
    scrinfo.bits_per_pixel = 32;
    scrinfo.red.offset = 0;
    scrinfo.red.length = 8;
    scrinfo.green.offset = 8;
    scrinfo.green.length = 8;
    scrinfo.blue.offset = 16;
    scrinfo.blue.length = 8;
   }
   bytespp = scrinfo.bits_per_pixel / 8;
   uint32_t temp[1000];
   while (fread(temp,4,1000,sc));
   mypclose(sc);
   break;
# 10421 "webkey-2.09/service/webkey.cpp"
    }
  if (screencapbinaries[i].name == __null)
   screencap = -1;
  else
   screencap = i;
 }

 max_brightness = 255;
 int fd = open("/sys/class/leds/lcd-backlight/max_brightness", 00000000);
 if (fd < 0)
  fd = open("/sys/class/backlight/pwm-backlight/max_brightness", 00000000);
 char value[20];
 int n;
 if (fd >= 0)
 {
  n = read(fd, value, 10);
  if (n)
   max_brightness = getnum(value);
  close(fd);
 }
 char buffer[8192];
        (void) signal(17, signal_handler);
        (void) signal(15, signal_handler);
        (void) signal(2, signal_handler);
 itoa(buffer,port);


 passfile = "passwords.txt";
 FILE* pf = fopen((dir+passfile).c_str(),"r");
 if (pf)
  fclose(pf);
 else
 {
  pf = fopen((dir+passfile).c_str(),"w");
  if (pf)
   fclose(pf);
 }
 chmod((dir+passfile).c_str(), 00400|00200|00040|00020);
 chown((dir+passfile).c_str(), info.st_uid, info.st_gid);
 chmod((dir+passfile).c_str(), 00400|00200|00040|00020);
 char prot[512];
 sprintf(prot,(std::string("/favicon.ico=,/flags_=,/javatest=,/gpsset=,/stop=,/dyndns=,/reread=,/test=,/sendbroadcast=,/phonegetchatmessage=,/phonewritechatmessage=,/phoneclearchatmessage=,/index.html=,/register=,/reganim.gif=,/js/jquery=,/=")+dir+passfile).c_str());
# 10473 "webkey-2.09/service/webkey.cpp"
 struct timeval tv;
 gettimeofday(&tv,0);
 srand ( time(__null)+tv.tv_usec );
 for (i = 0; i < 10; i++)
 {
  upload_random[i] = (char)(rand()%26+97);
 }
 upload_random[10] = 0;
 char strport[16];
 char strport_ssl[16];
 char docroot[256];
 strcpy(docroot,dir.c_str());
 itoa(strport,port);
 FILE* sf = fopen((dir+"ssl_cert.pem").c_str(),"r");
 if (sf)
 {
  fclose(sf);
  has_ssl = true;
 }
 else
 {



  syst((dir+"openssl req -x509 -nodes -days 5650 -newkey rsa:1024 -keyout "+dir+"ssl_cert.pem -out "+dir+"ssl_cert.pem -config "+dir+"ssleay.cnf").c_str());

  sf = fopen((dir+"ssl_cert.pem").c_str(),"r");
  if (sf)
  {
   fclose(sf);
   has_ssl = true;
  }
 }
 if (has_ssl)
  unlink((dir+"openssl").c_str());
 static const char *options[] = {
  "document_root", docroot,
  "listening_ports", strport,
  "num_threads", "10",

  "protect_uri", prot,
  "authentication_domain", "Webkey",

  __null
 };
 strcpy(strport_ssl,strport);
 char t[10];
 itoa(t,sslport);
 strcat(strport_ssl,",");
 strcat(strport_ssl,t);
 strcat(strport_ssl,"s");
 char sslc[100];
 strcpy(sslc,(dir+"ssl_cert.pem").c_str());
 static const char *options_ssl[] = {
  "document_root", docroot,
  "listening_ports", strport_ssl,
  "ssl_certificate", sslc,
  "num_threads", "10",

  "protect_uri", prot,
  "authentication_domain", "Webkey",

  __null
 };


 if (getuid() != 0)
  error("Not running as root.\n");

 if (has_ssl)
 {
  printf("SSL is ON\n");
  if ((ctx = mg_start(upload_random,&event_handler,dir.c_str(),options_ssl)) == __null) {
   error("Cannot initialize Mongoose context");
  }
 }
 else
 {
  printf("SSL is OFF, error generating the key.\n");
  if ((ctx = mg_start(upload_random,&event_handler,dir.c_str(),options)) == __null) {
   error("Cannot initialize Mongoose context");
  }
 }

 if (ctx == __null)
  return -1;


 FILE* auth;
 if ((auth = fopen((dir+"authkey.txt").c_str(),"w")))
 {
  fprintf(auth,"%s",upload_random);
  fclose(auth);
 }
 chmod((dir+"authkey.txt").c_str(), 00400|00200|00040|00020);
 chown((dir+"authkey.txt").c_str(), info.st_uid, info.st_gid);
 chmod((dir+"authkey.txt").c_str(), 00400|00200|00040|00020);

 FILE* pidFile;
 if ((pidFile = fopen((dir+"pid.txt").c_str(),"w")))
 {
  fprintf(pidFile,"%d",getpid());
  fclose(pidFile);
 }
 chmod((dir+"pid.txt").c_str(), 00400|00200|00040|00020);
 chown((dir+"pid.txt").c_str(), info.st_uid, info.st_gid);
 chmod((dir+"pid.txt").c_str(), 00400|00200|00040|00020);

 pthread_mutex_init(&pngmutex, __null);
 pthread_mutex_init(&fbmutex, __null);
 pthread_mutex_init(&diffmutex, __null);
 pthread_mutex_init(&popenmutex, __null);
 pthread_mutex_init(&uinputmutex, __null);
 pthread_mutex_init(&wakelockmutex, __null);
 pthread_cond_init(&diffcond,0);
 pthread_cond_init(&diffstartcond,0);





 chat_random = time(__null) + tv.tv_usec;
 chat_count = 1;
 loadchat();
 wakelock = true;
 unlock_wakelock(true);
# 10607 "webkey-2.09/service/webkey.cpp"
 notify.smsalarmed = false;
 notify.callalarmed = false;
 notify.lastsmstime = 0;
 notify.lastcalltime = 0;
 notify.lastalarm = -1000000;
 FILE* in = fopen((dir + "notify.txt").c_str(),"r");
 if (in)
 {
  char buff[4096];
  if (fgets(buff, 4096 -1, in) != __null)
   setupnotify(buff);
  fclose(in);
 }
# 10629 "webkey-2.09/service/webkey.cpp"
 printf("starting touch...\n");
 init_touch();



        fflush((&__sF[1]));

 pthread_t backthread;
 backserver_parameter par;
 par.server_username = &server_username;
 par.server_random = &server_random;
 par.server = &server;
 par.server_changes = &server_changes;
 par.server_port = &(strport[0]);
 par.ctx = ctx;
 pthread_create(&backthread,__null,backserver,(void*)&par);
 pthread_t watchthread;
 pthread_create(&watchthread,__null,watchscreen,(void*)__null);

 i = 0;
 int d = 0;
 int u = 0;
 __u32 tried = 0;
 __u32 lastip = 0;
 up = 0;
 time_t net_usage_save = 0;

 save_net_usage();


 while (exit_flag == 0)
 {
  i++;
  d++;
  up++;
                sleep(1);







  if (up%20==0)
   check_notify();
  if (is_icecreamsandwich && up > shutdownkey_up && uinput_fd != -1)
  {
   pthread_mutex_lock(&uinputmutex);
   suinput_close(uinput_fd);
   uinput_fd = -1;
   pthread_mutex_unlock(&uinputmutex);
  }
  if (i==10)
  {
   unlock_wakelock(false);



   i = 0;
   if (gps_active)
   {
    gettimeofday(&tv,0);
    if (tv.tv_sec > last_gps_time + 30)
    {
     syst("/system/bin/am broadcast -a \"webkey.intent.action.GPS.STOP\" -n \"com.webkey/.GPS\"&");
     gps_active = false;
    }
   }
  }

  if (d==30 || d == 60)
  {
   pthread_mutex_lock(&chatmutex);
   pthread_cond_broadcast(&chatcond);
   pthread_mutex_unlock(&chatmutex);
  }
  if (d==60)
  {
   d=0;
   gettimeofday(&tv,0);
   if (net_usage_save+10*60 < tv.tv_sec)
   {
    net_usage_save = tv.tv_sec;
    save_net_usage();
   }
   int q;
   for (q = 0; q < sessions.size(); q++)
   {
    if (sessions[q]->alive)
    {
     if (tv.tv_sec > sessions[q]->lastused + 3600)
     {
      sessions[q]->alive = false;
      kill(sessions[q]->pid,9);
      close(sessions[q]->ptm);
      printf("CLOSED\n");
     }
    }
   }
   backdecrease();
   __u32 ip = ipaddress();



   if (ip!=lastip)
    server_changes++;

   lastip = ip;
   if(dyndns)
   {






    if (ip && ip != dyndns_last_updated_ip)
    {



     u++;
     if (tried != ip || u==10)
     {
      tried = ip;
      u = 0;
      std::string ret = update_dyndns(ip);


      __android_log_print(ANDROID_LOG_INFO,"Webkey C++","debug: ret = %s",ret.c_str());

     }
    }
   }
  }
 }
 pthread_mutex_lock(&diffmutex);
 pthread_cond_broadcast(&diffstartcond);
 pthread_mutex_unlock(&diffmutex);
 pthread_mutex_lock(&chatmutex);
 pthread_cond_broadcast(&chatcond);
 pthread_mutex_unlock(&chatmutex);
 if (gps_active)
  syst("/system/bin/am broadcast -a \"webkey.intent.action.GPS.STOP\" -n \"com.webkey/.GPS\"&");
        (void) printf("Exiting on signal %d, "
            "waiting for all threads to finish...", exit_flag);
        fflush((&__sF[1]));
        mg_stop(ctx);
        (void) printf("%s", " done.\n");
 unlock_wakelock(true);

 clear();
 pthread_mutex_destroy(&pngmutex);
 pthread_mutex_destroy(&fbmutex);
 fclose(pipeout);
 fclose(pipein);
 close(pipeback[0]);
 close(pipeforward[1]);
 sqlite3_close(db);
        return (0);
}
